<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="">
    <meta name="author" content="chuddy">
    <meta name="keywords" content="">
    <title>ssm框架 ~ chuddy&#39;s Blog</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>chuddy&#39;s Blog</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("/post.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">ssm框架</p>
            <br>
            
            <p>Tuesday, October 1st 2019, 4:25 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h3 id="SSM框架是spring-MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。"><a href="#SSM框架是spring-MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。" class="headerlink" title="SSM框架是spring MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。"></a>SSM框架是spring MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。</h3><p><strong>spring MVC</strong>：负责请求的转发和视图管理。</p>
<p><strong>spring</strong>        ：实现业务对象管理。</p>
<p><strong>mybatis</strong>      ：作为数据对象的持久化引擎。<br><a id="more"></a></p>
<h2 id="一-谈谈你对Spring框架的理解"><a href="#一-谈谈你对Spring框架的理解" class="headerlink" title="一.谈谈你对Spring框架的理解"></a>一.谈谈你对Spring框架的理解</h2><h3 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1.Spring是什么？"></a>1.Spring是什么？</h3><pre><code>**Spring一个开源的，用来简化企业级应用开发的应用开发框架。Spring的核心就是IOC（控制反转）和AOP（面向切面编程）。**
</code></pre><p><strong>  Spring容器：spring框架中的一个核心模块，用来管理对象（包括对象的创建，销毁和初始化等）。它帮助完成类的初始化与装配工作，让开发者从这些底层类的实例化，依赖关系装配类的工作中脱离出来，专注于更有意义的业务逻辑开发工作。</strong></p>
<h4 id="启动spring容器"><a href="#启动spring容器" class="headerlink" title="启动spring容器:"></a>启动spring容器:</h4><pre><code> step1.导3.2.8的包

 step2.配置xml文件+junit包(这个包是为了测试用的)

 step3.读xml文件创建容器
</code></pre><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628230449848-1113112194.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628230851305-1773785467.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628231133245-1728334698.png" alt="">               </p>
<p>   <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628231427072-1476503062.png" alt=""></p>
<p><strong>Spring如何创建对象？——spring容器依据配置文件创建对象。</strong></p>
<h4 id="方式一-无参构造器-或者缺省构造器"><a href="#方式一-无参构造器-或者缺省构造器" class="headerlink" title="方式一: 无参构造器(或者缺省构造器)"></a>方式一: 无参构造器(或者缺省构造器)</h4><p>step1:为类添加无参构造器(内部有了这个无参构造的类就可以省略这一步) </p>
<p>step2:配置文件中添加一个bean元素</p>
<p>step3:启动创建容器,调用容器的getBean方法就是实例化这个类返回对象&lt;—重要思想!!!!!!!!!!!!!</p>
<p><strong>Step1：                                                                                                                                              </strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628232752273-718818414.png" alt="">         </p>
<p><strong> step2：</strong></p>
<p>   <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628233028759-964764539.png" alt="">  </p>
<p><strong>step3：</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628233210998-448156318.png" alt="">      </p>
<h3 id="方式二-用静态工厂方法创建-了解即可-—解决抽象类"><a href="#方式二-用静态工厂方法创建-了解即可-—解决抽象类" class="headerlink" title="方式二: 用静态工厂方法创建(了解即可)—解决抽象类"></a>方式二: 用静态工厂方法创建(了解即可)—解决抽象类</h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628233808427-411302733.png" alt=""></p>
<p><strong>Calendar c = ac.getBean(“cal”,Calendar.class);</strong></p>
<h3 id="方式三-用实例工厂方法创建-了解即可-—解决抽象类"><a href="#方式三-用实例工厂方法创建-了解即可-—解决抽象类" class="headerlink" title="方式三: 用实例工厂方法创建(了解即可)—解决抽象类"></a>方式三: 用实例工厂方法创建(了解即可)—解决抽象类</h3><p>**<img src="file:///D:/tts9/workspace/webbasic/src/main/webapp/Spring/img/cj32.png" alt=""><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628234101953-343336253.png" alt=""></p>
<p><strong>Date time = ac.getBean(“time”,Date.class);**</strong></p>
<h3 id="2-Spring的作用："><a href="#2-Spring的作用：" class="headerlink" title="2.Spring的作用：**"></a><strong>2.</strong>Spring的作用：<em>**</em></h3><p><strong><strong>  a.简化开发：spring对常用的API都做了一些简化和封装（比如，用spring jdbc访问数据库，就不用考虑如何获取连接和关闭连接）。</strong></strong></p>
<p><strong><strong>  b.解耦：spring帮我们管理对象的依赖关系，这样对象间的耦合度低，方便维护。</strong></strong></p>
<p><strong><strong>  c.集成其他框架：spring可以将其他的框架集成进来。（比如可以将Mybatis等框架集成进来）</strong></strong></p>
<h3 id="1-1-ioc是什么？"><a href="#1-1-ioc是什么？" class="headerlink" title="1.1 ioc是什么？"></a>1.1 ioc是什么？</h3><h4 id="IOC——：inversion-of-control，即“控制反转”，ioc不是一种技术，是一种设计思想，一个重要的面向对象编程的法则。在java开发中，IOC意味着将你设计好的对象交给容器控制，而不是在传统的在你的对象内部直接控制。"><a href="#IOC——：inversion-of-control，即“控制反转”，ioc不是一种技术，是一种设计思想，一个重要的面向对象编程的法则。在java开发中，IOC意味着将你设计好的对象交给容器控制，而不是在传统的在你的对象内部直接控制。" class="headerlink" title="IOC——：inversion of control，即“控制反转”，ioc不是一种技术，是一种设计思想，一个重要的面向对象编程的法则。在java开发中，IOC意味着将你设计好的对象交给容器控制，而不是在传统的在你的对象内部直接控制。"></a>IOC——：inversion of control，即“控制反转”，ioc不是一种技术，是一种设计思想，一个重要的面向对象编程的法则。在java开发中，IOC意味着将你设计好的对象交给容器控制，而不是在传统的在你的对象内部直接控制。</h4><p>  <strong>何为“控制”：传统的JAVA SE程序设计，我们是从对象内部通过new创建对象，是程序控制对象的创建，而IOC有一个专门的容器（IOC容器）创建对象，IOC容器控制外部资源的获取（包括对象，文件等）。</strong></p>
<p><strong>  何为“反转”：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，即“正转”。而“反转”，是由容器来帮我们去创建及注入依赖对象。对象只是被动的接受依赖对象。依赖对象的获取被反转了。</strong></p>
<h3 id="1-2-ioc有什么用？"><a href="#1-2-ioc有什么用？" class="headerlink" title="1.2 ioc有什么用？"></a>1.2 ioc有什么用？</h3><p>  <strong>ioc容器能帮我们管理对象的依赖关系，这样对象与对象的耦合度低，方便代码的维护。对于spring框架来说，ioc就是由spring来负责控制对象的生命周期和对象间的关系。</strong></p>
<h3 id="1-3-DI"><a href="#1-3-DI" class="headerlink" title="1.3 DI"></a>1.3 DI</h3><p>  <strong>DI——dependenc injection，即“依赖注入”。IOC与DI有什么关系呢？其实它们是同一个概念的不同角度描述。“依赖注入”，相对ioc而言，“依赖注入”明确地描述了“被注入对象”依赖ioc容器配置依赖对象。IOC的一个重点是在系统运行中，动态的向某个对象提供所需要的其他对象，这一点通过DI实现。DI如何实现？这就要引入java 1.3之后的一个重要特征——反射（reflection）。它允许程序在运行的时候动态生成对象、执行对象的方法、改变对象的属性。spring就是通过反射注入的。</strong></p>
<h3 id="1-4-spring的两种注入方式"><a href="#1-4-spring的两种注入方式" class="headerlink" title="1.4 spring的两种注入方式"></a>1.4 spring的两种注入方式</h3><h3 id="1-4-1-构造器注入：通过调用的类的构造函数，将接口实现类通过构造函数变量传入。"><a href="#1-4-1-构造器注入：通过调用的类的构造函数，将接口实现类通过构造函数变量传入。" class="headerlink" title="1.4.1. 构造器注入：通过调用的类的构造函数，将接口实现类通过构造函数变量传入。"></a>1.4.1. 构造器注入：通过调用的类的构造函数，将接口实现类通过构造函数变量传入。</h3><h4 id="构造器注入步骤"><a href="#构造器注入步骤" class="headerlink" title="构造器注入步骤:"></a>构造器注入步骤:</h4><p><strong>step1.添加相应构造器：</strong>                                                                                                                               </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629065601061-1402875520.png" alt="">                 </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629065640061-949590767.png" alt=""></p>
<p><strong>step2：配置文件xml</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629065727402-864001061.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628110545841-387631255.png" alt=""></p>
<p><strong>xml的启动相当于容器的启动,constructor-arg意思是构造器,相当于写了Manager类的构造方法ref=cp相当于Computer类型的对象cp,因为构造方法里面有this.cp=cp;所以就相当与给Manager类里面的cp赋值了(类型必须是匹配的,都是Computer类型)相当于就在xml表里面写了Manager(Computer cp){},xml一启动就调用了</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629070845896-61865111.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629070905450-396029866.png" alt=""></p>
<h3 id="1-4-2-setter方法注入：是容器通过调用无参构造器或无参static-工厂方法实列化bean之后，调用该bean的setter方法，-即实现了基于setter的依赖注入"><a href="#1-4-2-setter方法注入：是容器通过调用无参构造器或无参static-工厂方法实列化bean之后，调用该bean的setter方法，-即实现了基于setter的依赖注入" class="headerlink" title="1.4.2:setter方法注入：是容器通过调用无参构造器或无参static 工厂方法实列化bean之后，调用该bean的setter方法， 即实现了基于setter的依赖注入"></a>1.4.2:setter方法注入：是容器通过调用无参构造器或无参static 工厂方法实列化bean之后，调用该bean的setter方法， 即实现了基于setter的依赖注入</h3><p>  <strong>set方法注入步骤：</strong></p>
<p>  <strong>step1.为A类添加 IB类型常量并写上setB():</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629062820378-1677294909.png" alt="">                                                       </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629062728343-393136633.png" alt="">                                 </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629062121836-953969200.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629062000911-923673844.png" alt="">                                                                                      </p>
<p> <strong>step2.配置文件xml:</strong><br><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629063342737-579823553.png" alt=""></p>
<p><strong>这个name=b相当于写了A类里面的setB方法,ref=c相当于C类型的对象c,因为set方法里面是this.b=b,所以一旦调用set方法就相当于给A类里面的b赋值了</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629064347569-190849675.png" alt=""></p>
<p> <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628110346101-1538896447.png" alt=""><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180628110359457-766455122.png" alt=""></p>
<h2 id="一-使用注解简化配置文件"><a href="#一-使用注解简化配置文件" class="headerlink" title="一.使用注解简化配置文件"></a>一.使用注解简化配置文件</h2><h3 id="组件扫描-Spring容器启动之后会检查某个包以及子包下面的所有的类-如果类前面有特定注解-比如-Component"><a href="#组件扫描-Spring容器启动之后会检查某个包以及子包下面的所有的类-如果类前面有特定注解-比如-Component" class="headerlink" title="组件扫描: Spring容器启动之后会检查某个包以及子包下面的所有的类,如果类前面有特定注解(比如@Component),"></a>组件扫描: Spring容器启动之后会检查某个包以及子包下面的所有的类,如果类前面有特定注解(比如@Component),</h3><p>则容器会将该类纳入容器进行管理(就相当于配置了一个bean元素)          </p>
<p><strong>其中init跟destroy的注释@PostConstruct跟@PreDestroy是sun公司的,要导annotation包</strong><br><strong>生命周期相关注解:@PostConstruct/@PreDestroy</strong><br><strong>延迟加载和作用域相关注解:@Lazy(true)/@Scope(“prototype”)/@Scope(“singleton”)</strong><br><strong>依赖注入相关注解(就是set注入和构造器注入):@Autowired和@Qualifier(“wt”) ，@Qualifier如果不加的话,会按照byType的方式来自动装配,就有可能找到多个,建议最好使用该注解,明确指定被注入的bean的id。</strong><br><strong>@Resource(name=”wt”): 1.只支持set方法的注入. 2.使用name属性指定被注入的bean的id</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629073211600-253122970.png" alt="">                  <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629073342764-1326497986.png" alt=""></p>
<h3 id="STEP1-在类前面加注释-方法前面加注释"><a href="#STEP1-在类前面加注释-方法前面加注释" class="headerlink" title="STEP1.在类前面加注释,方法前面加注释"></a>STEP1.在类前面加注释,方法前面加注释</h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629073656052-2135089681.png" alt=""></p>
<h3 id="STEP2-配置里面扫描包"><a href="#STEP2-配置里面扫描包" class="headerlink" title="STEP2.配置里面扫描包"></a>STEP2.配置里面扫描包</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629073617907-575418362.png" alt=""></h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629073841340-1564664979.png" alt=""></p>
<p><strong>测试结果1 :</strong>       </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629074036831-515286206.png" alt="">     </p>
<p><strong>测试结果2：</strong>                       </p>
<p> <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629074055812-1599784626.png" alt=""></p>
<p><strong>测试结果3：</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629074113691-1206929143.png" alt=""></p>
<h3 id="Restaurant是set注入，-Leader是有参构造方法注入，-Manager是-Resource-name-””-注入-lt"><a href="#Restaurant是set注入，-Leader是有参构造方法注入，-Manager是-Resource-name-””-注入-lt" class="headerlink" title="Restaurant是set注入， Leader是有参构造方法注入， Manager是@Resource(name=””)注入&lt;"></a>Restaurant是set注入， Leader是有参构造方法注入， Manager是@Resource(name=””)注入&lt;</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629110722309-1707062022.png" alt=""></h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629110759032-421354163.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629110846244-286498346.png" alt=""> </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629110910575-59598053.png" alt="">                                                                                                                                                                                                                                                        </p>
<p><strong> 测试</strong><br><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629111026134-410680688.png" alt=""></p>
<p><strong>测试结果5：</strong><br><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629111304397-1508366435.png" alt=""></p>
<p> <strong>测试结果6：</strong><br><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629111322847-898009253.png" alt=""></p>
<p><strong>测试结果7：</strong></p>
<p> <img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629111857952-1058115945.png" alt=""></p>
<h3 id="2-1-AOP"><a href="#2-1-AOP" class="headerlink" title="2.1 AOP"></a>2.1 AOP</h3><h4 id="2-1-1-Aop是什么？"><a href="#2-1-1-Aop是什么？" class="headerlink" title="2.1.1   Aop是什么？"></a>2.1.1   Aop是什么？</h4><h4 id="AOP——（Aspect-Oriented-Programming），即面向切面编程。AOP可以说是OOP的补充和完善，是Spring框架核心功能之一。"><a href="#AOP——（Aspect-Oriented-Programming），即面向切面编程。AOP可以说是OOP的补充和完善，是Spring框架核心功能之一。" class="headerlink" title="AOP——（Aspect-Oriented Programming），即面向切面编程。AOP可以说是OOP的补充和完善，是Spring框架核心功能之一。"></a>AOP——（Aspect-Oriented Programming），即面向切面编程。AOP可以说是OOP的补充和完善，是Spring框架核心功能之一。</h4><h4 id="2-1-2-AOP的特点（优势）？"><a href="#2-1-2-AOP的特点（优势）？" class="headerlink" title="2.1.2   AOP的特点（优势）？"></a>2.1.2   AOP的特点（优势）？</h4><p><strong>为了解决当我们需要为分散的对象引入公共行为的时候，如程序中交叉业务逻辑（系统日志，事务处理，系统安全验证，系统数据缓存等等），这是我们应当把它封装成一个切面，注入到目标对象（具体逻辑）中去。可以简化代码开发和效率，能够在不改变原有代码的基础上扩展新的功能实现。</strong></p>
<h3 id="2-1-3AOP-核心概念、术语"><a href="#2-1-3AOP-核心概念、术语" class="headerlink" title="2.1.3AOP 核心概念、术语"></a>2.1.3AOP 核心概念、术语</h3><h3 id="AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。其相关概念术语如下："><a href="#AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。其相关概念术语如下：" class="headerlink" title="AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。其相关概念术语如下："></a>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。其相关概念术语如下：</h3><h3 id="切面-aspect-横切面对象-一般为一个具体类对象-本质就是加了-Aspect注解的类"><a href="#切面-aspect-横切面对象-一般为一个具体类对象-本质就是加了-Aspect注解的类" class="headerlink" title="切面(aspect): 横切面对象,一般为一个具体类对象(本质就是加了@Aspect注解的类)"></a>切面(aspect): 横切面对象,一般为一个具体类对象(本质就是加了@Aspect注解的类)</h3><p>通知(advice):拦截到连接点之后只要执行的方法<br>切入点(pointcut):对连接点拦截内容的一种定义<br>连接点(joinpoint):程序执行过程中某个特定的点，一般指被拦截到的的方法<br>目标对象(target)：代理的目标对象。<br>通知(Advice):在切面的某个特定连接点上执行的动作，例如before,after等 </p>
<p>知识点术语强化:<br>1) 切面(可以简单理解为要植入的新的业务功能,这个功能交给某个类负责,这个类就是切面)<br>2) 通知(可以简单理解为一个业务中的扩展逻辑的若干步骤,例如先做什么(before),再做什么(afterReturn),最后做什么)<br>3) 切入点(在原有的哪些业务方法上扩展新的业务,可以将切入点理解为方法的集合)<br>4) 连接点(可以简单理解为切入点中的一个具体方法)<br>5) 目标对象(需要扩展功能的那个对象,一般为被代理对象)<br>6) 代理对象(负责调用切面中的方法为目标对象植入新的功能)</p>
<p>###<br>2.1.4 Spring AOP 的编程实现</p>
<h3 id="Spring中AOP代理由Spring的IOC容器负责生成、管理。"><a href="#Spring中AOP代理由Spring的IOC容器负责生成、管理。" class="headerlink" title="Spring中AOP代理由Spring的IOC容器负责生成、管理。"></a>Spring中AOP代理由Spring的IOC容器负责生成、管理。</h3><p>其依赖关系也由IOC容器负责管理。<br>因此，AOP代理可以直接使用容器中的其它bean实例作为目标，<br>这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：<br>1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了<br>2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理。</p>
<p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：<br>1. 定义普通业务组件（切面）<br>2. 定义切入点，一个切入点可能横切多个业务组件<br>3. 定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。<br>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理</p>
<h3 id="2-1-5-AOP怎么用？"><a href="#2-1-5-AOP怎么用？" class="headerlink" title="2.1.5 AOP怎么用？"></a>2.1.5 AOP怎么用？</h3><h3 id="面向切面-Aspect"><a href="#面向切面-Aspect" class="headerlink" title="面向切面@Aspect"></a>面向切面@Aspect</h3><p>step1. 导入3个Maven jar包,spring-context(里面包含了spring-aop),aspectjrt,aspectjweaver</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629161024124-2105337245.png" alt=""></h3><p>###<br>step2. 配置spring-aop.xml</p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629161135663-2055182515.png" alt=""></p>
<h3 id="step3-写一个代理类-这个类相当于切面-注解-Aspect-Component-英文意思就是切面-扫描"><a href="#step3-写一个代理类-这个类相当于切面-注解-Aspect-Component-英文意思就是切面-扫描" class="headerlink" title="step3.写一个代理类,这个类相当于切面,注解@Aspect@Component,英文意思就是切面,扫描,"></a>step3.写一个代理类,这个类相当于切面,注解@Aspect@Component,英文意思就是切面,扫描,</h3><h3 id="Order-1-多个切面类时执行顺序注解-数字越小越先执行，在方法前面加你要的功能注解并指向被代理类-称为切入点如：-Before-“bean-projectServiceImpl-”-实现类开头字母小写"><a href="#Order-1-多个切面类时执行顺序注解-数字越小越先执行，在方法前面加你要的功能注解并指向被代理类-称为切入点如：-Before-“bean-projectServiceImpl-”-实现类开头字母小写" class="headerlink" title="@Order(1)多个切面类时执行顺序注解,数字越小越先执行，在方法前面加你要的功能注解并指向被代理类,称为切入点如：@Before(“bean(projectServiceImpl)”),实现类开头字母小写"></a>@Order(1)多个切面类时执行顺序注解,数字越小越先执行，在方法前面加你要的功能注解并指向被代理类,称为切入点如：@Before(“bean(projectServiceImpl)”),实现类开头字母小写</h3><h3 id="AfterThrowing-AfterReturning-After-分别为目标方法异常后-目标方法正常结束后-目标方法之后，"><a href="#AfterThrowing-AfterReturning-After-分别为目标方法异常后-目标方法正常结束后-目标方法之后，" class="headerlink" title="@AfterThrowing @AfterReturning @After 分别为目标方法异常后,目标方法正常结束后,目标方法之后，"></a>@AfterThrowing @AfterReturning @After 分别为目标方法异常后,目标方法正常结束后,目标方法之后，</h3><p>  空间想象就是当被代理类进来的时候会先经过代理类这个’横切面’过滤,在被代理类方法运行前后记录日志</p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629161328112-544196109.png" alt="">   </p>
<p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629161649869-400938012.png" alt=""> </p>
<h3 id="step4-被代理类实质上就是业务层-必须有注解-Service"><a href="#step4-被代理类实质上就是业务层-必须有注解-Service" class="headerlink" title="step4. 被代理类实质上就是业务层,必须有注解@Service"></a>step4. 被代理类实质上就是业务层,必须有注解@Service</h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629161918859-572455540.png" alt=""></p>
<h3 id="step5-测试的时候getBean-“业务层类名开头字母小写”-指向业务层实现的那个接口的名字"><a href="#step5-测试的时候getBean-“业务层类名开头字母小写”-指向业务层实现的那个接口的名字" class="headerlink" title="step5. 测试的时候getBean(“业务层类名开头字母小写”,指向业务层实现的那个接口的名字);"></a>step5. 测试的时候getBean(“业务层类名开头字母小写”,指向业务层实现的那个接口的名字);</h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629162034161-376095449.png" alt="">     </p>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629162340724-766499400.png" alt=""></h3><p><img src="https://images2018.cnblogs.com/blog/1418314/201806/1418314-20180629162353778-158560173.png" alt=""></p>
<h3 id="step6-对面向切面的接入点封装-之后就直接调用-如-Before-“method-”"><a href="#step6-对面向切面的接入点封装-之后就直接调用-如-Before-“method-”" class="headerlink" title="step6. 对面向切面的接入点封装,之后就直接调用,如:@Before(“method()”)"></a>step6. 对面向切面的接入点封装,之后就直接调用,如:@Before(“method()”)</h3><h3 id="Pointcut-“bean-projectServiceImpl-”"><a href="#Pointcut-“bean-projectServiceImpl-”" class="headerlink" title="@Pointcut(“bean(projectServiceImpl)”)"></a>@Pointcut(“bean(projectServiceImpl)”)</h3><pre><code>public void method(){}
</code></pre>
                <hr>
                <div>
                    <p>
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>