{"meta":{"title":"chuddy's Blog","subtitle":"keep hungry keep foolish","description":null,"author":"chuddy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"ssm框架","slug":"ssm框架","date":"2020-06-03T08:25:42.000Z","updated":"2020-06-03T08:32:42.620Z","comments":true,"path":"2020/06/03/ssm框架/","link":"","permalink":"http://yoursite.com/2020/06/03/ssm框架/","excerpt":"SSM框架是spring MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。spring MVC：负责请求的转发和视图管理。 spring ：实现业务对象管理。 mybatis ：作为数据对象的持久化引擎。","text":"SSM框架是spring MVC，spring和mabatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层。spring MVC：负责请求的转发和视图管理。 spring ：实现业务对象管理。 mybatis ：作为数据对象的持久化引擎。 一.谈谈你对Spring框架的理解1.Spring是什么？**Spring一个开源的，用来简化企业级应用开发的应用开发框架。Spring的核心就是IOC（控制反转）和AOP（面向切面编程）。** Spring容器：spring框架中的一个核心模块，用来管理对象（包括对象的创建，销毁和初始化等）。它帮助完成类的初始化与装配工作，让开发者从这些底层类的实例化，依赖关系装配类的工作中脱离出来，专注于更有意义的业务逻辑开发工作。 启动spring容器: step1.导3.2.8的包 step2.配置xml文件+junit包(这个包是为了测试用的) step3.读xml文件创建容器 Spring如何创建对象？——spring容器依据配置文件创建对象。 方式一: 无参构造器(或者缺省构造器)step1:为类添加无参构造器(内部有了这个无参构造的类就可以省略这一步) step2:配置文件中添加一个bean元素 step3:启动创建容器,调用容器的getBean方法就是实例化这个类返回对象&lt;—重要思想!!!!!!!!!!!!! Step1： step2： step3： 方式二: 用静态工厂方法创建(了解即可)—解决抽象类 Calendar c = ac.getBean(“cal”,Calendar.class); 方式三: 用实例工厂方法创建(了解即可)—解决抽象类** Date time = ac.getBean(“time”,Date.class);** 2.Spring的作用：** a.简化开发：spring对常用的API都做了一些简化和封装（比如，用spring jdbc访问数据库，就不用考虑如何获取连接和关闭连接）。 b.解耦：spring帮我们管理对象的依赖关系，这样对象间的耦合度低，方便维护。 c.集成其他框架：spring可以将其他的框架集成进来。（比如可以将Mybatis等框架集成进来） 1.1 ioc是什么？IOC——：inversion of control，即“控制反转”，ioc不是一种技术，是一种设计思想，一个重要的面向对象编程的法则。在java开发中，IOC意味着将你设计好的对象交给容器控制，而不是在传统的在你的对象内部直接控制。 何为“控制”：传统的JAVA SE程序设计，我们是从对象内部通过new创建对象，是程序控制对象的创建，而IOC有一个专门的容器（IOC容器）创建对象，IOC容器控制外部资源的获取（包括对象，文件等）。 何为“反转”：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，即“正转”。而“反转”，是由容器来帮我们去创建及注入依赖对象。对象只是被动的接受依赖对象。依赖对象的获取被反转了。 1.2 ioc有什么用？ ioc容器能帮我们管理对象的依赖关系，这样对象与对象的耦合度低，方便代码的维护。对于spring框架来说，ioc就是由spring来负责控制对象的生命周期和对象间的关系。 1.3 DI DI——dependenc injection，即“依赖注入”。IOC与DI有什么关系呢？其实它们是同一个概念的不同角度描述。“依赖注入”，相对ioc而言，“依赖注入”明确地描述了“被注入对象”依赖ioc容器配置依赖对象。IOC的一个重点是在系统运行中，动态的向某个对象提供所需要的其他对象，这一点通过DI实现。DI如何实现？这就要引入java 1.3之后的一个重要特征——反射（reflection）。它允许程序在运行的时候动态生成对象、执行对象的方法、改变对象的属性。spring就是通过反射注入的。 1.4 spring的两种注入方式1.4.1. 构造器注入：通过调用的类的构造函数，将接口实现类通过构造函数变量传入。构造器注入步骤:step1.添加相应构造器： step2：配置文件xml xml的启动相当于容器的启动,constructor-arg意思是构造器,相当于写了Manager类的构造方法ref=cp相当于Computer类型的对象cp,因为构造方法里面有this.cp=cp;所以就相当与给Manager类里面的cp赋值了(类型必须是匹配的,都是Computer类型)相当于就在xml表里面写了Manager(Computer cp){},xml一启动就调用了 1.4.2:setter方法注入：是容器通过调用无参构造器或无参static 工厂方法实列化bean之后，调用该bean的setter方法， 即实现了基于setter的依赖注入 set方法注入步骤： step1.为A类添加 IB类型常量并写上setB(): step2.配置文件xml: 这个name=b相当于写了A类里面的setB方法,ref=c相当于C类型的对象c,因为set方法里面是this.b=b,所以一旦调用set方法就相当于给A类里面的b赋值了 一.使用注解简化配置文件————————————————组件扫描: Spring容器启动之后会检查某个包以及子包下面的所有的类,如果类前面有特定注解(比如@Component),则容器会将该类纳入容器进行管理(就相当于配置了一个bean元素) 其中init跟destroy的注释@PostConstruct跟@PreDestroy是sun公司的,要导annotation包生命周期相关注解:@PostConstruct/@PreDestroy延迟加载和作用域相关注解:@Lazy(true)/@Scope(“prototype”)/@Scope(“singleton”)依赖注入相关注解(就是set注入和构造器注入):@Autowired和@Qualifier(“wt”) ，@Qualifier如果不加的话,会按照byType的方式来自动装配,就有可能找到多个,建议最好使用该注解,明确指定被注入的bean的id。@Resource(name=”wt”): 1.只支持set方法的注入. 2.使用name属性指定被注入的bean的id STEP1.在类前面加注释,方法前面加注释 STEP2.配置里面扫描包 测试结果1 : 测试结果2： 测试结果3： Restaurant是set注入， Leader是有参构造方法注入， Manager是@Resource(name=””)注入&lt; 测试 测试结果5： 测试结果6： 测试结果7： 2.1 AOP2.1.1 Aop是什么？AOP——（Aspect-Oriented Programming），即面向切面编程。AOP可以说是OOP的补充和完善，是Spring框架核心功能之一。2.1.2 AOP的特点（优势）？为了解决当我们需要为分散的对象引入公共行为的时候，如程序中交叉业务逻辑（系统日志，事务处理，系统安全验证，系统数据缓存等等），这是我们应当把它封装成一个切面，注入到目标对象（具体逻辑）中去。可以简化代码开发和效率，能够在不改变原有代码的基础上扩展新的功能实现。 2.1.3AOP 核心概念、术语AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。其相关概念术语如下：切面(aspect): 横切面对象,一般为一个具体类对象(本质就是加了@Aspect注解的类)通知(advice):拦截到连接点之后只要执行的方法切入点(pointcut):对连接点拦截内容的一种定义连接点(joinpoint):程序执行过程中某个特定的点，一般指被拦截到的的方法目标对象(target)：代理的目标对象。通知(Advice):在切面的某个特定连接点上执行的动作，例如before,after等 知识点术语强化:1) 切面(可以简单理解为要植入的新的业务功能,这个功能交给某个类负责,这个类就是切面)2) 通知(可以简单理解为一个业务中的扩展逻辑的若干步骤,例如先做什么(before),再做什么(afterReturn),最后做什么)3) 切入点(在原有的哪些业务方法上扩展新的业务,可以将切入点理解为方法的集合)4) 连接点(可以简单理解为切入点中的一个具体方法)5) 目标对象(需要扩展功能的那个对象,一般为被代理对象)6) 代理对象(负责调用切面中的方法为目标对象植入新的功能) ###2.1.4 Spring AOP 的编程实现 Spring中AOP代理由Spring的IOC容器负责生成、管理。其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理。 AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：1. 定义普通业务组件（切面）2. 定义切入点，一个切入点可能横切多个业务组件3. 定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理 2.1.5 AOP怎么用？面向切面@Aspectstep1. 导入3个Maven jar包,spring-context(里面包含了spring-aop),aspectjrt,aspectjweaver ###step2. 配置spring-aop.xml step3.写一个代理类,这个类相当于切面,注解@Aspect@Component,英文意思就是切面,扫描,@Order(1)多个切面类时执行顺序注解,数字越小越先执行，在方法前面加你要的功能注解并指向被代理类,称为切入点如：@Before(“bean(projectServiceImpl)”),实现类开头字母小写@AfterThrowing @AfterReturning @After 分别为目标方法异常后,目标方法正常结束后,目标方法之后， 空间想象就是当被代理类进来的时候会先经过代理类这个’横切面’过滤,在被代理类方法运行前后记录日志 step4. 被代理类实质上就是业务层,必须有注解@Service step5. 测试的时候getBean(“业务层类名开头字母小写”,指向业务层实现的那个接口的名字); step6. 对面向切面的接入点封装,之后就直接调用,如:@Before(“method()”)@Pointcut(“bean(projectServiceImpl)”)public void method(){}","categories":[],"tags":[]},{"title":"SSM（Spring+Spring MVC+MyBatis）框架整合搭建详细步骤","slug":"SSM（Spring-Spring-MVC-MyBatis）框架整合搭建详细步骤","date":"2020-06-03T08:18:50.000Z","updated":"2020-06-03T08:31:53.289Z","comments":true,"path":"2020/06/03/SSM（Spring-Spring-MVC-MyBatis）框架整合搭建详细步骤/","link":"","permalink":"http://yoursite.com/2020/06/03/SSM（Spring-Spring-MVC-MyBatis）框架整合搭建详细步骤/","excerpt":"因为 Spring MVC 是 Spring 框架中的一个子模块，所以 Spring 与 SpringMVC 之间不存在整合的问题。实际上，SSM 框架的整合只涉及 Spring 与 MyBatis 的整合以及 Spring MVC 与 MyBatis 的整合。","text":"因为 Spring MVC 是 Spring 框架中的一个子模块，所以 Spring 与 SpringMVC 之间不存在整合的问题。实际上，SSM 框架的整合只涉及 Spring 与 MyBatis 的整合以及 Spring MVC 与 MyBatis 的整合。实现 SSM 框架的整合首先需要准备 3 个框架的 JAR 包以及其他整合所需要的 JAR 包。 在《MyBatis与Spring的整合步骤》教程中已经讲解了 Spring 与 MyBatis 框架整合所需要的 JAR 包，本节只需再加入 Spring MVC 的相关 JAR 包（spring-web-3.2.13.RELEASE.jar 和 spring-webmvc-3.2.13.RELEASE.jar）即可。因此，SSM 框架整合所需的 JAR 包如图 1 所示。 图 1 ssm 框架整合所需 JAR 包 SSM 框架整合应用测试下面是一个应用案例（根据用户名模糊查询用户信息，用户表是《第一个MyBatis程序》教程中的数据表 user），使用 SSM 框架实现该案例的具体步骤如下： 1. 创建应用并导入相关 JAR 包创建应用 ssm，将图 1 所示的 JAR 包复制到应用的 lib 中。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;${pageContext.request.contextPath }/select&quot; method=&quot;post&quot;&gt; 输入用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2. 创建信息输入页面在 WebContent 目录下创建 input.jsp 页面，具体代码如下： package com.po; /** * mybatis数据库中user表的持久化类 */ public class MyUser { private Integer uid; private String uname; private String usex; public Integer getUid() { return uid; } public void setUid(Integer uid) { this.uid = uid; } public String getUname() { return uname; } public void setUname(String uname) { this.uname = uname; } public String getUsex() { return usex; } public void setUsex(String usex) { this.usex = usex; } } 3. 创建持久化类在 src 目录下创建一个名为 com.po 的包，并在该包中创建一个 PO 类 MyUser。具体代码如下： package com.po; /** * mybatis数据库中user表的持久化类 */ public class MyUser { private Integer uid; private String uname; private String usex; public Integer getUid() { return uid; } public void setUid(Integer uid) { this.uid = uid; } public String getUname() { return uname; } public void setUname(String uname) { this.uname = uname; } public String getUsex() { return usex; } public void setUsex(String usex) { this.usex = usex; } } 4. 创建 Dao 层在 src 目录下创建一个名为 com.dao 的包，并在该包中创建一个名为 UserDao 的接口。具体代码如下： package com.dao; import java.util.List; import org.springframework.stereotype.Repository; import com.po.MyUser; @Repository(&quot;userDao&quot;) /* * 使用Spring自动扫描MyBatis的接口并装配 （Spring将指定包中所有被@Mapper注解标注的接口自动装配为Mybatis的映射接口 */ public interface UserDao { /** * 接口方法对应SQL映射文件UserMapper.xml中的id */ public List&lt;MyUser&gt; selectUserByUname(MyUser user); } 5. 创建 Service 层在 src 目录下创建一个名为 com.service 的包，并在该包中创建一个名为 UserService 的接口和该接口的实现类 UserServiceImpl。 UserService 接口的代码如下： package com.service; import java.util.List; import com.po.MyUser; public interface UserService { public List&lt;MyUser&gt; selectUserByUname(MyUser user); } UserServiceImpl 实现类的代码如下： package com.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import com.dao.UserDao; import com.po.MyUser; @Service(&quot;userService&quot;) @Transactional /** * 加上注解@Transactional可以指定这个类需要受Spring的事务管理， *注意@Transactional只能针对public属性范围内的方法添加， *本案例并不需要处理事务，在这里只是告诉读者如何使用事务 */ public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public List&lt;MyUser&gt; selectUserByUname(MyUser user) { return userDao.selectUserByUname(user); } } 6. 创建 Controller 层在 src 目录下创建一个名为 com.controller 的包，并在该包中创建一个名为 UserController 的控制器类。具体代码如下： package com.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import com.dao.UserDao; import com.po.MyUser; @Controller public class UserController { @Autowired private UserDao userDao; @RequestMapping(&quot;/select&quot;) public String select(MyUser user, Model model) { List&lt;MyUser&gt; list = userDao.selectUserByUname(user); model.addAttribute(&quot;userList&quot;, list); return &quot;userList&quot;; } } 7. 创建用户信息显示页面在 WEB-INF 目录下创建文件夹 JSP，并在该文件夹下创建用户信息显示页面 userList. jsp。具体代码如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户信息 &lt;br&gt; &lt;c:forEach items=&quot;${userList }&quot; var=&quot;user&quot;&gt; ${user.uid }&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ${user.uname }&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ${user.usex }&lt;br&gt; &lt;/c:forEach&gt; &lt;/body&gt; &lt;/html&gt; 8. 创建相关配置文件1）web.xml在 WEB-INF 目录下创建 web.xml 文件，并在该文件中实例化 ApplicationContext 容器、启动 Spring 容器、配置 DispatcherServlet 以及配置字符编码过滤器。具体代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 实例化ApplicationContext容器 --&gt; &lt;context-param&gt; &lt;!-- 加载src目录下的 applicationContext-*.xml文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 2）springmvc-servlet.xml在 WEB-INF 目录下创建 Spring MVC 的核心配置文件 springmvc-servlet.xml，在该文件中仅配置控制器扫描包和视图解析器，具体代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 使用扫描机制扫描包 --&gt; &lt;context:component-scan base-package=&quot;com.controller&quot; /&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 3）log4j.properties在 src 目录下创建 MyBatis 的日志文件 log4j.properties，具体代码如下： # Global logging configuration log4j.rootLogger=ERROR,stdout # MyBatis logging configuration... log4j.logger.com.mybatis=DEBUG # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 4）applicationContext.xml在 src 目录下创建 Spring 的配置文件 applicationContext.xml，在该文件中配置数据源、添加事务支持、开启事务注解、配置 MyBatis 工厂、进行 Mapper 代理开发以及指定扫描包。具体代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;1128&quot; /&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- 添加事务支持 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; &lt;!-- 配置mybitas工厂，同时指定数据源，并与MyBatis完美整合 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- configLocation的属性值为Mybatis的核心配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- Mapper代理开发，使用Spring自动扫描Mybatis的接口并装配 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- mybatis-spring组件的扫描器 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 指定需要扫描的包（包括子包），使注解生效。dao包在mybatis-spring组件中已经扫描，这里不在需要扫描 --&gt; &lt;context:component-scan base-package=&quot;com.service&quot; /&gt; &lt;/beans&gt; 5）创建 MyBatis 的核心配置文件和 SQL 映射文件在 src 目录下创建 com.mybatis 文件夹，并在该文件夹中创建 MyBatis 的核心配置文件 mybatis-config.xml。具体代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;mappers&gt;&lt;!-- 映射器告诉MyBatis到哪里去找映射文件 --&gt; &lt;mapper resource=&quot;com/dao/UserMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 在 com.mybatis 文件夹中创建 SQL 映射文件 UserMapper.xml。具体代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.dao.UserDao&quot;&gt; &lt;select id=&quot;selectUserByUname&quot; resultType=&quot;com.po.MyUser&quot; parameterType=&quot;com.po.MyUser&quot;&gt; select * from user where 1=1 &lt;if test=&quot;uname!=null and uname!=&#39;&#39;&quot;&gt; and uname like concat(&#39;%&#39;,#{uname},&#39;%&#39;) &lt;/if&gt; &lt;/select&gt; &lt;/mapper&gt; 9. 发布并运行应用首先将 springMVCDemo11 应用发布到 Tomcat 服务器并启动 Tomcat 服务器，然后通过地址“http://localhost:8080/ssm/input.jsp” 访问信息输入页面，运行结果如图 2 所示。 图 2 信息输入页面 在图 2 中输入用户名，例如“张”，然后单击“提交”按钮，显示如图 3 所示的结果。 图 3 用户列表页面","categories":[],"tags":[]},{"title":"pyecharts基本图表","slug":"pyecharts基本图表","date":"2020-06-03T08:16:06.000Z","updated":"2020-06-03T08:29:29.505Z","comments":true,"path":"2020/06/03/pyecharts基本图表/","link":"","permalink":"http://yoursite.com/2020/06/03/pyecharts基本图表/","excerpt":"链接地址:链接地址","text":"链接地址:链接地址首页界面","categories":[],"tags":[]},{"title":"python excel常用方法归纳总结","slug":"python-excel常用方法归纳总结","date":"2020-06-03T08:14:50.000Z","updated":"2020-06-03T08:29:43.172Z","comments":true,"path":"2020/06/03/python-excel常用方法归纳总结/","link":"","permalink":"http://yoursite.com/2020/06/03/python-excel常用方法归纳总结/","excerpt":"python excel常用方法归纳总结xlrd模块： Python的三方库xlrd用于对excel文件进行读取，可以是“.xls”或“.xlsx”格式（旧版本可能不支持“.xlsx”）。 下载安装：https://pypi.org/project/xlrd/#files，或者使用pip安装 “pip install xlrd” API文档：https://xlrd.readthedocs.io/en/latest/api.html","text":"python excel常用方法归纳总结xlrd模块： Python的三方库xlrd用于对excel文件进行读取，可以是“.xls”或“.xlsx”格式（旧版本可能不支持“.xlsx”）。 下载安装：https://pypi.org/project/xlrd/#files，或者使用pip安装 “pip install xlrd” API文档：https://xlrd.readthedocs.io/en/latest/api.htmlxlrd常用的方法： work_book = xlrd.open_workbook(filename)：打开指定路径的excel文件，返回excel处理对象，但无法打开不存在的文件。 work_book.nsheets：返回excel中的sheet个数。 work_book.sheets()：加载并返回excel中的所有sheet对象组成的列表。 work_book.sheet_by_index(sheetx)：返回对应索引的sheet对象，索引范围为range(work_book.nsheets)。 work_book.sheet_by_name(sheet_name)：返回对应sheet名称的sheet对象。 work_book.sheet_names()：返回excel中所有sheet名称组成的列表。 sheet.book：sheet所属的work_book。 sheet.name：sheet的名称。 sheet.nrows：sheet中的行数。 sheet.ncols：sheet中的列数。 sheet.row(rowx)：返回对应行的cell对象组成的列表。 sheet.row_slice(rowx, start_colx=0, end_colx=None)：返回对应行的cell对象组成的列表，也自定义切片获取行的cell对象列表。 sheet.col(colx)：返回对应列的cell对象组成的列表。 sheet.col_slice(colx, start_rowx=0, end_rowx=None)：返回对应列的cell对象组成的列表，也自定义切片获取行的cell对象列表。 sheet.cell(rowx, colx)：返回对应单元格的cell对象。 sheet.cell_value(rowx, colx)：返回对应单元格的值。 sheet.row_len(rowx)：返回对应行的有效单元格数。 sheet.get_rows()：返回一个行的迭代器，每次迭代返回一个cell对象组成的列表，即这一行的cell对象列表。 sheet.row_values(rowx, start_colx=0, end_colx=None)：返回对应行的值的列表，也可以自定义切片获取某些值。 sheet.col_values(colx, start_rowx=0, end_rowx=None)：返回对应列的值的列表，也可以自定义切片获取某些值。 sheet.cell(rowx, colx).value：返回对应单元格的值文档。","categories":[],"tags":[]},{"title":"idea基本配置","slug":"idea基本配置","date":"2020-06-03T07:47:26.000Z","updated":"2020-06-03T07:51:37.431Z","comments":true,"path":"2020/06/03/idea基本配置/","link":"","permalink":"http://yoursite.com/2020/06/03/idea基本配置/","excerpt":"","text":"最近在学习新技术时，发现许多教程都是使用IDEA开发的。因为原来使用eclipse，感觉不想换别的开发工具了。但是因为构建项目时，IDEA和eclipse还是有许多不同，因此准备把自己学习实用IDEA的资料记录下。毕竟网上好多实用教程那叫一个啰嗦，还竟是没用的配置。因为是eclipse的老用户，因此先把一些eclipse干的事实现下，再有就是扩展一些IDEA好的功能。一、IDEA的安装 官网地址：https://www.jetbrains.com/idea/download/#section=windows 百度网盘分享：https://pan.baidu.com/s/1GFGWtCYVvk03y15HFu98xA 前提：我安装在window10系统，安装版本为：2018.2，安装时间：2018年8月10日 当然了你也可以根据需要下载属于自己操作系统自己喜欢的版本。而且我是用2018.2后面有原因。 安装过程很简单，截图就不上了，就是选择一个安装路径，然后在选择桌面上生成32bit还是64bit的launtch,根据你操作系统来。貌似现在都是64bit吧。 说一下安装到最后，它让你输入注册码。也就是收费了呗。网上有很多破解的方法，还有就是搭建服务器环境之类的，总之为了免费搞了好久都不行，要么显示注册码在2017年就过期了，要么就是验证通过，但是上面又报验证码不适合之类的。为了省力气，在某宝上搜IDEA注册码，然后发给我一个长长的串，你在下图位置输入：就可以进入到开发界面了。（注：费用1年5元，真心不想在这折腾了） 完成后，软件来到这个页面： 讲一下： 1、Create New Project 这个就是我们创建新项目的地方，一般出在第一次安装或者没有项目时出现这个。 2、Import Project 这个就是引入工程，可以支持eclipse开发的项目（注意修改配置文件，坑很深）以及Maven项目。具体引入流程会在后面的博客中具体涉及。 3、Open 打开现有项目，别的IDEA开发的，拿过来打开 4、Check out from Version Control 里面下拉框有：CVS , Git,TFS,Mercurial,Subversion五个选项，这是版本控制功能，很强大，可以和对应的相关网站上的项目直接克隆到本地，很是强大。二、简单配置使用 我们因为第一次安装没有项目，所以想进行配置必须先到开发界面，因此必须先创建个项目（很蛋疼，要是没项目还不行了呢） 第一步：我们点击 Create New Project 第二步：我们可以看到左侧有许多种类型项目可以创建，这里我们选择java。同时右边的Project SDK相当于JDK，我们只需要找到我们的JDK安装目录即可。 第三步：给项目取名字，同时指定了项目了所在地（注意：在IDEA中并没有workspace概念）这里的MJava项目名只是作为一个指示作用，并不是工作空间名称。在IDEA中使用Project和Module来划分工程和项目。例如我们知道Spring是由许多模块组成，而每个模块又可以独自作为一个项目存在（例如SpringMVC/Spring Core/Spring IOC等等）因此这里可以把新建Project当做Spring的存在，而Spring的子模块作为Module。IDEA在我们新建Project时默认是Project和Module一对一对应，我们可以继续新建Module,而不能在Project中在新建Project了。当然如果我们再次新建Project，IDEA会新打开一个窗口或者将此Project覆盖，当我们想回到开始的Project时，只需重新打开。 可以看到打开的项目结构，IDEA生成项目依赖jar以及一些配置文件。.idea配置是属于Project的，而.iml属于Module的。IDEA为我们默认生成一个项目，所以出现src文件夹。这个是项目源文件。我们自己新建一个Module，然后看一下文件夹中项目分布。 可以看到文件夹中出现了我们后来创建的First项目。如果要创建另一个类型的项目，可以在顶层File中选择新建Project。 基本的创建完成后下面开始进行配置： 1.IDEA的配置基本都与setting有关，首先大家先把快捷工具栏调出来，个人认为很喜欢： 2.现在将我们最常用的总体设置栏打开 方法一：快捷键：Ctrl + ALT + s 方法二：上面菜单File - Setting 方法三：点击刚才我们调出来工具栏那个像扳手 3.下面进行具体的配置 字体设置：File | Settings | Editor | Font可以对字体大小、字体、以及行间距等进行设置 主题设置：File | Settings | Appearance &amp; Behavior | Appearance 在UI Options中Theme里面有两个主题供选择（第一个黑色背景，第二个白色背景） 编码设置：File | Settings | Editor | File Encodings 其中单选框勾选是为了在.properties文件中中文注释可以显示，而不是变为其他编码形成的不明字符。三、简单应用 下面开始进行开发一个java的Hello World程序，在我们运行程序时，下面会出现短暂的build，因为IDEA在编译我们的代码。不过编译可以进行全项目编译以及分段编译等，具体设置在菜单栏的Build中设置。 同时在打印后，出现一个out文件夹，里面文件为.class文件，即编译文件。 这里写两个快捷键 main函数快捷键：psvm + Tab(单词开头首字母) 打印语句：souf + Tab 其他快捷键发现后再记录。到这里基本能够完成简单的使用了。四、总结 IDEA功能远不止这些，后续IDEA系列要编写博客内容包括目录如下： 版本控制，与Git以及SVN等进行项目版本控制，上传更细以及Clone项目 添加Tomcat等WEB项目服务中间件 Maven项目创建 框架使用集成 JVM参数启动与断点程序测试 项目打包部署文件的导出（maven和简单的项目） 最后附上参考IDEA教程： http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/theme-settings.html","categories":[],"tags":[]},{"title":"idea下载教程","slug":"idea下载教程","date":"2020-06-03T07:40:54.000Z","updated":"2020-06-03T07:46:28.577Z","comments":true,"path":"2020/06/03/idea下载教程/","link":"","permalink":"http://yoursite.com/2020/06/03/idea下载教程/","excerpt":"1.下载IntelliJ IDEA 2018.1.6","text":"1.下载IntelliJ IDEA 2018.1.6链接：https://pan.baidu.com/s/18ZcKiPp3LU5S-la10r5icw提取码：ghn0 2.安装IntelliJ IDEA 2018.1.6 3.下载JetbrainsCrack-3.1-release-enc.jar 到 IntelliJ IDEA 2018.1.6 安装路径的bin目录下 链接：https://pan.baidu.com/s/1MFZJlJFvuJbEMoani6MhMw提取码：g1ls 4.编辑IntelliJ IDEA 2018.1.6/bin/idea64.exe.vmoptions下的配置文件（32位操作系统编辑idea.exe.vmoptions） ①Windows系统：在idea64.exe.vmoptions文件最后一行另起一行加上： -javaagent:D:/indea/bin/JetbrainsCrack-3.1-release-enc.jar 注意：红色字体就是IntelliJ IDEA 2018.1.6安装路径 ②Mac系统：在idea64.exe.vmoptions文件最后一行另起一行加上： -javaagent:../bin/JetbrainsCrack-3.1-release-enc.jar 5.重启Idea 6.填入注册码 ThisCrackLicenseId-{ &quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;, &quot;licenseeName&quot;:&quot;Rover12421&quot;, &quot;assigneeName&quot;:&quot;&quot;, &quot;assigneeEmail&quot;:&quot;rover12421@163.com&quot;, &quot;licenseRestriction&quot;:&quot;For Rover12421 Crack, Only Test! Please support genuine!!!&quot;, &quot;checkConcurrentUse&quot;:false, &quot;products&quot;:[ {&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;} ], &quot;hash&quot;:&quot;2911276/0&quot;, &quot;gracePeriodDays&quot;:7, &quot;autoProlongated&quot;:false}","categories":[],"tags":[]},{"title":"java之jar包下载","slug":"java之jar包下载","date":"2020-06-03T07:39:31.000Z","updated":"2020-06-03T07:46:37.548Z","comments":true,"path":"2020/06/03/java之jar包下载/","link":"","permalink":"http://yoursite.com/2020/06/03/java之jar包下载/","excerpt":"Java jar包下载地址","text":"Java jar包下载地址 https://mvnrepository.com/ 页面首页","categories":[],"tags":[]},{"title":"分离数据库","slug":"分离数据库","date":"2020-06-03T07:30:02.000Z","updated":"2020-06-03T07:52:48.648Z","comments":true,"path":"2020/06/03/分离数据库/","link":"","permalink":"http://yoursite.com/2020/06/03/分离数据库/","excerpt":"SQLServer之分离数据库","text":"SQLServer之分离数据库 执行“数据库分离”后，分离出来的数据库在哪里（哪个目录文件下）？ 分离后的数据库默认的存放地点是 sqlserver数据文件版安装的根目权录\\MSSQL\\Data\\数据库文件(*.mdf,*.ldf) 例如：D:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data 分离数据库注意事项 要求具有 db_owner 固定数据库角色中的成员资格。 可以分离数据库的数据和事务日志文件，然后将它们重新附加到同一或其他 SQL Server实例。 如果要将数据库更改到同一计算机的不同 SQL Server 实例或要移动数据库，分离和附加数据库会很有用。 分离数据库是指将数据库从 SQL Server 实例中删除，但使数据库在其数据文件和事务日志文件中保持不变。 之后，就可以使用这些文件将数据库附加到任何 SQL Server实例，包括分离该数据库的服务器。 如果存在下列任何情况，则不能分离数据库： 已复制并发布数据库。 如果进行复制，则数据库必须是未发布的。 必须通过运行 sp_replicationdboption禁用发布后，才能分离数据库。如果无法使用 sp_replicationdboption，可以通过运行 sp_removedbreplication删除复制。 数据库中存在数据库快照。必须首先删除所有数据库快照，然后才能分离数据库。不能分离或附加数据库快照。 该数据库正在某个数据库镜像会话中进行镜像。除非终止该会话，否则无法分离该数据库。 数据库处于可疑状态。 无法分离可疑数据库；必须将数据库设为紧急模式，才能对其进行分离。 数据库为系统数据库。 分离只读数据库将会丢失有关差异备份的差异基准的信息。 分离数据库时生成的错误会阻止完全关闭数据库和重新生成事务日志。 收到错误消息后，请执行下列更正操作： 重新附加与数据库关联的所有文件，而不仅仅是主文件。 解决导致生成错误消息的问题。 再次分离数据库。 使用SSMS数据库工具分离数据库 1、连接服务器-》展开服务器-》选择数据库-》右键点击-》选择任务-》选择分离。 2、在分离数据库对话框-》右边要分离得数据库对话框-》数据库名称：列出要分离的数据库-》删除连接：断开与指定数据库的连接，不能分离连接为活动状态的数据库-》更新统计信息：默认情况下，分离操作将在分离数据库时保留过期的优化统计信息；若要更新现有的优化统计信息，请单击此复选框-》状态：显示以下状态之一： 就绪或 未就绪-》消息：当数据库进行了复制操作，则 状态为未就绪， 消息列将显示已复制数据库。如果数据库有一个或多个活动连接，则状态为未就绪，消息列显示&lt;number_of_active_connections&gt; 个活动连接，例如：1 个活动连接。 在分离数据库之前，需要通过选择 删除连接断开所有活动连接。 3、数据库分离结果。使用T-SQL脚本分离数据库 语法 --声明数据库引用 use other_database_name; go --语法 exec sp_detach_db [@dbname=] &#39;database_name&#39; [,[@skipchecks= ] &#39;skipchecks&#39;] [,[@keepfulltextindexfile=] &#39;KeepFulltextIndexFile&#39; ]; go 语法注释 --语法示例 --other_database_name --声明当前使用的数据库不是要分离的数据库 --[@dbname=]&#39;database_name&#39; --要分离的数据库的名称。database_name是sysname值，默认值为NULL。 --[@skipchecks =]&#39;skipchecks&#39; --指定跳过还是运行update statistic。同时将skipchecks是nvarchar(10)值，默认值为NULL。 --若要跳过更新统计信息，请指定，则返回 true。 若要显式运行更新统计信息，请指定false。 --默认情况下，执行update statistic可更新有关表和索引中的数据的信息。 对于要移动到只读介质的数据库，执行 UPDATE STATISTICS 非常有用。 --[@keepfulltextindexfile=] &#39;KeepFulltextIndexFile&#39; --指定在数据库分离操作过程中不会删除与所分离的数据库关联的全文索引文件。 --KeepFulltextIndexFile是nvarchar(10)值，该值具有默认值为true。 --如果KeepFulltextIndexFile是false、 与数据库关联的全文索引的所有文件和全文索引的元数据被删除，除非数据库是只读的。 --如果为NULL，则返回true，全文索引相关的元数据保留。 --@keepfulltextindexfile中的未来版本将删除参数SQL Server。请不要在新的开发工作中使用此参数，并尽快修改当前仍在使用此参数的应用程序。 示例 --声明数据库引用 use master; go --进行数据库分离 --方式一 --exec sp_detach_db @dbname=&#39;testss&#39; --,@skipchecks=&#39;true&#39; --,@keepfulltextindexfile=&#39;true&#39;; --方式二 exec sp_detach_db &#39;testss&#39; ,&#39;true&#39; ,&#39;true&#39;; go 示例结果：T-SQL脚本执行完毕需要在对象资源管理器刷新才能看到分离结果。 分类: SQLServer","categories":[],"tags":[]}]}